import { HashingImpl } from './hashing-impl';
export declare class FileHasher {
    private readonly hashing;
    fileHashes: {
        [path: string]: string;
    };
    workspaceFiles: Set<string>;
    usesGitForHashing: boolean;
    private isInitialized;
    constructor(hashing: HashingImpl);
    clear(): void;
    /**
     * For the project graph daemon server use-case we can potentially skip expensive work
     * by leveraging knowledge of the uncommitted and untracked files, so the init() method
     * returns a Map containing this data.
     */
    init(): Map<string, string>;
    /**
     * This method is used in cases where we do not want to fully tear down the
     * known state of file hashes, and instead only want to hash an updated Map
     * of files which are provided to the method.
     *
     * For example, the daemon server performs file-watching and knows at a granular
     * level what needs to be rehashed in order to accurately update the overall state.
     */
    incrementalUpdate(updatedHashes: Map<string, string>): void;
    /**
     * In the case of the daemon server, because it performs file-watching, it
     * knows when one or more files have been deleted from the workspace and can
     * therefore precisely update the source of truth for file hashes and workspace
     * files.
     */
    removeFiles(deletedFiles: string[]): void;
    hashFile(path: string): string;
    ensureInitialized(): void;
    private applyFileHashes;
    private processPath;
}
export declare const defaultFileHasher: FileHasher;
