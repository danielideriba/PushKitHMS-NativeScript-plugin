"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getProjectGraphFromServer = exports.isServerAvailable = exports.stop = exports.startInCurrentProcess = exports.startInBackground = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const app_root_1 = require("@nrwl/tao/src/utils/app-root");
const child_process_1 = require("child_process");
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const tmp_1 = require("tmp");
const cache_1 = require("../cache");
const net_1 = require("net");
const socket_utils_1 = require("../socket-utils");
const perf_hooks_1 = require("perf_hooks");
const fs_1 = require("fs");
function startInBackground() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        /**
         * For now, while the daemon is an opt-in feature, we will log to stdout when
         * starting the server, as well as providing a reference to where any subsequent
         * log files can be found.
         */
        const tmpDirPrefix = `nx-daemon--${devkit_1.normalizePath(app_root_1.appRootPath).replace(
        // Replace the occurrences of / in the unix-style normalized path with a -
        new RegExp(escapeRegExp('/'), 'g'), '-')}`;
        const serverLogOutputDir = tmp_1.dirSync({
            prefix: tmpDirPrefix,
        }).name;
        const serverLogOutputFile = path_1.join(serverLogOutputDir, 'nx-daemon.log');
        fs_extra_1.ensureFileSync(serverLogOutputFile);
        // Clean up any existing orphaned background process before creating a new one
        const cachedDaemonJson = yield cache_1.readDaemonJsonCache();
        if (cachedDaemonJson) {
            if (cachedDaemonJson.backgroundProcessId) {
                process.kill(cachedDaemonJson.backgroundProcessId);
            }
        }
        devkit_1.logger.info(`NX Daemon Server - Starting in a background process...`);
        devkit_1.logger.log(`  Logs from the Daemon process can be found here: ${serverLogOutputFile}\n`);
        try {
            const backgroundProcess = child_process_1.spawn(process.execPath, ['../server/start.js', serverLogOutputFile], {
                cwd: __dirname,
                stdio: 'ignore',
                detached: true,
            });
            backgroundProcess.unref();
            // Persist metadata about the background process so that it can be cleaned up later if needed
            const daemonJson = {
                backgroundProcessId: backgroundProcess.pid,
                serverLogOutputFile: serverLogOutputFile,
            };
            yield cache_1.writeDaemonJsonCache(daemonJson);
            /**
             * Ensure the server is actually available to connect to via IPC before resolving
             */
            return new Promise((resolve) => {
                const id = setInterval(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    if (yield isServerAvailable()) {
                        clearInterval(id);
                        resolve();
                    }
                }), 500);
            });
        }
        catch (err) {
            devkit_1.logger.error(err);
            process.exit(1);
        }
    });
}
exports.startInBackground = startInBackground;
function startInCurrentProcess() {
    devkit_1.logger.info(`NX Daemon Server - Starting in the current process...`);
    child_process_1.spawnSync(process.execPath, ['./start.js'], {
        cwd: __dirname,
        stdio: 'inherit',
    });
}
exports.startInCurrentProcess = startInCurrentProcess;
function stop() {
    devkit_1.logger.info(`NX Daemon Server - Stopping...`);
    child_process_1.spawnSync(process.execPath, ['../server/stop.js'], {
        cwd: __dirname,
        stdio: 'inherit',
    });
}
exports.stop = stop;
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}
/**
 * As noted in the comments above the createServer() call, in order to reliably (meaning it works
 * cross-platform) check whether or not the server is availabe to request a project graph from we
 * need to actually attempt connecting to it.
 *
 * Because of the behavior of named pipes on Windows, we cannot simply treat them as a file and
 * check for their existence on disk (unlike with Unix Sockets).
 */
function isServerAvailable() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const socket = net_1.connect(socket_utils_1.FULL_OS_SOCKET_PATH);
            return new Promise((resolve) => {
                socket.on('connect', () => {
                    socket.destroy();
                    resolve(true);
                });
                socket.on('error', () => {
                    resolve(false);
                });
            });
        }
        catch (_a) {
            return Promise.resolve(false);
        }
    });
}
exports.isServerAvailable = isServerAvailable;
/**
 * Establishes a client connection to the daemon server for use in project graph
 * creation utilities.
 *
 * All logs are performed by the devkit logger because this logic does not
 * run "on the server" per se and therefore does not write to its log output.
 *
 * TODO: Gracefully handle a server shutdown (for whatever reason) while a client
 * is connecting and querying it.
 */
function getProjectGraphFromServer() {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            perf_hooks_1.performance.mark('getProjectGraphFromServer-start');
            const socket = net_1.connect(socket_utils_1.FULL_OS_SOCKET_PATH);
            socket.on('error', (err) => {
                let errorMessage;
                if (err.message.startsWith('connect ENOENT')) {
                    errorMessage = 'Error: The Daemon Server is not running';
                }
                if (err.message.startsWith('connect ECONNREFUSED')) {
                    // If somehow the file descriptor had not been released during a previous shut down.
                    if (fs_1.existsSync(socket_utils_1.FULL_OS_SOCKET_PATH)) {
                        errorMessage = `Error: A server instance had not been fully shut down. Please try running the command again.`;
                        socket_utils_1.killSocketOrPath();
                    }
                }
                devkit_1.logger.error(`NX Daemon Client - ${errorMessage || err}`);
                return reject(new Error(errorMessage) || err);
            });
            /**
             * Immediately after connecting to the server we send it the known project graph creation
             * request payload. See the notes above createServer() for more context as to why we explicitly
             * request the graph from the client like this.
             */
            socket.on('connect', () => {
                socket.write('REQUEST_PROJECT_GRAPH_PAYLOAD');
                let serializedProjectGraph = '';
                socket.on('data', (data) => {
                    serializedProjectGraph += data.toString();
                });
                socket.on('end', () => {
                    try {
                        perf_hooks_1.performance.mark('json-parse-start');
                        const projectGraph = JSON.parse(serializedProjectGraph);
                        perf_hooks_1.performance.mark('json-parse-end');
                        perf_hooks_1.performance.measure('deserialize graph on the client', 'json-parse-start', 'json-parse-end');
                        devkit_1.logger.info('NX Daemon Client - Resolved ProjectGraph');
                        perf_hooks_1.performance.measure('total for getProjectGraphFromServer()', 'getProjectGraphFromServer-start', 'json-parse-end');
                        return resolve(projectGraph);
                    }
                    catch (_a) {
                        devkit_1.logger.error('NX Daemon Client - Error: Could not deserialize the ProjectGraph');
                        return reject(new Error('Could not deserialize the ProjectGraph'));
                    }
                });
            });
        });
    });
}
exports.getProjectGraphFromServer = getProjectGraphFromServer;
//# sourceMappingURL=client.js.map