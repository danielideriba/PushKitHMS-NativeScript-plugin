"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseProjectNameFromPath = exports.sanitizeCommaDelimitedArg = exports.prerun = exports.getAppPaths = exports.getRootTsConfigPath = exports.copy = exports.getNxWorkspaceConfig = exports.updateFile = exports.updateJsonFile = exports.getJsonFromFile = exports.jsonParse = exports.isTesting = exports.setTest = exports.isXplatWorkspace = exports.getAppName = exports.getGroupByName = exports.getFrontendFramework = exports.getPrefix = exports.getNpmScope = exports.supportedFrameworks = exports.supportedPlatformsWithNx = exports.supportedNxExtraPlatforms = exports.supportedPlatforms = void 0;
const schematics_1 = require("@angular-devkit/schematics");
const devkit_1 = require("@nrwl/devkit");
const workspace_1 = require("@nrwl/workspace");
exports.supportedPlatforms = [
    'web',
    'nativescript',
    'ionic',
    'electron',
];
exports.supportedNxExtraPlatforms = [
    'express',
    'nest',
    'node',
    'react',
];
exports.supportedPlatformsWithNx = exports.supportedPlatforms.concat(exports.supportedNxExtraPlatforms);
exports.supportedFrameworks = ['angular']; //, 'react', 'vue'];
let npmScope;
// selector prefix to use when generating various boilerplate for xplat support
let prefix;
// user preferred default framework
let frontendFramework;
// Group by app name (appname-platform) instead of the default (platform-appname)
let groupByName = false;
let isTest = false;
let usingXplatWorkspace = false;
function getNpmScope() {
    return npmScope;
}
exports.getNpmScope = getNpmScope;
function getPrefix() {
    return prefix;
}
exports.getPrefix = getPrefix;
function getFrontendFramework() {
    return frontendFramework;
}
exports.getFrontendFramework = getFrontendFramework;
function getGroupByName() {
    return groupByName;
}
exports.getGroupByName = getGroupByName;
function getAppName(options, platform) {
    return groupByName
        ? options.name.replace(`-${platform}`, '')
        : options.name.replace(`${platform}-`, '');
}
exports.getAppName = getAppName;
function isXplatWorkspace() {
    return usingXplatWorkspace;
}
exports.isXplatWorkspace = isXplatWorkspace;
function setTest() {
    isTest = true;
}
exports.setTest = setTest;
function isTesting() {
    return isTest;
}
exports.isTesting = isTesting;
function jsonParse(content) {
    if (content) {
        // ensure comments are stripped when parsing (otherwise will fail)
        return devkit_1.parseJson(content);
    }
    return {};
}
exports.jsonParse = jsonParse;
function getJsonFromFile(tree, path) {
    // console.log('getJsonFromFile:', path)
    return jsonParse(tree.get(path).content.toString());
}
exports.getJsonFromFile = getJsonFromFile;
function updateJsonFile(tree, path, jsonData) {
    try {
        // if (tree.exists(path)) {
        tree.overwrite(path, workspace_1.serializeJson(jsonData));
        // }
        return tree;
    }
    catch (err) {
        // console.warn(err);
        throw new schematics_1.SchematicsException(`${path}: ${err}`);
    }
}
exports.updateJsonFile = updateJsonFile;
function updateFile(tree, path, content) {
    try {
        // if (tree.exists(path)) {
        tree.overwrite(path, content);
        // }
        return tree;
    }
    catch (err) {
        // console.warn(err);
        throw new schematics_1.SchematicsException(`${path}: ${err}`);
    }
}
exports.updateFile = updateFile;
function getNxWorkspaceConfig(tree) {
    const nxConfig = getJsonFromFile(tree, 'nx.json');
    const hasWorkspaceDirs = tree.exists('apps') && tree.exists('libs');
    // determine if Nx workspace
    if (nxConfig) {
        if (nxConfig.npmScope || hasWorkspaceDirs) {
            return nxConfig;
        }
    }
    throw new schematics_1.SchematicsException('@nstudio/xplat must be used inside an Nx workspace. Create a workspace first. https://nx.dev');
}
exports.getNxWorkspaceConfig = getNxWorkspaceConfig;
const copy = (tree, from, to) => {
    const file = tree.get(from);
    if (!file) {
        throw new schematics_1.SchematicsException(`File ${from} does not exist!`);
    }
    tree.create(to, file.content);
};
exports.copy = copy;
function getRootTsConfigPath() {
    return '/tsconfig.base.json';
}
exports.getRootTsConfigPath = getRootTsConfigPath;
function getAppPaths(tree, type // by default, will return all app paths (considering folder nesting)
) {
    const appsDir = tree.getDir('apps');
    const appPaths = [];
    const checkIfPlatform = (dirPath) => {
        let packagePath = `${dirPath}/package.json`;
        // check for platform via it's package (web is only app type that doesn't have a package)
        switch (type) {
            case 'nativescript':
                if (tree.exists(`${dirPath}/nativescript.config.ts`) || tree.exists(`${dirPath}/nsconfig.json`)) {
                    appPaths.push(dirPath);
                }
                break;
            case 'ionic':
                if (tree.exists(packagePath)) {
                    const packageData = getJsonFromFile(tree, packagePath);
                    if (packageData.dependencies &&
                        packageData.dependencies['@capacitor/core']) {
                        appPaths.push(dirPath);
                    }
                }
                break;
            case 'electron':
                let embeddedPackage = `${dirPath}/src/package.json`;
                if (tree.exists(embeddedPackage)) {
                    const packageData = getJsonFromFile(tree, embeddedPackage);
                    if (packageData.build && packageData.build.appId) {
                        appPaths.push(dirPath);
                    }
                }
                break;
            case 'web':
                if (!tree.exists(packagePath)) {
                    // web app when no package is present
                    appPaths.push(dirPath);
                }
                break;
        }
    };
    for (const dir of appsDir.subdirs) {
        let tsconfigPath = `${appsDir.path}/${dir}/tsconfig.json`;
        if (tree.exists(tsconfigPath)) {
            // this is an app directory
            if (type) {
                checkIfPlatform(`${appsDir.path}/${dir}`);
            }
            else {
                appPaths.push(`${appsDir.path}/${dir}`);
            }
        }
        else {
            // apps in nested folders
            const subDirs = tree.getDir(`${appsDir.path}/${dir}`).subdirs;
            for (const subDir of subDirs) {
                tsconfigPath = `${appsDir.path}/${dir}/${subDir}/tsconfig.json`;
                if (tree.exists(tsconfigPath)) {
                    // this is an app directory
                    if (type) {
                        checkIfPlatform(`${appsDir.path}/${dir}/${subDir}`);
                    }
                    else {
                        appPaths.push(`${appsDir.path}/${dir}/${subDir}`);
                    }
                }
            }
        }
    }
    return appPaths;
}
exports.getAppPaths = getAppPaths;
function prerun(options, init) {
    return (tree) => {
        const nxJson = getNxWorkspaceConfig(tree);
        if (nxJson) {
            npmScope = nxJson.npmScope || 'workspace';
        }
        // console.log('npmScope:', npmScope);
        const packageJson = getJsonFromFile(tree, 'package.json');
        let frameworkChoice;
        if (options && options.framework) {
            // can actually specify comma delimited list of frameworks to generate support for
            // most common to generate 1 at a time but we allow multiple
            const frameworks = sanitizeCommaDelimitedArg(options.framework);
            // always default framework choice to first in list when multiple
            // when it's just one (most common) will be first already
            frameworkChoice = frameworks[0];
        }
        // console.log('frameworkChoice:', frameworkChoice);
        if (packageJson) {
            prefix = '';
            if (packageJson.xplat) {
                usingXplatWorkspace = true;
                const xplatSettings = packageJson.xplat; //<IXplatSettings>packageJson.xplat;
                // use persisted xplat settings
                prefix = xplatSettings.prefix || npmScope; // (if not prefix, default to npmScope)
                frontendFramework = xplatSettings.framework;
                if (options) {
                    if (options.prefix) {
                        // always use explicit prefix user passed in
                        prefix = options.prefix;
                    }
                    else {
                        // ensure options are updated
                        options.prefix = prefix;
                    }
                    if (frameworkChoice) {
                        // always override default framework when user has explicitly passed framework option in
                        frontendFramework = frameworkChoice;
                    }
                    // else if (frontendFramework) {
                    //   // ensure the options use the default
                    //   options.framework = frontendFramework;
                    // }
                }
                // grouping
                groupByName =
                    xplatSettings.groupByName || (options ? options.groupByName : false);
            }
            else if (options) {
                groupByName = options.groupByName;
                if (options.prefix) {
                    if (!prefix && init) {
                        // initializing for first time
                        prefix = options.prefix;
                    }
                }
                else {
                    // default to npmScope for prefix
                    options.prefix = npmScope;
                }
                if (frameworkChoice) {
                    if (!frontendFramework && init) {
                        frontendFramework = frameworkChoice;
                    }
                }
            }
            // console.log('prefix:', prefix);
            // if (!prefix) {
            //   if (init) {
            //     // if no prefix was found and we're initializing, user need to specify a prefix
            //     throw new SchematicsException(errorMissingPrefix);
            //   } else {
            //     // if no prefix was found and we're not initializing, user needs to generate xplat first
            //     throw new SchematicsException(errorXplat);
            //   }
            // }
        }
        // console.log('prefix:', prefix);
        return tree;
    };
}
exports.prerun = prerun;
function sanitizeCommaDelimitedArg(input) {
    if (input) {
        return input
            .split(',')
            .filter((i) => !!i)
            .map((i) => i.trim().toLowerCase());
    }
    return [];
}
exports.sanitizeCommaDelimitedArg = sanitizeCommaDelimitedArg;
function parseProjectNameFromPath(input) {
    if (input && input.indexOf('/') > -1) {
        input = input.split('/').pop();
    }
    return input;
}
exports.parseProjectNameFromPath = parseProjectNameFromPath;
