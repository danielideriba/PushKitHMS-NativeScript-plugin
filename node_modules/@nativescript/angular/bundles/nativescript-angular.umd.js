(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@nativescript/core'), require('@angular/core'), require('@angular/common'), require('rxjs/operators'), require('rxjs'), require('@angular/router'), require('@angular/forms'), require('@angular/animations'), require('@angular/animations/browser'), require('@angular/platform-browser/animations'), require('@angular/common/http')) :
    typeof define === 'function' && define.amd ? define('@nativescript/angular', ['exports', '@nativescript/core', '@angular/core', '@angular/common', 'rxjs/operators', 'rxjs', '@angular/router', '@angular/forms', '@angular/animations', '@angular/animations/browser', '@angular/platform-browser/animations', '@angular/common/http'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.nativescript = global.nativescript || {}, global.nativescript.angular = {}), global['ns-core'], global.ng.core, global.ng.common, global.rxjs.operators, global.rxjs, global.ng.router, global.ng.forms, global.ng.animations, global.ng.animations.browser, global.ng.platformBrowser.animations, global.ng.common.http));
}(this, (function (exports, core, i0, common, operators, rxjs, i1, forms, animations$1, browser, animations, http) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || Array.prototype.slice.call(from));
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    var getClassName = function (instance) { return instance.constructor.name; };
    var ɵ0$9 = getClassName;
    var InvisibleNode = /** @class */ (function (_super) {
        __extends(InvisibleNode, _super);
        function InvisibleNode(name) {
            if (name === void 0) { name = ''; }
            var _this = _super.call(this) || this;
            _this.name = name;
            _this.nodeType = 1;
            _this.nodeName = getClassName(_this);
            return _this;
        }
        InvisibleNode.prototype.toString = function () {
            return this.nodeName + "(" + this.id + ")-" + this.name;
        };
        return InvisibleNode;
    }(core.View));
    var CommentNode = /** @class */ (function (_super) {
        __extends(CommentNode, _super);
        function CommentNode(value) {
            var _this = _super.call(this, value) || this;
            _this.meta = {
                skipAddToDom: true,
            };
            _this.id = CommentNode.id.toString();
            CommentNode.id += 1;
            return _this;
        }
        return CommentNode;
    }(InvisibleNode));
    CommentNode.id = 0;
    var TextNode = /** @class */ (function (_super) {
        __extends(TextNode, _super);
        function TextNode(value) {
            var _this = _super.call(this, value) || this;
            _this.meta = {
                skipAddToDom: true,
            };
            _this.id = TextNode.id.toString();
            TextNode.id += 1;
            return _this;
        }
        return TextNode;
    }(InvisibleNode));
    TextNode.id = 0;

    function isDetachedElement(element) {
        return element && element.meta && element.meta.skipAddToDom;
    }
    function isView(view) {
        return view instanceof core.View;
    }
    function isInvisibleNode(view) {
        return view instanceof InvisibleNode;
    }
    function isLayout(view) {
        return view instanceof core.LayoutBase;
    }
    function isContentView(view) {
        return view instanceof core.ContentView;
    }
    function getFirstNativeLikeView(view, extractFromNSParent) {
        if (extractFromNSParent === void 0) { extractFromNSParent = false; }
        if (view instanceof core.ProxyViewContainer) {
            if (view.getChildrenCount() === 0) {
                return null;
            }
            return getFirstNativeLikeView(view.getChildAt(0));
        }
        if (extractFromNSParent) {
            // const node = view.parentNode;
            detachViewFromParent(view);
            // view.parentNode = node;
        }
        return view;
    }
    function detachViewFromParent(view) {
        var parent = view === null || view === void 0 ? void 0 : view.parent;
        if (!parent) {
            return;
        }
        if (parent.meta && parent.meta.removeChild) {
            parent.meta.removeChild(parent, view);
        }
        else if (isLayout(parent)) {
            parent.removeChild(view);
        }
        else if (isContentView(parent) && parent.content === view) {
            parent.content = null;
        }
        else if (isView(parent)) {
            parent._removeView(view);
        }
    }

    var APP_ROOT_VIEW = new i0.InjectionToken('NativeScriptAppRootView');
    var NATIVESCRIPT_ROOT_MODULE_ID = new i0.InjectionToken('NativeScriptRootModuleId');
    var START_PATH = new i0.InjectionToken('NativeScriptStartPath');
    var ENABLE_REUSABE_VIEWS = new i0.InjectionToken('NativeScriptEnableReusableViews');
    var DISABLE_ROOT_VIEW_HANDLING = new i0.InjectionToken('NativeScriptDisableRootViewHandling');
    var DEVICE = new i0.InjectionToken('NativeScriptDevice');
    var PAGE_FACTORY = new i0.InjectionToken('NativeScriptPageFactory');
    var defaultPageFactory = function (_opts) {
        return new core.Page();
    };

    var PlatformNamespaceFilter = /** @class */ (function () {
        function PlatformNamespaceFilter(device) {
            this.device = device;
        }
        PlatformNamespaceFilter.prototype.runsIn = function (namespace, next) {
            if (namespace === 'android') {
                return this.device.os === core.platformNames.android;
            }
            if (namespace === 'ios') {
                return this.device.os === core.platformNames.ios;
            }
            return next(namespace);
        };
        return PlatformNamespaceFilter;
    }());
    PlatformNamespaceFilter.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [DEVICE,] }] }
    ]; };
    var NAMESPACE_FILTERS = new i0.InjectionToken('NativeScriptNamespaceFilter');

    var NgViewRef = /** @class */ (function () {
        function NgViewRef(ref) {
            this.ref = ref;
            this.view = ref instanceof i0.ComponentRef ? ref.location.nativeElement : ref.rootNodes.find(function (v) { return !(v instanceof InvisibleNode); });
            this.firstNativeLikeView = getFirstNativeLikeView(this.view);
        }
        NgViewRef.prototype.detachNativeLikeView = function () {
            detachViewFromParent(this.firstNativeLikeView);
        };
        return NgViewRef;
    }());

    var AppHostView = /** @class */ (function (_super) {
        __extends(AppHostView, _super);
        function AppHostView(backgroundColor) {
            var _this = _super.call(this) || this;
            _this.timeout = -1;
            _this.backgroundColor = backgroundColor;
            return _this;
        }
        Object.defineProperty(AppHostView.prototype, "ngAppRoot", {
            get: function () {
                return this._ngAppRoot;
            },
            set: function (value) {
                this._ngAppRoot = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AppHostView.prototype, "content", {
            //@ts-ignore
            get: function () {
                return this._content;
            },
            set: function (value) {
                if (this._content) {
                    this._content.parentNode = undefined;
                }
                this._content = value;
                if (value) {
                    this._content.parentNode = this;
                }
                this.ngAppRoot = value;
                if (this._content instanceof core.ProxyViewContainer) {
                    var grid = new core.GridLayout();
                    grid.backgroundColor = this.backgroundColor;
                    grid.addChild(this._content);
                    this.ngAppRoot = grid;
                }
                if (this.ngAppRoot) {
                    // maybe use this approach
                    // this.scheduleRootChange();
                }
            },
            enumerable: false,
            configurable: true
        });
        AppHostView.prototype.scheduleRootChange = function () {
            var _this = this;
            if (this.timeout === -1) {
                this.timeout = setTimeout(function () {
                    //console.log(this.ngAppRoot);
                    core.Application.resetRootView({
                        create: function () { return _this.content; }
                    });
                    _this.timeout = -1;
                }, 0);
            }
        };
        return AppHostView;
    }(core.ContentView));
    var AppHostAsyncView = /** @class */ (function (_super) {
        __extends(AppHostAsyncView, _super);
        function AppHostAsyncView(backgroundColor) {
            var _this = _super.call(this) || this;
            _this.backgroundColor = backgroundColor;
            return _this;
        }
        Object.defineProperty(AppHostAsyncView.prototype, "ngAppRoot", {
            get: function () {
                return this;
            },
            set: function (value) {
                // ignored
            },
            enumerable: false,
            configurable: true
        });
        return AppHostAsyncView;
    }(core.GridLayout));

    var NativeScriptLoadingService = /** @class */ (function () {
        function NativeScriptLoadingService() {
            this.mainModuleReady$ = new rxjs.BehaviorSubject(false);
            this.readyToDestroy$ = new rxjs.BehaviorSubject(true);
            this.onMainModuleReady$ = this.mainModuleReady$.pipe(operators.filter(function (ready) { return ready; }));
        }
        /**
         * delays destroying this module until `notifyReadyToDestroy()`.
         * remember to call `notifyReadyToDestroy()` when done!
         */
        NativeScriptLoadingService.prototype.waitUntilNotified = function () {
            this.readyToDestroy$.next(false);
        };
        /**
         * notifies this module is ready to be destroyed
         */
        NativeScriptLoadingService.prototype.notifyReadyToDestroy = function () {
            this.readyToDestroy$.next(true);
        };
        NativeScriptLoadingService.prototype.isMainModuleReady = function () {
            return this.mainModuleReady$.value;
        };
        NativeScriptLoadingService.prototype.ngOnDestroy = function () {
            this.readyToDestroy$.complete();
            this.mainModuleReady$.complete();
        };
        /**
         * This funcion is called by the bootstrap code when the app is ready
         * @internal
         */
        NativeScriptLoadingService.prototype._notifyMainModuleReady = function () {
            this.mainModuleReady$.next(true);
        };
        return NativeScriptLoadingService;
    }());
    NativeScriptLoadingService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function NativeScriptLoadingService_Factory() { return new NativeScriptLoadingService(); }, token: NativeScriptLoadingService, providedIn: "root" });
    NativeScriptLoadingService.decorators = [
        { type: i0.Injectable, args: [{ providedIn: 'root' },] }
    ];

    var NativeScriptDebug = /** @class */ (function () {
        function NativeScriptDebug() {
        }
        NativeScriptDebug.isLogEnabled = function () {
            return core.Trace.isEnabled();
        };
        NativeScriptDebug.animationsLog = function (message) {
            core.Trace.write(message, NativeScriptDebug.animationsTraceCategory);
        };
        NativeScriptDebug.rendererLog = function (msg) {
            core.Trace.write(msg, NativeScriptDebug.rendererTraceCategory);
        };
        NativeScriptDebug.rendererError = function (message) {
            core.Trace.write(message, NativeScriptDebug.rendererTraceCategory, core.Trace.messageType.error);
        };
        NativeScriptDebug.viewUtilLog = function (msg) {
            core.Trace.write(msg, NativeScriptDebug.viewUtilCategory);
        };
        NativeScriptDebug.routerLog = function (message) {
            core.Trace.write(message, NativeScriptDebug.routerTraceCategory);
        };
        NativeScriptDebug.routerError = function (message) {
            core.Trace.write(message, NativeScriptDebug.routerTraceCategory, core.Trace.messageType.error);
        };
        NativeScriptDebug.routeReuseStrategyLog = function (message) {
            core.Trace.write(message, NativeScriptDebug.routeReuseStrategyTraceCategory);
        };
        NativeScriptDebug.styleError = function (message) {
            core.Trace.write(message, core.Trace.categories.Style, core.Trace.messageType.error);
        };
        NativeScriptDebug.listViewLog = function (message) {
            core.Trace.write(message, NativeScriptDebug.listViewTraceCategory);
        };
        NativeScriptDebug.listViewError = function (message) {
            core.Trace.write(message, NativeScriptDebug.listViewTraceCategory, core.Trace.messageType.error);
        };
        NativeScriptDebug.bootstrapLog = function (message) {
            core.Trace.write(message, NativeScriptDebug.bootstrapCategory);
        };
        NativeScriptDebug.bootstrapLogError = function (message) {
            core.Trace.write(message, NativeScriptDebug.bootstrapCategory, core.Trace.messageType.error);
        };
        return NativeScriptDebug;
    }());
    NativeScriptDebug.animationsTraceCategory = 'ns-animations';
    NativeScriptDebug.rendererTraceCategory = 'ns-renderer';
    NativeScriptDebug.viewUtilCategory = 'ns-view-util';
    NativeScriptDebug.routerTraceCategory = 'ns-router';
    NativeScriptDebug.routeReuseStrategyTraceCategory = 'ns-route-reuse-strategy';
    NativeScriptDebug.listViewTraceCategory = 'ns-list-view';
    NativeScriptDebug.bootstrapCategory = 'bootstrap';
    // TODO: migrate all usage to this - avoids extraneous method executions
    NativeScriptDebug.enabled = core.Trace.isEnabled();

    function disableRootViewHanding(view) {
        view.__disable_root_view_handling = true;
    }
    var preAngularDisposal$ = new rxjs.Subject();
    var postAngularBootstrap$ = new rxjs.Subject();
    var ɵ0$8 = function (v) { return v.moduleType === 'main' && v.reason === 'hotreload'; }, ɵ1$3 = function (v) { return v.reference; };
    /**
     * @deprecated
     */
    var onBeforeLivesync = preAngularDisposal$.pipe(operators.filter(ɵ0$8), operators.map(ɵ1$3));
    var ɵ2$3 = function (v) { return v.moduleType === 'main'; }, ɵ3$2 = function (v) { return ({ moduleRef: v.reference }); };
    /**
     * @deprecated
     */
    var onAfterLivesync = postAngularBootstrap$.pipe(operators.filter(ɵ2$3), operators.map(ɵ3$2));
    if (module['hot']) {
        module['hot'].decline();
        global.__onLiveSyncCore = function () {
            var _a;
            (_a = core.Application.getRootView()) === null || _a === void 0 ? void 0 : _a._onCssStateChange();
            // all other changes are applied by runNativeScriptAngularApp
        };
    }
    function emitModuleBootstrapEvent(ref, name, reason) {
        postAngularBootstrap$.next({
            moduleType: name,
            reference: ref,
            reason: reason,
        });
    }
    function destroyRef(ref, name, reason) {
        if (ref) {
            if (ref instanceof i0.PlatformRef) {
                preAngularDisposal$.next({
                    moduleType: 'platform',
                    reference: ref,
                    reason: name,
                });
            }
            if (ref instanceof i0.NgModuleRef) {
                preAngularDisposal$.next({
                    moduleType: name,
                    reference: ref,
                    reason: reason,
                });
            }
            ref.destroy();
        }
    }
    function runNativeScriptAngularApp(options) {
        var mainModuleRef = null;
        var loadingModuleRef;
        var platformRef = null;
        var bootstrapId = -1;
        var updatePlatformRef = function (moduleRef, reason) {
            var newPlatformRef = moduleRef.injector.get(i0.PlatformRef);
            if (newPlatformRef === platformRef) {
                return;
            }
            destroyRef(platformRef, reason);
            platformRef = newPlatformRef;
            platformRef.onDestroy(function () { return (platformRef = platformRef === newPlatformRef ? null : platformRef); });
        };
        var setRootView = function (ref) {
            var _a;
            if (bootstrapId === -1) {
                // treat edge cases
                return;
            }
            if (ref instanceof i0.NgModuleRef) {
                if (ref.injector.get(DISABLE_ROOT_VIEW_HANDLING, false)) {
                    return;
                }
            }
            else {
                if (ref['__disable_root_view_handling']) {
                    return;
                }
            }
            (_a = core.Application.getRootView()) === null || _a === void 0 ? void 0 : _a._closeAllModalViewsInternal(); // cleanup old rootview
            // TODO: check for leaks when root view isn't properly destroyed
            if (ref instanceof core.View) {
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.bootstrapLog("Setting RootView to " + ref);
                }
                core.Application.resetRootView({
                    create: function () { return ref; },
                });
                return;
            }
            var view = ref.injector.get(APP_ROOT_VIEW);
            var newRoot = view instanceof AppHostView ? view.content : view;
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.bootstrapLog("Setting RootView to " + newRoot);
            }
            core.Application.resetRootView({
                create: function () { return newRoot; },
            });
        };
        var showErrorUI = function (error) {
            var message = error.message + '\n\n' + error.stack;
            var errorTextBox = new core.TextView();
            errorTextBox.text = message;
            errorTextBox.color = new core.Color('red');
            setRootView(errorTextBox);
        };
        var bootstrapRoot = function (reason) {
            bootstrapId = Date.now();
            var currentBootstrapId = bootstrapId;
            var bootstrapped = false;
            var onMainBootstrap = function () {
                setRootView(mainModuleRef);
            };
            options.appModuleBootstrap(reason).then(function (ref) {
                if (currentBootstrapId !== bootstrapId) {
                    // this module is old and not needed anymore
                    // this may happen when developer uses async app initializer and the user exits the app before this bootstraps
                    ref.destroy();
                    return;
                }
                mainModuleRef = ref;
                ref.onDestroy(function () { return (mainModuleRef = mainModuleRef === ref ? null : mainModuleRef); });
                updatePlatformRef(ref, reason);
                var styleTag = ref.injector.get(NATIVESCRIPT_ROOT_MODULE_ID);
                ref.onDestroy(function () {
                    core.removeTaggedAdditionalCSS(styleTag);
                });
                bootstrapped = true;
                // delay bootstrap callback until all rendering is good to go
                core.Utils.queueMacrotask(function () { return onMainBootstrap(); });
                // onMainBootstrap();
                emitModuleBootstrapEvent(ref, 'main', reason);
                // bootstrapped component: (ref as any)._bootstrapComponents[0];
            }, function (err) {
                bootstrapped = true;
                NativeScriptDebug.bootstrapLogError("Error bootstrapping app module:\n" + err.message + "\n\n" + err.stack);
                showErrorUI(err);
                throw err;
            });
            core.Utils.queueMacrotask(function () {
                if (currentBootstrapId !== bootstrapId) {
                    return;
                }
                if (!bootstrapped) {
                    if (options.loadingModule) {
                        options.loadingModule(reason).then(function (loadingRef) {
                            if (currentBootstrapId !== bootstrapId) {
                                // this module is old and not needed anymore
                                // this may happen when developer uses async app initializer and the user exits the app before this bootstraps
                                loadingRef.destroy();
                                return;
                            }
                            loadingModuleRef = loadingRef;
                            loadingModuleRef.onDestroy(function () { return (loadingModuleRef = loadingModuleRef === loadingRef ? null : loadingModuleRef); });
                            updatePlatformRef(loadingRef, reason);
                            var styleTag = loadingModuleRef.injector.get(NATIVESCRIPT_ROOT_MODULE_ID);
                            loadingRef.onDestroy(function () {
                                core.removeTaggedAdditionalCSS(styleTag);
                            });
                            setRootView(loadingRef);
                            onMainBootstrap = function () {
                                var loadingService = loadingModuleRef.injector.get(NativeScriptLoadingService);
                                loadingModuleRef.injector.get(i0.NgZone).run(function () {
                                    loadingService._notifyMainModuleReady();
                                });
                                loadingService.readyToDestroy$
                                    .pipe(operators.filter(function (ready) { return ready; }), operators.take(1))
                                    .subscribe(function () {
                                    destroyRef(loadingModuleRef, 'loading', reason);
                                    loadingModuleRef = null;
                                    setRootView(mainModuleRef);
                                });
                            };
                            emitModuleBootstrapEvent(loadingModuleRef, 'loading', reason);
                        }, function (err) {
                            NativeScriptDebug.bootstrapLogError("Error bootstrapping loading module:\n" + err.message + "\n\n" + err.stack);
                            showErrorUI(err);
                            throw err;
                        });
                    }
                    else if (options.launchView) {
                        var launchView_1 = options.launchView(reason);
                        setRootView(launchView_1);
                        if (launchView_1.startAnimation) {
                            setTimeout(function () {
                                // ensure launch animation is executed after launchView added to view stack
                                launchView_1.startAnimation();
                            });
                        }
                        onMainBootstrap = function () {
                            if (launchView_1.cleanup) {
                                launchView_1
                                    .cleanup()
                                    .catch()
                                    .then(function () {
                                    launchView_1 = null;
                                    setRootView(mainModuleRef);
                                });
                            }
                        };
                    }
                    else {
                        console.warn('App is bootstrapping asynchronously (likely APP_INITIALIZER) but did not provide a launchView or LoadingModule.');
                    }
                }
            });
        };
        var disposePlatform = function (reason) {
            destroyRef(platformRef, reason);
            platformRef = null;
        };
        var disposeLastModules = function (reason) {
            // reset bootstrap ID to make sure any modules bootstrapped after this are discarded
            bootstrapId = -1;
            destroyRef(loadingModuleRef, 'loading', reason);
            loadingModuleRef = null;
            destroyRef(mainModuleRef, 'main', reason);
            mainModuleRef = null;
        };
        var launchCallback = core.profile('@nativescript/angular/platform-common.launchCallback', function (args) {
            args.root = null;
            bootstrapRoot('applaunch');
        });
        var exitCallback = core.profile('@nativescript/angular/platform-common.exitCallback', function (args) {
            disposeLastModules('appexit');
        });
        core.Application.on(core.Application.launchEvent, launchCallback);
        core.Application.on(core.Application.exitEvent, exitCallback);
        if (module['hot']) {
            // handle HMR Application.run
            global['__dispose_app_ng_platform__'] = function () {
                disposePlatform('hotreload');
            };
            global['__dispose_app_ng_modules__'] = function () {
                disposeLastModules('hotreload');
            };
            global['__bootstrap_app_ng_modules__'] = function () {
                bootstrapRoot('hotreload');
            };
            global['__cleanup_ng_hot__'] = function () {
                core.Application.off(core.Application.launchEvent, launchCallback);
                core.Application.off(core.Application.exitEvent, exitCallback);
                disposeLastModules('hotreload');
                disposePlatform('hotreload');
            };
            global['__reboot_ng_modules__'] = function (shouldDisposePlatform) {
                if (shouldDisposePlatform === void 0) { shouldDisposePlatform = false; }
                disposeLastModules('hotreload');
                if (shouldDisposePlatform) {
                    disposePlatform('hotreload');
                }
                bootstrapRoot('hotreload');
            };
            if (!core.Application.hasLaunched()) {
                core.Application.run();
                return;
            }
            bootstrapRoot('hotreload');
            return;
        }
        core.Application.run();
    }

    var NativeScriptPlatformRefProxy = /** @class */ (function (_super) {
        __extends(NativeScriptPlatformRefProxy, _super);
        function NativeScriptPlatformRefProxy(platform, launchView) {
            var _this = _super.call(this) || this;
            _this.platform = platform;
            _this.launchView = launchView;
            return _this;
        }
        NativeScriptPlatformRefProxy.prototype.bootstrapModuleFactory = function (moduleFactory) {
            var _this = this;
            this.options = {
                appModuleBootstrap: function () { return _this.platform.bootstrapModuleFactory(moduleFactory); },
                launchView: function () { return _this.launchView; },
            };
            runNativeScriptAngularApp(this.options);
            return null;
        };
        NativeScriptPlatformRefProxy.prototype.bootstrapModule = function (moduleType, compilerOptions) {
            var _this = this;
            this.options = {
                appModuleBootstrap: function () { return _this.platform.bootstrapModule(moduleType, compilerOptions); },
            };
            runNativeScriptAngularApp(this.options);
            return null;
        };
        NativeScriptPlatformRefProxy.prototype.onDestroy = function (callback) {
            this.platform.onDestroy(callback);
        };
        Object.defineProperty(NativeScriptPlatformRefProxy.prototype, "injector", {
            get: function () {
                return this.platform.injector;
            },
            enumerable: false,
            configurable: true
        });
        NativeScriptPlatformRefProxy.prototype.destroy = function () {
            this.platform.destroy();
        };
        Object.defineProperty(NativeScriptPlatformRefProxy.prototype, "destroyed", {
            get: function () {
                return this.platform.destroyed;
            },
            enumerable: false,
            configurable: true
        });
        return NativeScriptPlatformRefProxy;
    }(i0.PlatformRef));

    var ɵ0$7 = defaultPageFactory;
    var defaultPageFactoryProvider = { provide: PAGE_FACTORY, useValue: ɵ0$7 };
    var NativeScriptSanitizer = /** @class */ (function (_super) {
        __extends(NativeScriptSanitizer, _super);
        function NativeScriptSanitizer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        NativeScriptSanitizer.prototype.sanitize = function (_context, value) {
            return value;
        };
        return NativeScriptSanitizer;
    }(i0.Sanitizer));
    // TODO: when angular finally exports their scheduler token for ivy CD, provide our own with queueMacroTask
    // export function schedulerFactory() {
    //   return (fn: any) => {
    //     console.log('SCHEDULER');
    //     setTimeout(fn, 0);
    //   };
    // }
    var NativeScriptDocument = /** @class */ (function () {
        function NativeScriptDocument() {
            // Required by the AnimationDriver
            this.body = {
                isOverride: true,
            };
        }
        NativeScriptDocument.prototype.createElement = function (tag) {
            throw new Error('NativeScriptDocument is not DOM Document. There is no createElement() method.');
        };
        return NativeScriptDocument;
    }());
    var COMMON_PROVIDERS = [defaultPageFactoryProvider, { provide: i0.Sanitizer, useClass: NativeScriptSanitizer, deps: [] }, { provide: common.DOCUMENT, useClass: NativeScriptDocument, deps: [] }];
    var platformNativeScript = i0.createPlatformFactory(i0.platformCore, 'nativescriptDynamic', COMMON_PROVIDERS);
    /**
     * @deprecated use runNativeScriptAngularApp instead
     */
    var platformNativeScriptDynamic = function (options, extraProviders) {
        console.log('platformNativeScriptDynamic is deprecated, use runNativeScriptAngularApp instead');
        options = options || {};
        extraProviders = extraProviders || [];
        var ngRootView = new AppHostView(new core.Color(options.backgroundColor || 'white'));
        var launchView = options.launchView;
        if (!launchView && options.async) {
            launchView = new core.GridLayout();
            launchView.backgroundColor = options.backgroundColor || 'white';
        }
        return new NativeScriptPlatformRefProxy(platformNativeScript(__spreadArray([], __read(extraProviders))), launchView);
    };

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Throws an exception when attempting to attach a null portal to a host.
     * @docs-private
     */
    function throwNullPortalError() {
        throw Error('Must provide a portal to attach');
    }
    /**
     * Throws an exception when attempting to attach a portal to a host that is already attached.
     * @docs-private
     */
    function throwPortalAlreadyAttachedError() {
        throw Error('Host already has a portal attached');
    }
    /**
     * Throws an exception when attempting to attach a portal to an already-disposed host.
     * @docs-private
     */
    function throwPortalOutletAlreadyDisposedError() {
        throw Error('This PortalOutlet has already been disposed');
    }
    /**
     * Throws an exception when attempting to attach an unknown portal type.
     * @docs-private
     */
    function throwUnknownPortalTypeError() {
        throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' + 'a ComponentPortal or a TemplatePortal.');
    }
    /**
     * Throws an exception when attempting to attach a portal to a null host.
     * @docs-private
     */
    function throwNullPortalOutletError() {
        throw Error('Attempting to attach a portal to a null PortalOutlet');
    }
    /**
     * Throws an exception when attempting to detach a portal that is not attached.
     * @docs-private
     */
    function throwNoPortalAttachedError() {
        throw Error('Attempting to detach a portal that is not attached to a host');
    }

    /**
     * A `Portal` is something that you want to render somewhere else.
     * It can be attach to / detached from a `PortalOutlet`.
     */
    var Portal = /** @class */ (function () {
        function Portal() {
        }
        /** Attach this portal to a host. */
        Portal.prototype.attach = function (host) {
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
                if (host == null) {
                    throwNullPortalOutletError();
                }
                if (host.hasAttached()) {
                    throwPortalAlreadyAttachedError();
                }
            }
            this._attachedHost = host;
            return host.attach(this);
        };
        /** Detach this portal from its host */
        Portal.prototype.detach = function () {
            var host = this._attachedHost;
            if (host != null) {
                this._attachedHost = null;
                host.detach();
            }
            else if (typeof ngDevMode === 'undefined' || ngDevMode) {
                throwNoPortalAttachedError();
            }
        };
        Object.defineProperty(Portal.prototype, "isAttached", {
            /** Whether this portal is attached to a host. */
            get: function () {
                return this._attachedHost != null;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
         * the PortalOutlet when it is performing an `attach()` or `detach()`.
         */
        Portal.prototype.setAttachedHost = function (host) {
            this._attachedHost = host;
        };
        return Portal;
    }());
    /**
     * A `ComponentPortal` is a portal that instantiates some Component upon attachment.
     */
    var ComponentPortal = /** @class */ (function (_super) {
        __extends(ComponentPortal, _super);
        function ComponentPortal(component, viewContainerRef, injector, componentFactoryResolver) {
            var _this = _super.call(this) || this;
            _this.component = component;
            _this.viewContainerRef = viewContainerRef;
            _this.injector = injector;
            _this.componentFactoryResolver = componentFactoryResolver;
            return _this;
        }
        return ComponentPortal;
    }(Portal));
    /**
     * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).
     */
    var TemplatePortal = /** @class */ (function (_super) {
        __extends(TemplatePortal, _super);
        function TemplatePortal(template, viewContainerRef, context) {
            var _this = _super.call(this) || this;
            _this.templateRef = template;
            _this.viewContainerRef = viewContainerRef;
            _this.context = context;
            return _this;
        }
        Object.defineProperty(TemplatePortal.prototype, "origin", {
            get: function () {
                return this.templateRef.elementRef;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Attach the portal to the provided `PortalOutlet`.
         * When a context is provided it will override the `context` property of the `TemplatePortal`
         * instance.
         */
        TemplatePortal.prototype.attach = function (host, context) {
            if (context === void 0) { context = this.context; }
            this.context = context;
            return _super.prototype.attach.call(this, host);
        };
        TemplatePortal.prototype.detach = function () {
            this.context = undefined;
            return _super.prototype.detach.call(this);
        };
        return TemplatePortal;
    }(Portal));
    /**
     * A `DomPortal` is a portal whose DOM element will be taken from its current position
     * in the DOM and moved into a portal outlet, when it is attached. On detach, the content
     * will be restored to its original position.
     */
    var DomPortal = /** @class */ (function (_super) {
        __extends(DomPortal, _super);
        function DomPortal(element) {
            var _this = _super.call(this) || this;
            _this.element = element instanceof i0.ElementRef ? element.nativeElement : element;
            return _this;
        }
        return DomPortal;
    }(Portal));
    /**
     * Partial implementation of PortalOutlet that handles attaching
     * ComponentPortal and TemplatePortal.
     */
    var BasePortalOutlet = /** @class */ (function () {
        function BasePortalOutlet() {
            /** Whether this host has already been permanently disposed. */
            this._isDisposed = false;
            // @breaking-change 10.0.0 `attachDomPortal` to become a required abstract method.
            this.attachDomPortal = null;
        }
        /** Whether this host has an attached portal. */
        BasePortalOutlet.prototype.hasAttached = function () {
            return !!this._attachedPortal;
        };
        /** Attaches a portal. */
        BasePortalOutlet.prototype.attach = function (portal) {
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
                if (!portal) {
                    throwNullPortalError();
                }
                if (this.hasAttached()) {
                    throwPortalAlreadyAttachedError();
                }
                if (this._isDisposed) {
                    throwPortalOutletAlreadyDisposedError();
                }
            }
            if (portal instanceof ComponentPortal) {
                this._attachedPortal = portal;
                return this.attachComponentPortal(portal);
            }
            else if (portal instanceof TemplatePortal) {
                this._attachedPortal = portal;
                return this.attachTemplatePortal(portal);
                // @breaking-change 10.0.0 remove null check for `this.attachDomPortal`.
            }
            else if (this.attachDomPortal && portal instanceof DomPortal) {
                this._attachedPortal = portal;
                return this.attachDomPortal(portal);
            }
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
                throwUnknownPortalTypeError();
            }
        };
        /** Detaches a previously attached portal. */
        BasePortalOutlet.prototype.detach = function () {
            if (this._attachedPortal) {
                this._attachedPortal.setAttachedHost(null);
                this._attachedPortal = null;
            }
            this._invokeDisposeFn();
        };
        /** Permanently dispose of this portal host. */
        BasePortalOutlet.prototype.dispose = function () {
            if (this.hasAttached()) {
                this.detach();
            }
            this._invokeDisposeFn();
            this._isDisposed = true;
        };
        /** @docs-private */
        BasePortalOutlet.prototype.setDisposeFn = function (fn) {
            this._disposeFn = fn;
        };
        BasePortalOutlet.prototype._invokeDisposeFn = function () {
            if (this._disposeFn) {
                this._disposeFn();
                this._disposeFn = null;
            }
        };
        return BasePortalOutlet;
    }());

    /**
     * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,
     * the directive instance itself can be attached to a host, enabling declarative use of portals.
     */
    var CdkPortal = /** @class */ (function (_super) {
        __extends(CdkPortal, _super);
        function CdkPortal(templateRef, viewContainerRef) {
            return _super.call(this, templateRef, viewContainerRef) || this;
        }
        return CdkPortal;
    }(TemplatePortal));
    CdkPortal.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[cdkPortal]',
                    exportAs: 'cdkPortal',
                },] }
    ];
    CdkPortal.ctorParameters = function () { return [
        { type: i0.TemplateRef },
        { type: i0.ViewContainerRef }
    ]; };
    /**
     * Directive version of a PortalOutlet. Because the directive *is* a PortalOutlet, portals can be
     * directly attached to it, enabling declarative use.
     *
     * Usage:
     * `<ng-template [cdkPortalOutlet]="greeting"></ng-template>`
     */
    var CdkPortalOutlet = /** @class */ (function (_super) {
        __extends(CdkPortalOutlet, _super);
        function CdkPortalOutlet(_componentFactoryResolver, _viewContainerRef, renderer) {
            var _this = _super.call(this) || this;
            _this._componentFactoryResolver = _componentFactoryResolver;
            _this._viewContainerRef = _viewContainerRef;
            _this.renderer = renderer;
            /** Whether the portal component is initialized. */
            _this._isInitialized = false;
            /** Emits when a portal is attached to the outlet. */
            _this.attached = new i0.EventEmitter();
            /**
             * Attaches the given DomPortal to this PortalHost by moving all of the portal content into it.
             * @param portal Portal to be attached.
             * @deprecated To be turned into a method.
             * @breaking-change 10.0.0
             */
            _this.attachDomPortal = function (portal) {
                var element = portal.element;
                if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {
                    throw Error('DOM portal content must be attached to a parent node.');
                }
                // Anchor used to save the element's previous position so
                // that we can restore it when the portal is detached.
                var anchorNode = _this.renderer.createComment('dom-portal');
                portal.setAttachedHost(_this);
                _this.renderer.insertBefore(element.parentNode, anchorNode, element);
                _this.renderer.appendChild(_this._getRootNode(), element);
                _super.prototype.setDisposeFn.call(_this, function () {
                    if (anchorNode.parentNode) {
                        _this.renderer.insertBefore(anchorNode.parentNode, element, anchorNode);
                        _this.renderer.removeChild(anchorNode.parentNode, anchorNode);
                        // anchorNode.parentNode!.replaceChild(element, anchorNode);
                    }
                });
            };
            return _this;
        }
        Object.defineProperty(CdkPortalOutlet.prototype, "portal", {
            /** Portal associated with the Portal outlet. */
            get: function () {
                return this._attachedPortal;
            },
            set: function (portal) {
                // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have
                // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`
                // and attach a portal programmatically in the parent component. When Angular does the first CD
                // round, it will fire the setter with empty string, causing the user's content to be cleared.
                if (this.hasAttached() && !portal && !this._isInitialized) {
                    return;
                }
                if (this.hasAttached()) {
                    _super.prototype.detach.call(this);
                }
                if (portal) {
                    _super.prototype.attach.call(this, portal);
                }
                this._attachedPortal = portal;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(CdkPortalOutlet.prototype, "attachedRef", {
            /** Component or view reference that is attached to the portal. */
            get: function () {
                return this._attachedRef;
            },
            enumerable: false,
            configurable: true
        });
        CdkPortalOutlet.prototype.ngOnInit = function () {
            this._isInitialized = true;
        };
        CdkPortalOutlet.prototype.ngOnDestroy = function () {
            _super.prototype.dispose.call(this);
            this._attachedPortal = null;
            this._attachedRef = null;
        };
        /**
         * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.
         *
         * @param portal Portal to be attached to the portal outlet.
         * @returns Reference to the created component.
         */
        CdkPortalOutlet.prototype.attachComponentPortal = function (portal) {
            portal.setAttachedHost(this);
            // If the portal specifies an origin, use that as the logical location of the component
            // in the application tree. Otherwise use the location of this PortalOutlet.
            var viewContainerRef = portal.viewContainerRef != null ? portal.viewContainerRef : this._viewContainerRef;
            var resolver = portal.componentFactoryResolver || this._componentFactoryResolver;
            var componentFactory = resolver.resolveComponentFactory(portal.component);
            var ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.injector);
            // If we're using a view container that's different from the injected one (e.g. when the portal
            // specifies its own) we need to move the component into the outlet, otherwise it'll be rendered
            // inside of the alternate view container.
            if (viewContainerRef !== this._viewContainerRef) {
                this.renderer.appendChild(this._getRootNode(), ref.hostView.rootNodes[0]);
            }
            _super.prototype.setDisposeFn.call(this, function () { return ref.destroy(); });
            this._attachedPortal = portal;
            this._attachedRef = ref;
            this.attached.emit(ref);
            return ref;
        };
        /**
         * Attach the given TemplatePortal to this PortalHost as an embedded View.
         * @param portal Portal to be attached.
         * @returns Reference to the created embedded view.
         */
        CdkPortalOutlet.prototype.attachTemplatePortal = function (portal) {
            var _this = this;
            portal.setAttachedHost(this);
            var viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);
            _super.prototype.setDisposeFn.call(this, function () { return _this._viewContainerRef.clear(); });
            this._attachedPortal = portal;
            this._attachedRef = viewRef;
            this.attached.emit(viewRef);
            return viewRef;
        };
        /** Gets the root node of the portal outlet. */
        CdkPortalOutlet.prototype._getRootNode = function () {
            var nativeElement = this._viewContainerRef.element.nativeElement;
            // The directive could be set on a template which will result in a comment
            // node being the root. Use the comment's parent node if that is the case.
            return (!(nativeElement instanceof CommentNode) ? nativeElement : nativeElement.parentNode);
        };
        return CdkPortalOutlet;
    }(BasePortalOutlet));
    CdkPortalOutlet.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[cdkPortalOutlet]',
                    exportAs: 'cdkPortalOutlet',
                    inputs: ['portal: cdkPortalOutlet'],
                },] }
    ];
    CdkPortalOutlet.ctorParameters = function () { return [
        { type: i0.ComponentFactoryResolver },
        { type: i0.ViewContainerRef },
        { type: i0.Renderer2 }
    ]; };
    CdkPortalOutlet.propDecorators = {
        attached: [{ type: i0.Output }]
    };
    var PortalModule = /** @class */ (function () {
        function PortalModule() {
        }
        return PortalModule;
    }());
    PortalModule.decorators = [
        { type: i0.NgModule, args: [{
                    exports: [CdkPortal, CdkPortalOutlet],
                    declarations: [CdkPortal, CdkPortalOutlet],
                },] }
    ];

    var ɵ0$6 = function (parent, child) {
        // Page cannot be added to Frame with _addChildFromBuilder (thwos "use defaultPage" error)
        if (isInvisibleNode(child)) {
            return;
        }
        else if (child instanceof core.Page) {
            parent.navigate({ create: function () { return child; } });
        }
        else {
            throw new Error('Only a Page can be a child of Frame');
        }
    };
    var frameMeta = {
        insertChild: ɵ0$6,
    };

    var elementMap = new Map();
    var camelCaseSplit = /([a-z0-9])([A-Z])/g;
    var defaultViewMeta = { skipAddToDom: false };
    function registerElement(elementName, resolver, meta) {
        var entry = { resolver: resolver, meta: meta };
        elementMap.set(elementName, entry);
        elementMap.set(elementName.toLowerCase(), entry);
        elementMap.set(elementName.replace(camelCaseSplit, '$1-$2').toLowerCase(), entry);
    }
    function getViewClass(elementName) {
        var entry = elementMap.get(elementName) || elementMap.get(elementName.toLowerCase());
        if (!entry) {
            throw new TypeError("No known component for element " + elementName + ".");
        }
        try {
            return entry.resolver();
        }
        catch (e) {
            throw new TypeError("Could not load view for: " + elementName + "." + e);
        }
    }
    function getViewMeta(nodeName) {
        var entry = elementMap.get(nodeName) || elementMap.get(nodeName.toLowerCase());
        return (entry && entry.meta) || defaultViewMeta;
    }
    function isKnownView(elementName) {
        return elementMap.has(elementName) || elementMap.has(elementName.toLowerCase());
    }
    function extractSingleViewRecursive(nodes, nestLevel) {
        var actualNodes = nodes.filter(function (node) { return !(node instanceof InvisibleNode); });
        if (actualNodes.length === 0) {
            throw new Error("No suitable views found in list template! " + ("Nesting level: " + nestLevel));
        }
        else if (actualNodes.length > 1) {
            throw new Error("More than one view found in list template!" + ("Nesting level: " + nestLevel));
        }
        var rootLayout = actualNodes[0];
        if (!rootLayout) {
            return extractSingleViewRecursive(rootLayout.children, nestLevel + 1);
        }
        var parentLayout = rootLayout.parent;
        if (parentLayout instanceof core.LayoutBase) {
            var node = rootLayout.parentNode;
            parentLayout.removeChild(rootLayout);
            rootLayout.parentNode = node;
        }
        return rootLayout;
    }
    /**
     * @deprecated getSingleViewRecursive is deprecated, use extractSingleViewRecursive
     */
    function getSingleViewRecursive(nodes, nestLevel) {
        return extractSingleViewRecursive(nodes, nestLevel);
    }

    // Register default NativeScript components
    // Note: ActionBar related components are registerd together with action-bar directives.
    function registerNativeScriptViewComponents() {
        if (!global.__ngRegisteredViews) {
            global.__ngRegisteredViews = true;
            registerElement('AbsoluteLayout', function () { return core.AbsoluteLayout; });
            registerElement('ActivityIndicator', function () { return core.ActivityIndicator; });
            registerElement('Button', function () { return core.Button; });
            registerElement('ContentView', function () { return core.ContentView; });
            registerElement('DatePicker', function () { return core.DatePicker; });
            registerElement('DockLayout', function () { return core.DockLayout; });
            registerElement('Frame', function () { return core.Frame; }, frameMeta);
            registerElement('GridLayout', function () { return core.GridLayout; });
            registerElement('HtmlView', function () { return core.HtmlView; });
            registerElement('Image', function () { return core.Image; });
            // Parse5 changes <Image> tags to <img>. WTF!
            registerElement('img', function () { return core.Image; });
            registerElement('Label', function () { return core.Label; });
            registerElement('ListPicker', function () { return core.ListPicker; });
            registerElement('ListView', function () { return core.ListView; });
            registerElement('Page', function () { return core.Page; });
            registerElement('Placeholder', function () { return core.Placeholder; });
            registerElement('Progress', function () { return core.Progress; });
            registerElement('ProxyViewContainer', function () { return core.ProxyViewContainer; });
            registerElement('Repeater', function () { return core.Repeater; });
            registerElement('RootLayout', function () { return core.RootLayout; });
            registerElement('ScrollView', function () { return core.ScrollView; });
            registerElement('SearchBar', function () { return core.SearchBar; });
            registerElement('SegmentedBar', function () { return core.SegmentedBar; });
            registerElement('SegmentedBarItem', function () { return core.SegmentedBarItem; });
            registerElement('Slider', function () { return core.Slider; });
            registerElement('StackLayout', function () { return core.StackLayout; });
            registerElement('FlexboxLayout', function () { return core.FlexboxLayout; });
            registerElement('Switch', function () { return core.Switch; });
            registerElement('TabView', function () { return core.TabView; });
            registerElement('TextField', function () { return core.TextField; });
            registerElement('TextView', function () { return core.TextView; });
            registerElement('TimePicker', function () { return core.TimePicker; });
            registerElement('WebView', function () { return core.WebView; });
            registerElement('WrapLayout', function () { return core.WrapLayout; });
            registerElement('FormattedString', function () { return core.FormattedString; });
            registerElement('Span', function () { return core.Span; });
        }
    }

    var ELEMENT_NODE_TYPE = 1;
    var XML_ATTRIBUTES = Object.freeze(['style', 'rows', 'columns', 'fontAttributes']);
    var whiteSpaceSplitter = /\s+/;
    function printNgTree(view) {
        var parent = view;
        while (parent.parent && parent.parent.firstChild) {
            parent = parent.parent;
        }
        printChildrenRecurse(parent);
    }
    function printChildrenRecurse(parent) {
        var children = parent.firstChild ? __spreadArray([parent.firstChild], __read(getChildrenSiblings(parent.firstChild).nextSiblings)) : [];
        console.log("parent: " + parent + ", firstChild: " + parent.firstChild + ", lastChild: " + parent.lastChild + " children: " + children);
        if (parent.firstChild) {
            console.log("----- start " + parent);
        }
        children.forEach(function (c) { return printChildrenRecurse(c); });
        if (parent.firstChild) {
            console.log("----- end " + parent);
        }
    }
    function getChildrenSiblings(view) {
        var nextSiblings = [];
        var previousSiblings = [];
        var sibling = view.nextSibling;
        while (sibling) {
            nextSiblings.push(sibling);
            sibling = sibling.nextSibling;
        }
        sibling = view.previousSibling;
        while (sibling) {
            previousSiblings.push(sibling);
            sibling = sibling.previousSibling;
        }
        return {
            previousSiblings: previousSiblings,
            nextSiblings: nextSiblings,
        };
    }
    function printSiblingsTree(view) {
        var _a = getChildrenSiblings(view), previousSiblings = _a.previousSiblings, nextSiblings = _a.nextSiblings;
        console.log(view + " previousSiblings: " + previousSiblings + " nextSiblings: " + nextSiblings);
    }
    var propertyMaps = new Map();
    var ViewUtil = /** @class */ (function () {
        function ViewUtil(namespaceFilters, reuseViews) {
            this.namespaceFilters = namespaceFilters;
            this.reuseViews = reuseViews;
        }
        /**
         * Inserts a child into a parrent, preferably before next.
         * @param parent parent view
         * @param child child view to be added
         * @param previous previous element. If present, insert after this.
         * @param next next element. If present, insert before this (previous is ignored).
         */
        ViewUtil.prototype.insertChild = function (parent, child, previous, next) {
            if (!parent) {
                return;
            }
            var extendedParent = this.ensureNgViewExtensions(parent);
            var extendedChild = this.ensureNgViewExtensions(child);
            // if there's a next child, previous is the previousSibling of it
            if (next) {
                previous = next.previousSibling;
            }
            else if (previous) {
                // if there's a previous, next is the nextSibling of it
                next = previous.nextSibling;
            }
            else {
                // no previous or next, append to the parent
                previous = extendedParent.lastChild; // this can still be undefined if the parent has no children!
            }
            this.insertInList(extendedParent, extendedChild, previous, next);
            if (isInvisibleNode(child)) {
                extendedChild.parentNode = extendedParent;
            }
            if (!isDetachedElement(child)) {
                var nextVisual = this.findNextVisual(next);
                this.addToVisualTree(extendedParent, extendedChild, nextVisual);
            }
            // printNgTree(extendedChild);
        };
        ViewUtil.prototype.insertBefore = function (parent, child, refChild) {
            var extendedRef = refChild ? this.ensureNgViewExtensions(refChild) : undefined;
            this.insertChild(parent, child, undefined, extendedRef);
        };
        ViewUtil.prototype.insertAfter = function (parent, child, refChild) {
            var extendedRef = refChild ? this.ensureNgViewExtensions(refChild) : undefined;
            this.insertChild(parent, child, extendedRef);
        };
        ViewUtil.prototype.appendChild = function (parent, child) {
            this.insertChild(parent, child);
        };
        /**
         * Inserts a view into the parent/sibling linked list
         * !WARNING: this method makes no checks to validate the integrity of previous/next children
         * @param parent parent view
         * @param child child view
         * @param previous previous element. null/undefined for first element
         * @param next next element. null/undefined for last element
         */
        ViewUtil.prototype.insertInList = function (parent, child, previous, next) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.viewUtilLog("ViewUtil.insertInList parent: " + parent + ", view: " + child + ", " + ("previous: " + previous + ", next: " + next));
            }
            if (previous) {
                previous.nextSibling = child;
                child.previousSibling = previous;
            }
            else {
                parent.firstChild = child;
            }
            if (next) {
                child.nextSibling = next;
                next.previousSibling = child;
            }
            else {
                parent.lastChild = child;
            }
        };
        ViewUtil.prototype.addToVisualTree = function (parent, child, next) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.viewUtilLog("ViewUtil.addToVisualTree parent: " + parent + ", view: " + child + ", next: " + next);
            }
            if (parent.meta && parent.meta.insertChild) {
                parent.meta.insertChild(parent, child, next);
            }
            else if (isLayout(parent)) {
                this.insertToLayout(parent, child, next);
            }
            else if (isContentView(parent)) {
                parent.content = child;
            }
            else if (parent && parent._addChildFromBuilder) {
                parent._addChildFromBuilder(child.nodeName, child);
            }
        };
        ViewUtil.prototype.insertToLayout = function (parent, child, next) {
            if (child.parent === parent) {
                this.removeLayoutChild(parent, child);
            }
            var nextVisual = this.findNextVisual(next);
            if (nextVisual) {
                var index = parent.getChildIndex(nextVisual);
                parent.insertChild(child, index);
            }
            else {
                parent.addChild(child);
            }
            // parent.eachChild((c) => {console.log(c); return true});
        };
        ViewUtil.prototype.findNextVisual = function (view) {
            var next = view;
            while (next && isDetachedElement(next)) {
                next = next.nextSibling;
            }
            return next;
        };
        ViewUtil.prototype.removeChild = function (parent, child) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.viewUtilLog("ViewUtil.removeChild parent: " + parent + " child: " + child);
            }
            if (!parent) {
                return;
            }
            var extendedParent = this.ensureNgViewExtensions(parent);
            var extendedChild = this.ensureNgViewExtensions(child);
            this.removeFromList(extendedParent, extendedChild);
            if (!isDetachedElement(extendedChild)) {
                this.removeFromVisualTree(extendedParent, extendedChild);
            }
        };
        ViewUtil.prototype.removeFromList = function (parent, child) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.viewUtilLog("ViewUtil.removeFromList parent: " + parent + " child: " + child);
            }
            if (parent.firstChild === child && parent.lastChild === child) {
                parent.firstChild = null;
                parent.lastChild = null;
                child.nextSibling = null;
                child.previousSibling = null;
                return;
            }
            if (parent.firstChild === child) {
                parent.firstChild = child.nextSibling;
            }
            var previous = child.previousSibling;
            if (parent.lastChild === child) {
                parent.lastChild = previous;
            }
            if (previous) {
                previous.nextSibling = child.nextSibling;
                if (child.nextSibling) {
                    child.nextSibling.previousSibling = previous;
                }
            }
            child.nextSibling = null;
            child.previousSibling = null;
        };
        // NOTE: This one is O(n) - use carefully
        ViewUtil.prototype.findPreviousElement = function (parent, child) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.viewUtilLog("ViewUtil.findPreviousElement parent: " + parent + " child: " + child);
            }
            var previousVisual;
            if (isLayout(parent)) {
                previousVisual = this.getPreviousVisualElement(parent, child);
            }
            var previous = previousVisual || parent.firstChild;
            // since detached elements are not added to the visual tree,
            // we need to find the actual previous sibling of the view,
            // which may as well be an invisible node
            while (previous && previous !== child && previous.nextSibling !== child) {
                previous = previous.nextSibling;
            }
            return previous;
        };
        ViewUtil.prototype.getPreviousVisualElement = function (parent, child) {
            var elementIndex = parent.getChildIndex(child);
            if (elementIndex > 0) {
                return parent.getChildAt(elementIndex - 1);
            }
        };
        // NOTE: This one is O(n) - use carefully
        ViewUtil.prototype.getChildIndex = function (parent, child) {
            if (isLayout(parent)) {
                return parent.getChildIndex(child);
            }
            else if (isContentView(parent)) {
                return child === parent.content ? 0 : -1;
            }
        };
        ViewUtil.prototype.removeFromVisualTree = function (parent, child) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.viewUtilLog("ViewUtil.removeFromVisualTree parent: " + parent + " child: " + child);
            }
            if (parent.meta && parent.meta.removeChild) {
                parent.meta.removeChild(parent, child);
            }
            else if (isLayout(parent)) {
                this.removeLayoutChild(parent, child);
            }
            else if (isContentView(parent) && parent.content === child) {
                parent.content = null;
            }
            else if (isView(parent)) {
                parent._removeView(child);
            }
        };
        ViewUtil.prototype.removeLayoutChild = function (parent, child) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.viewUtilLog("ViewUtil.removeLayoutChild parent: " + parent + " child: " + child);
            }
            var index = parent.getChildIndex(child);
            if (index !== -1) {
                parent.removeChild(child);
            }
        };
        ViewUtil.prototype.createComment = function (value) {
            return new CommentNode(value);
        };
        ViewUtil.prototype.createText = function (value) {
            return new TextNode(value);
        };
        ViewUtil.prototype.createView = function (name) {
            var originalName = name;
            if (!isKnownView(name)) {
                name = 'ProxyViewContainer';
            }
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.viewUtilLog("Creating view: " + originalName + " " + name);
            }
            var viewClass = getViewClass(name);
            var view = new viewClass();
            var ngView = this.setNgViewExtensions(view, name);
            ngView.reusable = !!this.reuseViews;
            return ngView;
        };
        ViewUtil.prototype.ensureNgViewExtensions = function (view) {
            if (view.hasOwnProperty('meta')) {
                return view;
            }
            else {
                var name = view.cssType;
                var ngView = this.setNgViewExtensions(view, name);
                return ngView;
            }
        };
        ViewUtil.prototype.setNgViewExtensions = function (view, name) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.viewUtilLog("Make into a NgView view: " + view + " name: \"" + name + "\"");
            }
            var ngView = view;
            ngView.nodeName = name;
            ngView.meta = getViewMeta(name);
            // we're setting the node type of the view
            // to 'element' because of checks done in the
            // dom animation engine
            ngView.nodeType = ELEMENT_NODE_TYPE;
            return ngView;
        };
        ViewUtil.prototype.setProperty = function (view, attributeName, value, namespace) {
            if (!view || (namespace && !this.runsIn(namespace))) {
                return;
            }
            if (attributeName.indexOf('.') !== -1) {
                // Handle nested properties
                var properties = attributeName.split('.');
                attributeName = properties[properties.length - 1];
                var propMap = this.getProperties(view);
                var i = 0;
                while (i < properties.length - 1 && typeof view !== 'undefined') {
                    var prop = properties[i];
                    if (propMap.has(prop)) {
                        prop = propMap.get(prop);
                    }
                    view = view[prop];
                    propMap = this.getProperties(view);
                    i++;
                }
            }
            if (typeof view !== 'undefined') {
                this.setPropertyInternal(view, attributeName, value);
            }
        };
        ViewUtil.prototype.runsIn = function (platform) {
            var _this = this;
            var runs = true;
            var last = function () { return true; };
            if (this.namespaceFilters) {
                var chain = function (p) { return true; };
                var _loop_1 = function (i) {
                    var currentChain = chain;
                    chain = function (p) { return _this.namespaceFilters[i].runsIn(p, currentChain); };
                };
                for (var i = this.namespaceFilters.length - 1; i >= 0; i--) {
                    _loop_1(i);
                }
                runs = chain(platform);
                runs = runs !== false ? true : false; // undefined means true
                // this.namespaceFilters.some((filter) => {
                // 	const runsInFilter = filter.runsIn(platform);
                // 	if (runsInFilter !== undefined) {
                // 		runs = runsInFilter;
                // 		return true;
                // 	}
                // });
            }
            return runs;
        };
        ViewUtil.prototype.setPropertyInternal = function (view, attributeName, value) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.viewUtilLog("Setting attribute: " + attributeName + "=" + value + " to " + view);
            }
            if (attributeName === 'class') {
                this.setClasses(view, value);
                return;
            }
            if (XML_ATTRIBUTES.indexOf(attributeName) !== -1) {
                view[attributeName] = value;
                return;
            }
            var propMap = this.getProperties(view);
            var propertyName = propMap.get(attributeName);
            // Ensure the children of a collection currently have no parent set.
            if (Array.isArray(value)) {
                this.removeParentReferencesFromItems(value);
            }
            if (propertyName) {
                // We have a lower-upper case mapped property.
                view[propertyName] = value;
                return;
            }
            // Unknown attribute value -- just set it to our object as is.
            view[attributeName] = value;
        };
        ViewUtil.prototype.removeParentReferencesFromItems = function (items) {
            var e_1, _a;
            try {
                for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                    var item = items_1_1.value;
                    if (item.parent && item.parentNode) {
                        if (NativeScriptDebug.isLogEnabled()) {
                            NativeScriptDebug.viewUtilLog("Unassigning parent " + item.parentNode + " on value: " + item);
                        }
                        item.parent = undefined;
                        item.parentNode = undefined;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        ViewUtil.prototype.getProperties = function (instance) {
            var type = instance && instance.constructor;
            if (!type) {
                return new Map();
            }
            if (!propertyMaps.has(type)) {
                var propMap = new Map();
                for (var propName in instance) {
                    // tslint:disable:forin
                    propMap.set(propName.toLowerCase(), propName);
                }
                propertyMaps.set(type, propMap);
            }
            return propertyMaps.get(type);
        };
        ViewUtil.prototype.cssClasses = function (view) {
            if (!view.ngCssClasses) {
                view.ngCssClasses = new Map();
            }
            return view.ngCssClasses;
        };
        ViewUtil.prototype.addClass = function (view, className) {
            var extendedView = this.ensureNgViewExtensions(view);
            this.cssClasses(extendedView).set(className, true);
            this.syncClasses(extendedView);
        };
        ViewUtil.prototype.removeClass = function (view, className) {
            var extendedView = this.ensureNgViewExtensions(view);
            this.cssClasses(extendedView).delete(className);
            this.syncClasses(extendedView);
        };
        ViewUtil.prototype.setClasses = function (view, classesValue) {
            var _this = this;
            var classes = classesValue.split(whiteSpaceSplitter);
            this.cssClasses(view).clear();
            classes.forEach(function (className) { return _this.cssClasses(view).set(className, true); });
            this.syncClasses(view);
        };
        ViewUtil.prototype.syncClasses = function (view) {
            var classValue = Array.from(this.cssClasses(view).keys()).join(' ');
            view.className = classValue;
        };
        ViewUtil.prototype.setStyle = function (view, styleName, value) {
            view.style[styleName] = value;
        };
        ViewUtil.prototype.removeStyle = function (view, styleName) {
            view.style[styleName] = core.unsetValue;
        };
        return ViewUtil;
    }());

    var viewUtil = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ViewUtil: ViewUtil
    });

    /**
     * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular
     * application context.
     */
    var NativeScriptDomPortalOutlet = /** @class */ (function (_super) {
        __extends(NativeScriptDomPortalOutlet, _super);
        function NativeScriptDomPortalOutlet(
        /** Element into which the content is projected. */
        outletElement, _componentFactoryResolver, _appRef, _defaultInjector, viewUtil) {
            var _this = _super.call(this) || this;
            _this.outletElement = outletElement;
            _this._componentFactoryResolver = _componentFactoryResolver;
            _this._appRef = _appRef;
            _this._defaultInjector = _defaultInjector;
            /**
             * Attaches a DOM portal by transferring its content into the outlet.
             * @param portal Portal to be attached.
             * @deprecated To be turned into a method.
             * @breaking-change 10.0.0
             */
            _this.attachDomPortal = function (portal) {
                var element = portal.element;
                if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {
                    throw Error('DOM portal content must be attached to a parent node.');
                }
                // Anchor used to save the element's previous position so
                // that we can restore it when the portal is detached.
                var anchorNode = _this._viewUtil.createComment('dom-portal');
                _this._viewUtil.insertBefore(element.parentNode, anchorNode, element);
                _this._viewUtil.appendChild(_this.outletElement, element);
                _super.prototype.setDisposeFn.call(_this, function () {
                    // We can't use `replaceWith` here because IE doesn't support it.
                    if (anchorNode.parentNode) {
                        _this._viewUtil.insertBefore(anchorNode.parentNode, element, anchorNode);
                        _this._viewUtil.removeChild(anchorNode.parentNode, anchorNode);
                        //anchorNode.parentNode.replaceChild(element, anchorNode);
                    }
                });
            };
            _this._viewUtil = viewUtil || _this._defaultInjector.get(ViewUtil);
            return _this;
        }
        /**
         * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.
         * @param portal Portal to be attached
         * @returns Reference to the created component.
         */
        NativeScriptDomPortalOutlet.prototype.attachComponentPortal = function (portal) {
            var _this = this;
            var resolver = portal.componentFactoryResolver || this._componentFactoryResolver;
            var componentFactory = resolver.resolveComponentFactory(portal.component);
            var componentRef;
            // If the portal specifies a ViewContainerRef, we will use that as the attachment point
            // for the component (in terms of Angular's component tree, not rendering).
            // When the ViewContainerRef is missing, we use the factory to create the component directly
            // and then manually attach the view to the application.
            if (portal.viewContainerRef) {
                componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector);
                this.setDisposeFn(function () { return componentRef.destroy(); });
            }
            else {
                componentRef = componentFactory.create(portal.injector || this._defaultInjector);
                this._appRef.attachView(componentRef.hostView);
                this.setDisposeFn(function () {
                    _this._appRef.detachView(componentRef.hostView);
                    componentRef.destroy();
                });
            }
            // At this point the component has been instantiated, so we move it to the location in the DOM
            // where we want it to be rendered.
            var rootNode = this._getComponentRootNode(componentRef);
            if (rootNode.parent) {
                this._viewUtil.removeChild(rootNode.parent, rootNode);
            }
            this._viewUtil.appendChild(this.outletElement, this._getComponentRootNode(componentRef));
            return componentRef;
        };
        /**
         * Attaches a template portal to the DOM as an embedded view.
         * @param portal Portal to be attached.
         * @returns Reference to the created embedded view.
         */
        NativeScriptDomPortalOutlet.prototype.attachTemplatePortal = function (portal) {
            var _this = this;
            var viewContainer = portal.viewContainerRef;
            var viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);
            // The method `createEmbeddedView` will add the view as a child of the viewContainer.
            // But for the DomPortalOutlet the view can be added everywhere in the DOM
            // (e.g Overlay Container) To move the view to the specified host element. We just
            // re-append the existing root nodes.
            viewRef.rootNodes.forEach(function (rootNode) {
                if (rootNode.parent) {
                    _this._viewUtil.removeChild(rootNode.parent, rootNode);
                }
                _this._viewUtil.appendChild(_this.outletElement, rootNode);
            });
            // Note that we want to detect changes after the nodes have been moved so that
            // any directives inside the portal that are looking at the DOM inside a lifecycle
            // hook won't be invoked too early.
            viewRef.detectChanges();
            this.setDisposeFn(function () {
                var index = viewContainer.indexOf(viewRef);
                if (index !== -1) {
                    viewContainer.remove(index);
                }
            });
            // TODO(jelbourn): Return locals from view.
            return viewRef;
        };
        /**
         * Clears out a portal from the DOM.
         */
        NativeScriptDomPortalOutlet.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            if (this.outletElement.parentNode != null) {
                this._viewUtil.removeChild(this.outletElement.parentNode, this.outletElement);
            }
        };
        /** Gets the root HTMLElement for an instantiated component. */
        NativeScriptDomPortalOutlet.prototype._getComponentRootNode = function (componentRef) {
            return componentRef.hostView.rootNodes[0];
        };
        return NativeScriptDomPortalOutlet;
    }(BasePortalOutlet));
    NativeScriptDomPortalOutlet.ctorParameters = function () { return [
        { type: core.View },
        { type: i0.ComponentFactoryResolver },
        { type: i0.ApplicationRef },
        { type: i0.Injector },
        { type: ViewUtil, decorators: [{ type: i0.Optional }] }
    ]; };

    registerElement('DetachedContainer', function () { return core.ProxyViewContainer; }, {
        skipAddToDom: true,
    });
    /**
     * Wrapper component used for loading components when navigating
     * It uses DetachedContainer as selector so that it is containerRef is not attached to
     * the visual tree.
     */
    // eslint-disable-next-line @angular-eslint/component-class-suffix
    var DetachedLoader = /** @class */ (function () {
        // tslint:disable-line:component-class-suffix
        function DetachedLoader(resolver, changeDetector, containerRef, appRef) {
            this.resolver = resolver;
            this.changeDetector = changeDetector;
            this.containerRef = containerRef;
            this.appRef = appRef;
            this.disposeFunctions = [];
        }
        DetachedLoader.prototype.createComponentPortal = function (componentType, customInjector) {
            return new ComponentPortal(componentType, this.vc, customInjector || this.vc.injector);
        };
        DetachedLoader.prototype.createTemplatePortal = function (templateRef, context) {
            return new TemplatePortal(templateRef, this.vc, context);
        };
        DetachedLoader.prototype.loadInLocation = function (componentType) {
            var _this = this;
            var factory = this.resolver.resolveComponentFactory(componentType);
            var componentRef = factory.create(this.containerRef.injector);
            this.appRef.attachView(componentRef.hostView);
            this.disposeFunctions.push(function () {
                _this.appRef.detachView(componentRef.hostView);
                componentRef.destroy();
            });
            // Component is created, built may not be checked if we are loading
            // inside component with OnPush CD strategy. Mark us for check to be sure CD will reach us.
            // We are inside a promise here so no need for setTimeout - CD should trigger
            // after the promise.
            core.Trace.write('DetachedLoader.loadInLocation component loaded -> markForCheck', 'detached-loader');
            return componentRef;
        };
        DetachedLoader.prototype.ngOnDestroy = function () {
            this.disposeFunctions.forEach(function (fn) { return fn(); });
        };
        DetachedLoader.prototype.detectChanges = function () {
            this.changeDetector.markForCheck();
        };
        /**
         * @deprecated use Portals
         */
        DetachedLoader.prototype.loadComponent = function (componentType) {
            core.Trace.write('DetachedLoader.loadComponent', 'detached-loader');
            return Promise.resolve(this.loadInLocation(componentType));
        };
        /**
         * @deprecated use Portals
         */
        DetachedLoader.prototype.loadComponentSync = function (componentType) {
            core.Trace.write('DetachedLoader.loadComponent', 'detached-loader');
            return this.loadInLocation(componentType);
        };
        /**
         * @deprecated use Portals
         */
        DetachedLoader.prototype.loadWithFactory = function (factory) {
            var _this = this;
            var componentRef = factory.create(this.containerRef.injector);
            this.appRef.attachView(componentRef.hostView);
            this.disposeFunctions.push(function () {
                _this.appRef.detachView(componentRef.hostView);
                componentRef.destroy();
            });
            return componentRef;
        };
        return DetachedLoader;
    }());
    DetachedLoader.decorators = [
        { type: i0.Component, args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: 'DetachedContainer',
                    template: "<Placeholder #loader></Placeholder><ng-container #vc></ng-container><ng-content></ng-content>"
                },] }
    ];
    DetachedLoader.ctorParameters = function () { return [
        { type: i0.ComponentFactoryResolver },
        { type: i0.ChangeDetectorRef },
        { type: i0.ViewContainerRef },
        { type: i0.ApplicationRef }
    ]; };
    DetachedLoader.propDecorators = {
        vc: [{ type: i0.ViewChild, args: ['vc', { read: i0.ViewContainerRef, static: true },] }]
    };

    var NativescriptXhrFactory = /** @class */ (function (_super) {
        __extends(NativescriptXhrFactory, _super);
        function NativescriptXhrFactory() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        NativescriptXhrFactory.prototype.build = function () {
            return new XMLHttpRequest();
        };
        return NativescriptXhrFactory;
    }(common.XhrFactory));
    NativescriptXhrFactory.decorators = [
        { type: i0.Injectable }
    ];

    var ɵ0$5 = function addStyleToCss(style, tag) {
        if (tag) {
            core.addTaggedAdditionalCSS(style, tag);
        }
        else {
            core.Application.addCss(style);
        }
    };
    var addStyleToCss = core.profile('"renderer".addStyleToCss', ɵ0$5);
    var NativeScriptRendererFactory = /** @class */ (function () {
        function NativeScriptRendererFactory(rootView, namespaceFilters, rootModuleID, reuseViews) {
            this.rootView = rootView;
            this.namespaceFilters = namespaceFilters;
            this.rootModuleID = rootModuleID;
            this.reuseViews = reuseViews;
            this.componentRenderers = new Map();
            // backwards compatibility with RadListView
            this.viewUtil = new ViewUtil(this.namespaceFilters, this.reuseViews);
            if (typeof this.reuseViews !== 'boolean') {
                this.reuseViews = false; // default to false
            }
            this.defaultRenderer = new NativeScriptRenderer(rootView, namespaceFilters, this.reuseViews);
        }
        NativeScriptRendererFactory.prototype.createRenderer = function (hostElement, type) {
            var _this = this;
            if (NativeScriptDebug.enabled) {
                NativeScriptDebug.rendererLog("NativeScriptRendererFactory.createRenderer " + hostElement + ". type.id: " + type.id + " type.encapsulation: " + type.encapsulation);
            }
            if (!hostElement || !type) {
                return this.defaultRenderer;
            }
            var renderer = this.componentRenderers.get(type.id);
            /**
             *! WARNING
             *! We're reusing the renderer for the components
             *! this might cause unexpected behavior as the "rootView" is an arbitrary hostElement
             *! also, the renderer has it's .destroy() called!
             *! might be useful to create a BaseEmulatedRender and a ProxyEmulatedRender
             *! every component type gets a BaseEmulatedRender (singleton) which is passed to ProxyEmulatedRender
             *! ProxyEmulatedRenderer registers with BaseEmulatedRender so we can clean up things like CSS when it's not needed
             *! this might be useful if we find a way to HMR component styling without a full rebootstrap
             */
            if (renderer) {
                if (renderer instanceof EmulatedRenderer) {
                    renderer.applyToHost(hostElement);
                }
                return renderer;
            }
            if (type.encapsulation === i0.ViewEncapsulation.None) {
                type.styles.map(function (s) { return s.toString(); }).forEach(function (v) { return addStyleToCss(v, _this.rootModuleID); });
                renderer = this.defaultRenderer;
            }
            else {
                renderer = new EmulatedRenderer(type, hostElement, this.namespaceFilters, this.rootModuleID, this.reuseViews);
                renderer.applyToHost(hostElement);
            }
            this.componentRenderers.set(type.id, renderer);
            return renderer;
        };
        // begin?(): void {
        //     throw new Error("Method not implemented.");
        // }
        // end?(): void {
        //     throw new Error("Method not implemented.");
        // }
        NativeScriptRendererFactory.prototype.whenRenderingDone = function () {
            var _this = this;
            if (!this.rootView) {
                return Promise.resolve();
            }
            return new Promise(function (resolve) {
                var interval = 0;
                function scheduleResolve() {
                    // iOS really hates synchronous things...
                    // Utils.queueMacrotask(resolve);
                    setTimeout(resolve, 15);
                }
                function fireWhenLoaded() {
                    var view = rootFactory();
                    if (view.isLoaded) {
                        scheduleResolve();
                    }
                    else {
                        view.once('loaded', scheduleResolve);
                    }
                }
                var rootFactory = function () { return (_this.rootView instanceof core.ContentView ? _this.rootView.content : _this.rootView); };
                if (!rootFactory()) {
                    interval = setInterval(function () {
                        if (rootFactory()) {
                            clearInterval(interval);
                            fireWhenLoaded();
                        }
                    }, 10);
                }
                else {
                    fireWhenLoaded();
                }
            });
            // throw new Error("Method not implemented.");
        };
        return NativeScriptRendererFactory;
    }());
    NativeScriptRendererFactory.ctorParameters = function () { return [
        { type: core.View, decorators: [{ type: i0.Inject, args: [APP_ROOT_VIEW,] }] },
        { type: Array, decorators: [{ type: i0.Inject, args: [NAMESPACE_FILTERS,] }] },
        { type: undefined, decorators: [{ type: i0.Inject, args: [NATIVESCRIPT_ROOT_MODULE_ID,] }] },
        { type: undefined, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [ENABLE_REUSABE_VIEWS,] }] }
    ]; };
    var NativeScriptRenderer = /** @class */ (function () {
        function NativeScriptRenderer(rootView, namespaceFilters, reuseViews) {
            this.rootView = rootView;
            this.namespaceFilters = namespaceFilters;
            this.reuseViews = reuseViews;
            this.viewUtil = new ViewUtil(this.namespaceFilters, this.reuseViews);
            this.destroyNode = function (node) {
                if (NativeScriptDebug.enabled) {
                    NativeScriptDebug.rendererLog("NativeScriptRenderer.destroyNode node: " + node);
                }
                if (node === null || node === void 0 ? void 0 : node.destroyNode) {
                    node === null || node === void 0 ? void 0 : node.destroyNode();
                }
            };
        }
        Object.defineProperty(NativeScriptRenderer.prototype, "data", {
            get: function () {
                throw new Error('Method not implemented.');
            },
            enumerable: false,
            configurable: true
        });
        NativeScriptRenderer.prototype.destroy = function () {
            if (NativeScriptDebug.enabled) {
                NativeScriptDebug.rendererLog('NativeScriptRenderer.destroy');
            }
        };
        NativeScriptRenderer.prototype.createElement = function (name, namespace) {
            if (NativeScriptDebug.enabled) {
                NativeScriptDebug.rendererLog("NativeScriptRenderer.createElement: " + name);
            }
            var oldName;
            if (!isKnownView(name)) {
                oldName = name;
                name = 'ProxyViewContainer';
            }
            var view = this.viewUtil.createView(name);
            if (oldName) {
                view.customCSSName = oldName;
            }
            return view;
        };
        NativeScriptRenderer.prototype.createComment = function (value) {
            if (NativeScriptDebug.enabled) {
                NativeScriptDebug.rendererLog("NativeScriptRenderer.createComment " + value);
            }
            return this.viewUtil.createComment(value);
        };
        NativeScriptRenderer.prototype.createText = function (value) {
            if (NativeScriptDebug.enabled) {
                NativeScriptDebug.rendererLog("NativeScriptRenderer.createText " + value);
            }
            return this.viewUtil.createText(value);
        };
        NativeScriptRenderer.prototype.appendChild = function (parent, newChild) {
            if (NativeScriptDebug.enabled) {
                NativeScriptDebug.rendererLog("NativeScriptRenderer.appendChild child: " + newChild + " parent: " + parent);
            }
            this.viewUtil.appendChild(parent, newChild);
        };
        NativeScriptRenderer.prototype.insertBefore = function (parent, newChild, refChild) {
            if (NativeScriptDebug.enabled) {
                NativeScriptDebug.rendererLog("NativeScriptRenderer.insertBefore child: " + newChild + " " + ("parent: " + parent + " refChild: " + refChild));
            }
            this.viewUtil.insertBefore(parent, newChild, refChild);
        };
        NativeScriptRenderer.prototype.removeChild = function (parent, oldChild, isHostElement) {
            if (NativeScriptDebug.enabled) {
                NativeScriptDebug.rendererLog("NativeScriptRenderer.removeChild child: " + oldChild + " parent: " + parent);
            }
            this.viewUtil.removeChild(parent, oldChild);
        };
        NativeScriptRenderer.prototype.selectRootElement = function (selectorOrNode, preserveContent) {
            if (NativeScriptDebug.enabled) {
                NativeScriptDebug.rendererLog("NativeScriptRenderer.selectRootElement: " + selectorOrNode);
            }
            if (selectorOrNode instanceof core.View) {
                return selectorOrNode;
            }
            if (selectorOrNode && selectorOrNode[0] === '#') {
                var result = core.getViewById(this.rootView, selectorOrNode.slice(1));
                return (result || this.rootView);
            }
            if (typeof selectorOrNode === 'string') {
                var view = this.viewUtil.createView(selectorOrNode);
                if (getFirstNativeLikeView(view) === view) {
                    // view is nativelike!
                    this.appendChild(this.rootView, view);
                    return view;
                }
            }
            return this.rootView;
        };
        NativeScriptRenderer.prototype.parentNode = function (node) {
            if (NativeScriptDebug.enabled) {
                NativeScriptDebug.rendererLog("NativeScriptRenderer.parentNode for node: " + node + " is " + node.parentNode);
            }
            return node.parentNode;
        };
        NativeScriptRenderer.prototype.nextSibling = function (node) {
            if (NativeScriptDebug.enabled) {
                NativeScriptDebug.rendererLog("NativeScriptRenderer.nextSibling of " + node + " is " + node.nextSibling);
            }
            return node.nextSibling;
        };
        NativeScriptRenderer.prototype.setAttribute = function (el, name, value, namespace) {
            if (NativeScriptDebug.enabled) {
                NativeScriptDebug.rendererLog("NativeScriptRenderer.setAttribute " + (namespace ? namespace + ':' : '') + el + "." + name + " = " + value);
            }
            this.viewUtil.setProperty(el, name, value, namespace);
        };
        NativeScriptRenderer.prototype.removeAttribute = function (el, name, namespace) {
            if (NativeScriptDebug.enabled) {
                NativeScriptDebug.rendererLog("NativeScriptRenderer.removeAttribute " + (namespace ? namespace + ':' : '') + el + "." + name);
            }
        };
        NativeScriptRenderer.prototype.addClass = function (el, name) {
            if (NativeScriptDebug.enabled) {
                NativeScriptDebug.rendererLog("NativeScriptRenderer.addClass " + name);
            }
            this.viewUtil.addClass(el, name);
        };
        NativeScriptRenderer.prototype.removeClass = function (el, name) {
            if (NativeScriptDebug.enabled) {
                NativeScriptDebug.rendererLog("NativeScriptRenderer.removeClass " + name);
            }
            this.viewUtil.removeClass(el, name);
        };
        NativeScriptRenderer.prototype.setStyle = function (el, style, value, flags) {
            if (NativeScriptDebug.enabled) {
                NativeScriptDebug.rendererLog("NativeScriptRenderer.setStyle: " + el + ", " + style + " = " + value);
            }
            this.viewUtil.setStyle(el, style, value);
        };
        NativeScriptRenderer.prototype.removeStyle = function (el, style, flags) {
            if (NativeScriptDebug.enabled) {
                NativeScriptDebug.rendererLog('NativeScriptRenderer.removeStyle: ${styleName}');
            }
            this.viewUtil.removeStyle(el, style);
        };
        NativeScriptRenderer.prototype.setProperty = function (el, name, value) {
            if (NativeScriptDebug.enabled) {
                NativeScriptDebug.rendererLog("NativeScriptRenderer.setProperty " + el + "." + name + " = " + value);
            }
            this.viewUtil.setProperty(el, name, value);
        };
        NativeScriptRenderer.prototype.setValue = function (node, value) {
            if (NativeScriptDebug.enabled) {
                NativeScriptDebug.rendererLog("NativeScriptRenderer.setValue renderNode: " + node + ", value: " + value);
            }
            // throw new Error("Method not implemented.");
        };
        NativeScriptRenderer.prototype.listen = function (target, eventName, callback) {
            // throw new Error("Method not implemented.");
            if (NativeScriptDebug.enabled) {
                NativeScriptDebug.rendererLog("NativeScriptRenderer.listen: " + eventName);
            }
            target.on(eventName, callback);
            if (eventName === core.View.loadedEvent && target.isLoaded) {
                // we must create a new obervable here to ensure that the event goes through whatever zone patches are applied
                var obs = new core.Observable();
                obs.once(eventName, callback);
                obs.notify({
                    eventName: eventName,
                    object: target,
                });
            }
            return function () { return target.off(eventName, callback); };
        };
        return NativeScriptRenderer;
    }());
    // CONTENT_ATTR not exported from nativescript-renderer - we need it for styles application.
    var COMPONENT_REGEX = /%COMP%/g;
    var ATTR_SANITIZER = /-/g;
    var COMPONENT_VARIABLE = '%COMP%';
    var HOST_ATTR = "_nghost-" + COMPONENT_VARIABLE;
    var CONTENT_ATTR = "_ngcontent-" + COMPONENT_VARIABLE;
    var replaceNgAttribute = function (input, componentId) {
        return input.replace(COMPONENT_REGEX, componentId);
    };
    var ɵ1$2 = replaceNgAttribute;
    var ɵ2$2 = function addScopedStyleToCss(style, tag) {
        if (tag) {
            core.addTaggedAdditionalCSS(style, tag);
        }
        else {
            core.Application.addCss(style);
        }
    };
    var addScopedStyleToCss = core.profile("\"renderer\".addScopedStyleToCss", ɵ2$2);
    var EmulatedRenderer = /** @class */ (function (_super) {
        __extends(EmulatedRenderer, _super);
        function EmulatedRenderer(component, rootView, namespaceFilters, rootModuleId, reuseViews) {
            var _this = _super.call(this, rootView, namespaceFilters, reuseViews) || this;
            _this.rootModuleId = rootModuleId;
            var componentId = component.id.replace(ATTR_SANITIZER, '_');
            _this.contentAttr = replaceNgAttribute(CONTENT_ATTR, componentId);
            _this.hostAttr = replaceNgAttribute(HOST_ATTR, componentId);
            _this.addStyles(component.styles, componentId);
            return _this;
        }
        EmulatedRenderer.prototype.applyToHost = function (view) {
            _super.prototype.setAttribute.call(this, view, this.hostAttr, '');
        };
        EmulatedRenderer.prototype.appendChild = function (parent, newChild) {
            _super.prototype.appendChild.call(this, parent, newChild);
        };
        EmulatedRenderer.prototype.createElement = function (parent, name) {
            var view = _super.prototype.createElement.call(this, parent, name);
            // Set an attribute to the view to scope component-specific css.
            // The property name is pre-generated by Angular.
            _super.prototype.setAttribute.call(this, view, this.contentAttr, '');
            return view;
        };
        EmulatedRenderer.prototype.addStyles = function (styles, componentId) {
            var _this = this;
            styles
                .map(function (s) { return s.toString(); })
                .map(function (s) { return replaceNgAttribute(s, componentId); })
                .forEach(function (s) { return addScopedStyleToCss(s, _this.rootModuleId); });
        };
        return EmulatedRenderer;
    }(NativeScriptRenderer));
    EmulatedRenderer.decorators = [
        { type: i0.Injectable }
    ];
    EmulatedRenderer.ctorParameters = function () { return [
        { type: undefined },
        { type: core.View },
        { type: Array },
        { type: undefined },
        { type: Boolean }
    ]; };
    __decorate([
        core.profile
    ], EmulatedRenderer.prototype, "addStyles", null);

    var PageService = /** @class */ (function () {
        function PageService(page, elRef, view) {
            var _a;
            this._pageEvents$ = new rxjs.Subject();
            if (page) {
                this.page = page;
            }
            else {
                view = view || elRef.nativeElement;
                while (view) {
                    if (view instanceof core.Page) {
                        this.page = view;
                        break;
                    }
                    view = view.parent;
                }
            }
            this._inPage$ = new rxjs.BehaviorSubject(!!((_a = this.page) === null || _a === void 0 ? void 0 : _a.isLoaded));
            if (this.page) {
                this.page.on('navigatedFrom', this.pageEvent, this);
                this.page.on('navigatedTo', this.pageEvent, this);
                this.page.on('navigatingFrom', this.pageEvent, this);
                this.page.on('navigatingTo', this.pageEvent, this);
            }
        }
        Object.defineProperty(PageService.prototype, "inPage", {
            get: function () {
                return this._inPage$.value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PageService.prototype, "inPage$", {
            get: function () {
                return this._inPage$.pipe(operators.distinctUntilChanged());
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PageService.prototype, "pageEvents$", {
            get: function () {
                return this._pageEvents$.asObservable();
            },
            enumerable: false,
            configurable: true
        });
        PageService.prototype.ngOnDestroy = function () {
            if (this.page) {
                this.page.off('navigatedFrom', this.pageEvent, this);
                this.page.off('navigatedTo', this.pageEvent, this);
                this.page.off('navigatingFrom', this.pageEvent, this);
                this.page.off('navigatingTo', this.pageEvent, this);
            }
            this._inPage$.complete();
            this._pageEvents$.complete();
        };
        PageService.prototype.pageEvent = function (evt) {
            this._pageEvents$.next(evt);
            switch (evt.eventName) {
                case 'navigatedTo':
                    this._inPage$.next(true);
                    break;
                case 'navigatedFrom':
                    this._inPage$.next(false);
                    break;
                default:
            }
        };
        return PageService;
    }());
    PageService.decorators = [
        { type: i0.Injectable }
    ];
    PageService.ctorParameters = function () { return [
        { type: core.Page, decorators: [{ type: i0.Optional }] },
        { type: i0.ElementRef, decorators: [{ type: i0.Optional }] },
        { type: core.ViewBase, decorators: [{ type: i0.Optional }] }
    ]; };

    function customFrameComponentFactory(v) {
        return v.element.nativeElement;
    }
    function customPageFactoryFromFrame(v) {
        return v.page;
    }
    registerElement('FramePage', function () { return core.Frame; }, {
        insertChild: function (parent, child) {
            if (child instanceof core.Page) {
                frameMeta.insertChild(parent, child);
                return;
            }
            parent['__ng_page__'].content = child;
        },
    });
    var FramePageComponent = /** @class */ (function () {
        function FramePageComponent(element, renderer) {
            this.element = element;
            this.actionBarHidden = false;
            this.page = renderer.createElement('Page');
            element.nativeElement['__ng_page__'] = this.page;
            renderer.appendChild(element.nativeElement, this.page);
        }
        FramePageComponent.prototype.ngOnChanges = function (changes) {
            if (changes.actionBarHidden && changes.actionBarHidden.previousValue !== changes.actionBarHidden.currentValue) {
                if (this.page) {
                    this.page.actionBarHidden = !!this.actionBarHidden;
                }
            }
        };
        FramePageComponent.prototype.ngAfterViewInit = function () {
            if (this.page) {
                this.page.actionBarHidden = !!this.actionBarHidden;
            }
        };
        return FramePageComponent;
    }());
    FramePageComponent.decorators = [
        { type: i0.Component, args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: 'FramePage',
                    template: "<ng-content></ng-content>",
                    providers: [
                        {
                            provide: core.Frame,
                            useFactory: customFrameComponentFactory,
                            deps: [FramePageComponent],
                        },
                        {
                            provide: core.Page,
                            useFactory: customPageFactoryFromFrame,
                            deps: [FramePageComponent],
                        },
                        PageService,
                    ]
                },] }
    ];
    FramePageComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };
    FramePageComponent.propDecorators = {
        actionBarHidden: [{ type: i0.Input }]
    };

    function customFrameDirectiveFactory(v) {
        return v.element.nativeElement;
    }
    var FrameDirective = /** @class */ (function () {
        function FrameDirective(element) {
            this.element = element;
        }
        return FrameDirective;
    }());
    FrameDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'Frame',
                    providers: [
                        {
                            provide: core.Frame,
                            useFactory: customFrameDirectiveFactory,
                            deps: [FrameDirective],
                        },
                    ],
                },] }
    ];
    FrameDirective.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };

    function customPageFactory(v) {
        return v.element.nativeElement;
    }
    var PageDirective = /** @class */ (function () {
        function PageDirective(element) {
            this.element = element;
        }
        return PageDirective;
    }());
    PageDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'Page',
                    providers: [
                        {
                            provide: core.Page,
                            useFactory: customPageFactory,
                            deps: [PageDirective],
                        },
                        PageService,
                    ],
                },] }
    ];
    PageDirective.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };

    var FramePageModule = /** @class */ (function () {
        function FramePageModule() {
        }
        return FramePageModule;
    }());
    FramePageModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [FrameDirective, PageDirective, FramePageComponent],
                    exports: [FrameDirective, PageDirective, FramePageComponent],
                },] }
    ];

    function isPresent(obj) {
        return obj !== undefined && obj !== null;
    }
    function isBlank(obj) {
        return obj === undefined || obj === null;
    }

    function isActionItem(view) {
        return view instanceof core.ActionItem;
    }
    function isNavigationButton(view) {
        return view instanceof core.NavigationButton;
    }
    var ɵ0$4 = function (parent, child, next) {
        if (isInvisibleNode(child)) {
            return;
        }
        else if (isNavigationButton(child)) {
            parent.navigationButton = child;
            child.parentNode = parent;
        }
        else if (isActionItem(child)) {
            addActionItem(parent, child, next);
            child.parentNode = parent;
        }
        else if (isView(child)) {
            parent.titleView = child;
        }
    }, ɵ1$1 = function (parent, child) {
        if (isInvisibleNode(child)) {
            return;
        }
        else if (isNavigationButton(child)) {
            if (parent.navigationButton === child) {
                parent.navigationButton = null;
            }
            child.parentNode = null;
        }
        else if (isActionItem(child)) {
            parent.actionItems.removeItem(child);
            child.parentNode = null;
        }
        else if (isView(child) && parent.titleView && parent.titleView === child) {
            parent.titleView = null;
        }
    };
    var actionBarMeta = {
        skipAddToDom: true,
        insertChild: ɵ0$4,
        removeChild: ɵ1$1,
    };
    registerElement('ActionBar', function () { return core.ActionBar; }, actionBarMeta);
    registerElement('ActionItem', function () { return core.ActionItem; });
    registerElement('NavigationButton', function () { return core.NavigationButton; });
    var addActionItem = function (bar, item, next) {
        if (next) {
            insertActionItemBefore(bar, item, next);
        }
        else {
            appendActionItem(bar, item);
        }
    };
    var ɵ2$1 = addActionItem;
    var insertActionItemBefore = function (bar, item, next) {
        var actionItems = bar.actionItems;
        var actionItemsCollection = actionItems.getItems();
        var indexToInsert = actionItemsCollection.indexOf(next);
        actionItemsCollection.splice(indexToInsert, 0, item);
        actionItems.setItems(actionItemsCollection);
    };
    var ɵ3$1 = insertActionItemBefore;
    var appendActionItem = function (bar, item) {
        bar.actionItems.addItem(item);
    };
    var ɵ4 = appendActionItem;
    var ActionBarComponent = /** @class */ (function () {
        function ActionBarComponent(element, page) {
            this.element = element;
            this.page = page;
            if (!this.page) {
                throw new Error('Inside ActionBarComponent but no Page found in DI.');
            }
            if (isBlank(this.page.actionBarHidden)) {
                this.page.actionBarHidden = false;
            }
            this.page.actionBar = this.element.nativeElement;
            this.page.actionBar.update();
        }
        return ActionBarComponent;
    }());
    ActionBarComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ActionBar',
                    template: '<ng-content></ng-content>'
                },] }
    ];
    ActionBarComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: core.Page }
    ]; };
    var ActionBarScope = /** @class */ (function () {
        // tslint:disable-line:component-class-suffix
        function ActionBarScope(page) {
            this.page = page;
            if (!this.page) {
                throw new Error('Inside ActionBarScope but no Page found in DI.');
            }
        }
        ActionBarScope.prototype.onNavButtonInit = function (navBtn) {
            this.page.actionBar.navigationButton = navBtn.element.nativeElement;
        };
        ActionBarScope.prototype.onNavButtonDestroy = function (navBtn) {
            var nav = navBtn.element.nativeElement;
            if (nav && this.page.actionBar.navigationButton === nav) {
                this.page.actionBar.navigationButton = null;
            }
        };
        ActionBarScope.prototype.onActionInit = function (item) {
            this.page.actionBar.actionItems.addItem(item.element.nativeElement);
        };
        ActionBarScope.prototype.onActionDestroy = function (item) {
            if (item.element.nativeElement.actionBar) {
                this.page.actionBar.actionItems.removeItem(item.element.nativeElement);
            }
        };
        return ActionBarScope;
    }());
    ActionBarScope.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ActionBarExtension',
                    template: ''
                },] }
    ];
    ActionBarScope.ctorParameters = function () { return [
        { type: core.Page }
    ]; };
    var ActionItemDirective = /** @class */ (function () {
        function ActionItemDirective(element, ownerScope) {
            this.element = element;
            this.ownerScope = ownerScope;
            if (this.ownerScope) {
                this.ownerScope.onActionInit(this);
            }
        }
        ActionItemDirective.prototype.ngOnDestroy = function () {
            if (this.ownerScope) {
                this.ownerScope.onActionDestroy(this);
            }
        };
        return ActionItemDirective;
    }());
    ActionItemDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'ActionItem', // tslint:disable-line:directive-selector
                },] }
    ];
    ActionItemDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: ActionBarScope, decorators: [{ type: i0.Optional }] }
    ]; };
    var NavigationButtonDirective = /** @class */ (function () {
        function NavigationButtonDirective(element, ownerScope) {
            this.element = element;
            this.ownerScope = ownerScope;
            if (this.ownerScope) {
                this.ownerScope.onNavButtonInit(this);
            }
        }
        NavigationButtonDirective.prototype.ngOnDestroy = function () {
            if (this.ownerScope) {
                this.ownerScope.onNavButtonDestroy(this);
            }
        };
        return NavigationButtonDirective;
    }());
    NavigationButtonDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'NavigationButton', // tslint:disable-line:directive-selector
                },] }
    ];
    NavigationButtonDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: ActionBarScope, decorators: [{ type: i0.Optional }] }
    ]; };

    var NG_VIEW = '_ngViewRef';
    var TEMPLATED_ITEMS_COMPONENT = new i0.InjectionToken('TemplatedItemsComponent');
    var ItemContext = /** @class */ (function () {
        function ItemContext($implicit, item, index, even, odd) {
            this.$implicit = $implicit;
            this.item = item;
            this.index = index;
            this.even = even;
            this.odd = odd;
        }
        return ItemContext;
    }());
    var NsTemplatedItem = /** @class */ (function () {
        function NsTemplatedItem(template, location, onCreate) {
            this.template = template;
            this.location = location;
            this.onCreate = onCreate;
        }
        NsTemplatedItem.prototype.create = function (context) {
            var viewRef = this.location.createEmbeddedView(this.template, context ? this.setupItemContext(context) : new ItemContext());
            viewRef.detach(); // create detached, just beware this doesn't always work and the view might run the first CD anyway.
            var resultView = getItemViewRoot(viewRef);
            resultView[NG_VIEW] = viewRef;
            if (this.onCreate) {
                this.onCreate(resultView);
            }
            return resultView;
        };
        NsTemplatedItem.prototype.update = function (view, context) {
            var viewRef = this.getEmbeddedViewRef(view);
            this.setupItemContext(context, viewRef);
            viewRef === null || viewRef === void 0 ? void 0 : viewRef.detectChanges();
        };
        NsTemplatedItem.prototype.attach = function (view) {
            var viewRef = this.getEmbeddedViewRef(view);
            viewRef === null || viewRef === void 0 ? void 0 : viewRef.reattach();
            viewRef === null || viewRef === void 0 ? void 0 : viewRef.detectChanges();
        };
        NsTemplatedItem.prototype.detach = function (view) {
            var viewRef = this.getEmbeddedViewRef(view);
            viewRef === null || viewRef === void 0 ? void 0 : viewRef.detach();
        };
        NsTemplatedItem.prototype.dispose = function (view) {
            var viewRef = this.getEmbeddedViewRef(view);
            viewRef === null || viewRef === void 0 ? void 0 : viewRef.destroy();
        };
        NsTemplatedItem.prototype.getEmbeddedViewRef = function (view) {
            var viewRef = view[NG_VIEW];
            // Getting angular view from original element (in cases when ProxyViewContainer
            // is used NativeScript internally wraps it in a StackLayout)
            if (!viewRef && view instanceof core.LayoutBase && view.getChildrenCount() > 0) {
                viewRef = view.getChildAt(0)[NG_VIEW];
            }
            return viewRef;
        };
        NsTemplatedItem.prototype.isValid = function (view) {
            return !!this.getEmbeddedViewRef(view);
        };
        NsTemplatedItem.prototype.setupItemContext = function (_b, oldView) {
            var index = _b.index, data = _b.data;
            var context = oldView ? oldView.context : new ItemContext();
            context.$implicit = data;
            context.item = data;
            context.index = index;
            context.even = index % 2 === 0;
            context.odd = !context.even;
            return context;
        };
        return NsTemplatedItem;
    }());
    var ListViewComponent = /** @class */ (function () {
        function ListViewComponent(_elementRef, _iterableDiffers, zone) {
            this._iterableDiffers = _iterableDiffers;
            this.zone = zone;
            this._viewToTemplate = new WeakMap();
            this.setupItemView = new i0.EventEmitter();
            this.templatedItemsView = _elementRef.nativeElement;
        }
        Object.defineProperty(ListViewComponent.prototype, "nativeElement", {
            get: function () {
                return this.templatedItemsView;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ListViewComponent.prototype, "items", {
            get: function () {
                return this._items;
            },
            set: function (value) {
                this._items = value;
                var needDiffer = true;
                if (value instanceof core.ObservableArray) {
                    needDiffer = false;
                }
                if (needDiffer && !this._differ && i0.ɵisListLikeIterable(value)) {
                    this._differ = this._iterableDiffers.find(this._items).create(function (_index, item) {
                        return item;
                    });
                }
                this.templatedItemsView.items = this._items;
            },
            enumerable: false,
            configurable: true
        });
        ListViewComponent.prototype.ngAfterContentInit = function () {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.listViewLog('TemplatedItemsView.ngAfterContentInit()');
            }
            this.setItemTemplates();
        };
        ListViewComponent.prototype.ngOnDestroy = function () {
            this.templatedItemsView = null;
            if (this._templateMap) {
                this._templateMap.clear();
            }
        };
        ListViewComponent.prototype.setItemTemplates = function () {
            var _this = this;
            var _a;
            // The itemTemplateQuery may be changed after list items are added that contain <template> inside,
            // so cache and use only the original template to avoid errors.
            this.fallbackItemTemplate = this.itemTemplateQuery;
            if (this.fallbackItemTemplate && !((_a = this._templateMap) === null || _a === void 0 ? void 0 : _a.has('default'))) {
                // apparently you can create a Core ListView without a template...
                // we also add a fallback default for when the user sets multiple templates but no templateSelector
                this.registerTemplate('default', this.fallbackItemTemplate);
            }
            if (this._templateMap) {
                // sometimes templates are registered before loader is ready, so we update here
                this._templateMap.forEach(function (t) { return (t.location = _this.loader); });
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.listViewLog('Setting templates');
                }
                var templates_1 = [];
                this._templateMap.forEach(function (value, key) {
                    templates_1.push({
                        createView: function () { return null; },
                        key: key,
                    });
                });
                this.templatedItemsView.itemTemplates = templates_1;
            }
        };
        ListViewComponent.prototype.registerTemplate = function (key, template) {
            var _this = this;
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.listViewLog("registerTemplate for key: " + key + ", " + this.loader);
            }
            if (!this._templateMap) {
                this._templateMap = new Map();
            }
            this._templateMap.set(key, new NsTemplatedItem(template, this.loader, function (v) { return _this._viewToTemplate.set(v, key); }));
        };
        ListViewComponent.prototype.onItemLoading = function (args) {
            if (!this._templateMap) {
                return;
            }
            var index = args.index;
            var lview = args.object;
            var items = lview.items;
            var currentItem = 'getItem' in items && typeof items.getItem === 'function' ? items.getItem(index) : items[index];
            var template;
            if (args.view) {
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.listViewLog("onItemLoading: " + index + " - Reusing existing view");
                }
                var templateKey = this._viewToTemplate.get(args.view);
                if (!templateKey && args.view instanceof core.LayoutBase && args.view.getChildrenCount() > 0) {
                    templateKey = this._viewToTemplate.get(args.view.getChildAt(0));
                }
                if (!templateKey) {
                    // this template was not created by us
                    if (NativeScriptDebug.isLogEnabled()) {
                        NativeScriptDebug.listViewError("ViewReference not found for item " + index + ". View recycling is not working");
                    }
                    return;
                }
                template = this._templateMap.get(templateKey);
                template.update(args.view, { index: index, data: currentItem });
            }
            else {
                // this should never enter if it creates the view
                var templateKey = typeof lview.itemTemplateSelector === 'function' ? lview.itemTemplateSelector(currentItem, index, items) : 'default';
                template = this._templateMap.get(templateKey);
                if (!template) {
                    if (NativeScriptDebug.isLogEnabled()) {
                        NativeScriptDebug.listViewError("Template for key '" + templateKey + "' not found.");
                    }
                    return;
                }
                args.view = template.create({ index: index, data: currentItem });
            }
            this.setupViewRef(template.getEmbeddedViewRef(args.view), currentItem, index, args.view);
            template.attach(args.view);
            i0.ɵmarkDirty(this);
        };
        ListViewComponent.prototype.setupViewRef = function (viewRef, data, index, nativeElement) {
            var context = viewRef.context;
            this.setupItemView.next({ view: viewRef, nativeElement: nativeElement, data: data, index: index, context: context });
        };
        ListViewComponent.prototype.ngDoCheck = function () {
            if (this._differ) {
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.listViewLog('ngDoCheck() - execute differ');
                }
                var changes = this._differ.diff(this._items);
                if (changes) {
                    if (NativeScriptDebug.isLogEnabled()) {
                        NativeScriptDebug.listViewLog('ngDoCheck() - refresh');
                    }
                    this.templatedItemsView.refresh();
                }
            }
        };
        return ListViewComponent;
    }());
    ListViewComponent.decorators = [
        { type: i0.Component, args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: 'ListView',
                    template: "<DetachedContainer>\n    <ng-container #loader></ng-container>\n  </DetachedContainer>",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    providers: [{ provide: TEMPLATED_ITEMS_COMPONENT, useExisting: i0.forwardRef(function () { return ListViewComponent; }) }]
                },] }
    ];
    ListViewComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.IterableDiffers },
        { type: i0.NgZone }
    ]; };
    ListViewComponent.propDecorators = {
        loader: [{ type: i0.ViewChild, args: ['loader', { read: i0.ViewContainerRef, static: true },] }],
        setupItemView: [{ type: i0.Output }],
        itemTemplateQuery: [{ type: i0.ContentChild, args: [i0.TemplateRef, { read: i0.TemplateRef, static: false },] }],
        items: [{ type: i0.Input }],
        onItemLoading: [{ type: i0.HostListener, args: ['itemLoading', ['$event'],] }]
    };
    __decorate([
        core.profile
    ], ListViewComponent.prototype, "onItemLoading", null);
    function getItemViewRoot(viewRef, rootLocator) {
        if (rootLocator === void 0) { rootLocator = extractSingleViewRecursive; }
        var rootView = rootLocator(viewRef.rootNodes, 0);
        return rootView;
    }
    // eslint-disable-next-line @angular-eslint/directive-selector
    var TemplateKeyDirective = /** @class */ (function () {
        function TemplateKeyDirective(templateRef, comp) {
            this.templateRef = templateRef;
            this.comp = comp;
        }
        Object.defineProperty(TemplateKeyDirective.prototype, "nsTemplateKey", {
            set: function (value) {
                if (this.comp && this.templateRef) {
                    this.comp.registerTemplate(value, this.templateRef);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TemplateKeyDirective.prototype, "nsTemplateKeys", {
            set: function (values) {
                var _this = this;
                // single template with multiple keys
                if (this.comp && this.templateRef && values) {
                    values.forEach(function (value) { return _this.comp.registerTemplate(value, _this.templateRef); });
                }
            },
            enumerable: false,
            configurable: true
        });
        return TemplateKeyDirective;
    }());
    TemplateKeyDirective.decorators = [
        { type: i0.Directive, args: [{ selector: '[nsTemplateKey],[nsTemplateKeys]' },] }
    ];
    TemplateKeyDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef },
        { type: undefined, decorators: [{ type: i0.Host }, { type: i0.Inject, args: [TEMPLATED_ITEMS_COMPONENT,] }] }
    ]; };
    TemplateKeyDirective.propDecorators = {
        nsTemplateKey: [{ type: i0.Input }],
        nsTemplateKeys: [{ type: i0.Input }]
    };

    /**
     * Utility method to ensure a NgModule is only imported once in a codebase, otherwise will throw to help prevent accidental double importing
     * @param parentModule Parent module name
     * @param moduleName The module name
     */
    function throwIfAlreadyLoaded(parentModule, moduleName) {
        if (parentModule) {
            throw new Error(moduleName + " has already been loaded. Import " + moduleName + " in the AppModule only.");
        }
    }
    /**
     * Utility method which will only fire the callback once ever
     * @param fn callback to call only once
     */
    function once(fn) {
        var wasCalled = false;
        return function wrapper() {
            if (wasCalled) {
                return;
            }
            wasCalled = true;
            fn.apply(null, arguments);
        };
    }

    var FrameService = /** @class */ (function () {
        function FrameService() {
        }
        // TODO: Add any methods that are needed to handle frame/page navigation
        FrameService.prototype.getFrame = function () {
            return core.Frame.topmost();
        };
        return FrameService;
    }());
    FrameService.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function FrameService_Factory() { return new FrameService(); }, token: FrameService, providedIn: "root" });
    FrameService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    var Outlet = /** @class */ (function () {
        function Outlet(outletKey, path, pathByOutlets, modalNavigationDepth) {
            // More than one frame available when using NSEmptyOutletComponent component
            // in module that lazy loads children (loadChildren) and has outlet name.
            this.frames = [];
            this.states = [];
            // Used in reuse-strategy by its children to determine if they should be detached too.
            this.shouldDetach = true;
            this.outletKeys = [outletKey];
            this.isPageNavigationBack = false;
            this.showingModal = false;
            this.modalNavigationDepth = modalNavigationDepth || 0;
            this.pathByOutlets = pathByOutlets;
            this.path = path;
        }
        Outlet.prototype.containsFrame = function (frame) {
            return this.frames.indexOf(frame) > -1;
        };
        Outlet.prototype.peekState = function () {
            if (this.states.length > 0) {
                return this.states[this.states.length - 1];
            }
            return null;
        };
        Outlet.prototype.containsTopState = function (stateUrl) {
            var lastState = this.peekState();
            return lastState && lastState.segmentGroup.toString() === stateUrl;
        };
        // Search for frame that can go back.
        // Nested 'primary' outlets could result in Outlet with multiple navigatable frames.
        Outlet.prototype.getFrameToBack = function () {
            var frame = this.frames[this.frames.length - 1];
            if (!this.isNSEmptyOutlet) {
                for (var index = this.frames.length - 1; index >= 0; index--) {
                    var currentFrame = this.frames[index];
                    if (currentFrame.canGoBack()) {
                        frame = currentFrame;
                        break;
                    }
                }
            }
            return frame;
        };
        return Outlet;
    }());
    var defaultNavOptions = {
        clearHistory: false,
        animated: true,
    };

    var NSLocationStrategy = /** @class */ (function (_super) {
        __extends(NSLocationStrategy, _super);
        function NSLocationStrategy(frameService, startPath) {
            var _this = _super.call(this) || this;
            _this.frameService = frameService;
            _this.startPath = startPath;
            _this.outlets = [];
            _this.popStateCallbacks = new Array();
            _this._modalNavigationDepth = 0;
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('NSLocationStrategy.constructor()');
            }
            return _this;
        }
        NSLocationStrategy.prototype.path = function () {
            if (!this.currentUrlTree) {
                return this.startPath || '/';
            }
            var state = this.currentOutlet && this.currentOutlet.peekState();
            if (!state) {
                return '/';
            }
            var tree = this.currentUrlTree;
            var changedOutlet = this.getSegmentGroupByOutlet(this.currentOutlet);
            // Handle case where the user declares a component at path "/".
            // The url serializer doesn't parse this url as having a primary outlet.
            if (state.isRootSegmentGroup) {
                tree.root = state.segmentGroup;
            }
            else if (changedOutlet) {
                this.updateSegmentGroup(tree.root, changedOutlet, state.segmentGroup);
            }
            var urlSerializer = new i1.DefaultUrlSerializer();
            tree.queryParams = state.queryParams;
            var url = urlSerializer.serialize(tree);
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('NSLocationStrategy.path(): ' + url);
            }
            return url;
        };
        NSLocationStrategy.prototype.prepareExternalUrl = function (internal) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('NSLocationStrategy.prepareExternalUrl() internal: ' + internal);
            }
            return internal;
        };
        NSLocationStrategy.prototype.pushState = function (state, title, url, queryParams) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('NSLocationStrategy.pushState state: ' + (state + ", title: " + title + ", url: " + url + ", queryParams: " + queryParams));
            }
            this.pushStateInternal(state, title, url, queryParams);
        };
        NSLocationStrategy.prototype.pushStateInternal = function (state, title, url, queryParams) {
            var _this = this;
            var urlSerializer = new i1.DefaultUrlSerializer();
            this.currentUrlTree = urlSerializer.parse(url);
            var urlTreeRoot = this.currentUrlTree.root;
            // Handle case where the user declares a component at path "/".
            // The url serializer doesn't parse this url as having a primary outlet.
            if (!Object.keys(urlTreeRoot.children).length) {
                var segmentGroup = this.currentUrlTree && this.currentUrlTree.root;
                var outletKey = this.getOutletKey(this.getSegmentGroupFullPath(segmentGroup), 'primary');
                var outlet = this.findOutlet(outletKey);
                if (outlet && this.updateStates(outlet, segmentGroup, this.currentUrlTree.queryParams)) {
                    this.currentOutlet = outlet; // If states updated
                }
                else if (!outlet) {
                    // tslint:disable-next-line:max-line-length
                    var rootOutlet = this.createOutlet('primary', null, segmentGroup, null, null, this.currentUrlTree.queryParams);
                    this.currentOutlet = rootOutlet;
                }
                this.currentOutlet.peekState().isRootSegmentGroup = true;
                return;
            }
            var queue = [];
            var currentTree = urlTreeRoot;
            while (currentTree) {
                Object.keys(currentTree.children).forEach(function (outletName) {
                    var currentSegmentGroup = currentTree.children[outletName];
                    currentSegmentGroup.outlet = outletName;
                    currentSegmentGroup.root = urlTreeRoot;
                    var outletPath = _this.getSegmentGroupFullPath(currentTree);
                    var outletKey = _this.getOutletKey(outletPath, outletName);
                    var outlet = _this.findOutlet(outletKey);
                    var parentOutletName = currentTree.outlet || '';
                    var parentOutletPath = _this.getSegmentGroupFullPath(currentTree.parent);
                    var parentOutletKey = _this.getOutletKey(parentOutletPath, parentOutletName);
                    var parentOutlet = _this.findOutlet(parentOutletKey);
                    var containsLastState = outlet && outlet.containsTopState(currentSegmentGroup.toString());
                    if (!outlet) {
                        // tslint:disable-next-line:max-line-length
                        outlet = _this.createOutlet(outletKey, outletPath, currentSegmentGroup, parentOutlet, _this._modalNavigationDepth, _this.currentUrlTree.queryParams);
                        _this.currentOutlet = outlet;
                    }
                    else if (_this._modalNavigationDepth > 0 && outlet.showingModal && !containsLastState) {
                        // Navigation inside modal view.
                        _this.upsertModalOutlet(outlet, currentSegmentGroup, _this.currentUrlTree.queryParams);
                    }
                    else {
                        outlet.parent = parentOutlet;
                        if (_this.updateStates(outlet, currentSegmentGroup, _this.currentUrlTree.queryParams)) {
                            _this.currentOutlet = outlet; // If states updated
                        }
                    }
                    queue.push(currentSegmentGroup);
                });
                currentTree = queue.shift();
            }
        };
        NSLocationStrategy.prototype.replaceState = function (state, title, url, queryParams) {
            var states = this.currentOutlet && this.currentOutlet.states;
            if (states && states.length > 0) {
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.routerLog('NSLocationStrategy.replaceState changing existing state: ' + (state + ", title: " + title + ", url: " + url + ", queryParams: " + queryParams));
                }
            }
            else {
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.routerLog('NSLocationStrategy.replaceState pushing new state: ' + (state + ", title: " + title + ", url: " + url + ", queryParams: " + queryParams));
                }
                this.pushStateInternal(state, title, url, queryParams);
            }
        };
        NSLocationStrategy.prototype.forward = function () {
            throw new Error('NSLocationStrategy.forward() - not implemented');
        };
        NSLocationStrategy.prototype.back = function (outlet, frame) {
            this.currentOutlet = outlet || this.currentOutlet;
            if (this.currentOutlet.isPageNavigationBack) {
                var states = this.currentOutlet.states;
                // We are navigating to the previous page
                // clear the stack until we get to a page navigation state
                var state = states.pop();
                var count = 1;
                if (frame) {
                    while (state.frame && state.frame !== frame) {
                        state = states.pop();
                        count++;
                    }
                }
                while (!state.isPageNavigation) {
                    state = states.pop();
                    count++;
                }
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.routerLog("NSLocationStrategy.back() while navigating back. States popped: " + count);
                }
                this.callPopState(state, true);
            }
            else {
                var state = this.currentOutlet.peekState();
                if (state && state.isPageNavigation) {
                    // This was a page navigation - so navigate through frame.
                    if (NativeScriptDebug.isLogEnabled()) {
                        NativeScriptDebug.routerLog('NSLocationStrategy.back() while not navigating back but top' + ' state is page - will call frame.goBack()');
                    }
                    if (!outlet) {
                        var topmostFrame = this.frameService.getFrame();
                        this.currentOutlet = this.getOutletByFrame(topmostFrame) || this.currentOutlet;
                    }
                    var frameToBack = this.currentOutlet.getFrameToBack();
                    if (frameToBack) {
                        frameToBack.goBack();
                    }
                }
                else {
                    // Nested navigation - just pop the state
                    if (NativeScriptDebug.isLogEnabled()) {
                        NativeScriptDebug.routerLog('NSLocationStrategy.back() while not navigating back but top' + ' state is not page - just pop');
                    }
                    this.callPopState(this.currentOutlet.states.pop(), true);
                }
            }
        };
        NSLocationStrategy.prototype.canGoBack = function (outlet) {
            outlet = outlet || this.currentOutlet;
            return outlet.states.length > 1;
        };
        NSLocationStrategy.prototype.onPopState = function (fn) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('NSLocationStrategy.onPopState');
            }
            this.popStateCallbacks.push(fn);
        };
        NSLocationStrategy.prototype.getBaseHref = function () {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('NSLocationStrategy.getBaseHref()');
            }
            return '';
        };
        NSLocationStrategy.prototype.callPopState = function (state, pop, outlet) {
            var e_1, _a;
            if (pop === void 0) { pop = true; }
            outlet = outlet || this.currentOutlet;
            var urlSerializer = new i1.DefaultUrlSerializer();
            var changedOutlet = this.getSegmentGroupByOutlet(outlet);
            if (state && changedOutlet) {
                this.updateSegmentGroup(this.currentUrlTree.root, changedOutlet, state.segmentGroup);
            }
            else if (changedOutlet) {
                // when closing modal view there are scenarios (e.g. root viewContainerRef) when we need
                // to clean up the named page router outlet to make sure we will open the modal properly again if needed.
                this.updateSegmentGroup(this.currentUrlTree.root, changedOutlet, null);
            }
            var url = urlSerializer.serialize(this.currentUrlTree);
            var change = { url: url, pop: pop };
            try {
                for (var _b = __values(this.popStateCallbacks), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var fn = _c.value;
                    fn(change);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        NSLocationStrategy.prototype.toString = function () {
            var result = [];
            this.outlets.forEach(function (outlet) {
                var outletStates = outlet.states;
                var outletLog = outletStates
                    // tslint:disable-next-line:max-line-length
                    .map(function (v, i) { return outlet.outletKeys + "." + i + ".[" + (v.isPageNavigation ? 'PAGE' : 'INTERNAL') + "].[" + (outlet.modalNavigationDepth ? 'MODAL' : 'BASE') + "] \"" + v.segmentGroup.toString() + "\""; })
                    .reverse();
                result = result.concat(outletLog);
            });
            return result.join('\n');
        };
        // Methods for syncing with page navigation in PageRouterOutlet
        NSLocationStrategy.prototype._beginBackPageNavigation = function (frame) {
            var outlet = this.getOutletByFrame(frame);
            if (!outlet || outlet.isPageNavigationBack) {
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.routerError('Attempted to call startGoBack while going back.');
                }
                return;
            }
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('NSLocationStrategy.startGoBack()');
            }
            outlet.isPageNavigationBack = true;
            this.currentOutlet = outlet;
        };
        NSLocationStrategy.prototype._finishBackPageNavigation = function (frame) {
            var outlet = this.getOutletByFrame(frame);
            if (!outlet || !outlet.isPageNavigationBack) {
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.routerError('Attempted to call endGoBack while not going back.');
                }
                return;
            }
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('NSLocationStrategy.finishBackPageNavigation()');
            }
            outlet.isPageNavigationBack = false;
        };
        NSLocationStrategy.prototype._beginModalNavigation = function (frame) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('NSLocationStrategy._beginModalNavigation()');
            }
            this.currentOutlet = this.getOutletByFrame(frame) || this.currentOutlet;
            // It is possible to have frame, but not corresponding Outlet, if
            // showing modal dialog on app.component.ts ngOnInit() e.g. In that case
            // the modal is treated as none modal navigation.
            if (this.currentOutlet) {
                this.currentOutlet.showingModal = true;
                this._modalNavigationDepth++;
            }
        };
        NSLocationStrategy.prototype._closeModalNavigation = function () {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('NSLocationStrategy.closeModalNavigation()');
            }
            var isShowingModal = this._modalNavigationDepth > 0;
            if (isShowingModal) {
                this._modalNavigationDepth--;
            }
            // currentOutlet should be the one that corresponds to the topmost frame
            var topmostOutlet = this.getOutletByFrame(this.frameService.getFrame());
            var outlet = this.findOutletByModal(this._modalNavigationDepth, isShowingModal) || topmostOutlet;
            if (outlet) {
                this.currentOutlet = outlet;
                this.currentOutlet.showingModal = false;
                this.callPopState(this.currentOutlet.peekState(), false);
            }
        };
        NSLocationStrategy.prototype._beginPageNavigation = function (frame) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('NSLocationStrategy._beginPageNavigation()');
            }
            this.currentOutlet = this.getOutletByFrame(frame) || this.currentOutlet;
            var lastState = this.currentOutlet.peekState();
            if (lastState) {
                lastState.isPageNavigation = true;
            }
            var navOptions = this._currentNavigationOptions || defaultNavOptions;
            if (navOptions.clearHistory) {
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.routerLog('NSLocationStrategy._beginPageNavigation clearing states history');
                }
                this.currentOutlet.states = [lastState];
            }
            this._currentNavigationOptions = undefined;
            return navOptions;
        };
        NSLocationStrategy.prototype._setNavigationOptions = function (options) {
            this._currentNavigationOptions = {
                clearHistory: isPresent(options.clearHistory) ? options.clearHistory : false,
                animated: isPresent(options.animated) ? options.animated : true,
                transition: options.transition,
            };
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('NSLocationStrategy._setNavigationOptions(' + (JSON.stringify(this._currentNavigationOptions) + ")"));
            }
        };
        NSLocationStrategy.prototype._getOutlets = function () {
            return this.outlets;
        };
        NSLocationStrategy.prototype.updateOutletFrame = function (outlet, frame, isEmptyOutletFrame) {
            var lastState = outlet.peekState();
            if (lastState && !lastState.frame && !isEmptyOutletFrame) {
                lastState.frame = frame;
            }
            if (!outlet.containsFrame(frame)) {
                outlet.frames.push(frame);
            }
            this.currentOutlet = outlet;
        };
        NSLocationStrategy.prototype.clearOutlet = function (frame) {
            var _this = this;
            this.outlets = this.outlets.filter(function (currentOutlet) {
                var isEqualToCurrent;
                if (_this.currentOutlet) {
                    isEqualToCurrent = currentOutlet.pathByOutlets === _this.currentOutlet.pathByOutlets;
                }
                // Remove outlet from the url tree.
                if (currentOutlet.containsFrame(frame) && !isEqualToCurrent) {
                    _this.callPopState(null, true, currentOutlet);
                }
                // Skip frames filtering since currentOutlet is <router-outlet> when no frames available.
                if (currentOutlet.frames.length && !currentOutlet.isNSEmptyOutlet) {
                    currentOutlet.frames = currentOutlet.frames.filter(function (currentFrame) { return currentFrame !== frame; });
                    return currentOutlet.frames.length;
                }
                return !currentOutlet.containsFrame(frame);
            });
        };
        NSLocationStrategy.prototype.getSegmentGroupFullPath = function (segmentGroup) {
            var fullPath = '';
            while (segmentGroup) {
                var url = segmentGroup.toString();
                if (fullPath) {
                    fullPath = (url ? url + '/' : '') + fullPath;
                }
                else {
                    fullPath = url;
                }
                segmentGroup = segmentGroup.parent;
            }
            return fullPath;
        };
        NSLocationStrategy.prototype.getRouteFullPath = function (currentRoute) {
            var outletName = currentRoute.outlet;
            var fullPath;
            currentRoute = currentRoute.parent;
            while (currentRoute) {
                var urls = currentRoute.url.value || currentRoute.url;
                var url = urls;
                if (Array.isArray(urls)) {
                    url = url.join('/');
                }
                fullPath = fullPath ? (url ? url + '/' : url) + fullPath : url;
                currentRoute = currentRoute.parent;
            }
            return fullPath ? fullPath + '-' + outletName : outletName;
        };
        NSLocationStrategy.prototype.getPathByOutlets = function (urlSegmentGroup) {
            if (!urlSegmentGroup) {
                return '';
            }
            var pathToOutlet;
            var lastPath = urlSegmentGroup.outlet || 'primary';
            var parent = urlSegmentGroup.parent;
            while (parent && urlSegmentGroup.root !== parent) {
                if (parent && parent.outlet !== lastPath) {
                    if (lastPath === 'primary') {
                        lastPath = parent.outlet;
                    }
                    else {
                        lastPath = parent.outlet;
                        pathToOutlet = lastPath + '-' + (pathToOutlet || urlSegmentGroup.outlet);
                    }
                }
                parent = parent.parent;
            }
            return pathToOutlet || lastPath;
        };
        NSLocationStrategy.prototype.findOutlet = function (outletKey, activatedRouteSnapshot) {
            var _this = this;
            var outlet = this.outlets.find(function (currentOutlet) {
                var equalModalDepth = currentOutlet.modalNavigationDepth === _this._modalNavigationDepth;
                return equalModalDepth && currentOutlet.outletKeys.indexOf(outletKey) > -1;
            });
            // No Outlet with the given outletKey could happen when using nested unnamed p-r-o
            // primary -> primary -> prymary
            if (!outlet && activatedRouteSnapshot) {
                var pathByOutlets_1 = this.getPathByOutlets(activatedRouteSnapshot);
                outlet = this.outlets.find(function (currentOutlet) {
                    var equalModalDepth = currentOutlet.modalNavigationDepth === _this._modalNavigationDepth;
                    return equalModalDepth && currentOutlet.pathByOutlets === pathByOutlets_1;
                });
            }
            return outlet;
        };
        NSLocationStrategy.prototype.findOutletByModal = function (modalNavigation, isShowingModal) {
            return this.outlets.find(function (outlet) {
                var equalModalDepth = outlet.modalNavigationDepth === modalNavigation;
                return isShowingModal ? equalModalDepth && outlet.showingModal : equalModalDepth;
            });
        };
        NSLocationStrategy.prototype.getOutletByFrame = function (frame) {
            var outlet;
            for (var index = 0; index < this.outlets.length; index++) {
                var currentOutlet = this.outlets[index];
                if (currentOutlet.containsFrame(frame)) {
                    outlet = currentOutlet;
                    break;
                }
            }
            return outlet;
        };
        NSLocationStrategy.prototype.updateStates = function (outlet, currentSegmentGroup, queryParams) {
            var isNewPage = outlet.states.length === 0;
            var lastState = outlet.states[outlet.states.length - 1];
            var equalStateUrls = outlet.containsTopState(currentSegmentGroup.toString());
            var locationState = {
                segmentGroup: currentSegmentGroup,
                isRootSegmentGroup: false,
                isPageNavigation: isNewPage,
                queryParams: Object.assign({}, queryParams),
            };
            if (!lastState || !equalStateUrls) {
                outlet.states.push(locationState);
                // Update last state segmentGroup of parent Outlet.
                if (this._modalNavigationDepth === 0 && !outlet.showingModal) {
                    this.updateParentsStates(outlet, currentSegmentGroup.parent);
                }
                return true;
            }
            return false;
        };
        NSLocationStrategy.prototype.updateParentsStates = function (outlet, newSegmentGroup) {
            var parentOutlet = outlet.parent;
            // Update parents lastState segmentGroups
            while (parentOutlet && newSegmentGroup) {
                var state = parentOutlet.peekState();
                if (state) {
                    state.segmentGroup = newSegmentGroup;
                    newSegmentGroup = newSegmentGroup.parent;
                    parentOutlet = parentOutlet.parent;
                }
            }
        };
        // tslint:disable-next-line:max-line-length
        NSLocationStrategy.prototype.createOutlet = function (outletKey, path, segmentGroup, parent, modalNavigation, queryParams) {
            if (queryParams === void 0) { queryParams = {}; }
            var pathByOutlets = this.getPathByOutlets(segmentGroup);
            var newOutlet = new Outlet(outletKey, path, pathByOutlets, modalNavigation);
            var locationState = {
                segmentGroup: segmentGroup,
                isRootSegmentGroup: false,
                isPageNavigation: true,
                queryParams: Object.assign({}, queryParams),
            };
            newOutlet.states = [locationState];
            newOutlet.parent = parent;
            this.outlets.push(newOutlet);
            // Update last state segmentGroup of parent Outlet.
            if (this._modalNavigationDepth === 0 && !newOutlet.showingModal) {
                this.updateParentsStates(newOutlet, segmentGroup.parent);
            }
            return newOutlet;
        };
        NSLocationStrategy.prototype.getSegmentGroupByOutlet = function (outlet) {
            var pathList = outlet.pathByOutlets.split('-');
            var segmentGroup = this.currentUrlTree.root;
            var pathToOutlet;
            for (var index = 0; index < pathList.length; index++) {
                var currentPath = pathList[index];
                var childrenCount = Object.keys(segmentGroup.children).length;
                if (childrenCount && segmentGroup.children[currentPath]) {
                    var url = segmentGroup.toString();
                    pathToOutlet = pathToOutlet ? pathToOutlet + '/' + url : url;
                    segmentGroup = segmentGroup.children[currentPath];
                }
                else {
                    // If no child outlet found with the given name - forget about all previously found outlets.
                    // example: seaching for 'primary-second-primary' shouldn't return 'primary-second'
                    // if no 'primary' child available on 'second'.
                    segmentGroup = null;
                    break;
                }
            }
            // Paths should also match since there could be another Outlet
            // with the same pathByOutlets but different url path.
            if (segmentGroup && outlet.path && pathToOutlet && outlet.path !== pathToOutlet) {
                segmentGroup = null;
            }
            return segmentGroup;
        };
        // Traversal and replacement of segmentGroup.
        NSLocationStrategy.prototype.updateSegmentGroup = function (rootNode, oldSegmentGroup, newSegmentGroup) {
            var queue = [];
            var currentTree = rootNode;
            while (currentTree) {
                Object.keys(currentTree.children).forEach(function (outletName) {
                    if (currentTree.children[outletName] === oldSegmentGroup) {
                        if (newSegmentGroup) {
                            currentTree.children[outletName] = newSegmentGroup;
                        }
                        else {
                            delete currentTree.children[outletName];
                        }
                    }
                    queue.push(currentTree.children[outletName]);
                });
                currentTree = queue.shift();
            }
        };
        NSLocationStrategy.prototype.upsertModalOutlet = function (parentOutlet, segmentedGroup, queryParams) {
            var currentModalOutlet = this.findOutletByModal(this._modalNavigationDepth);
            // We want to treat every p-r-o as a standalone Outlet.
            if (!currentModalOutlet) {
                if (this._modalNavigationDepth > 1) {
                    // The parent of the current Outlet should be the previous opened modal (if any).
                    parentOutlet = this.findOutletByModal(this._modalNavigationDepth - 1);
                }
                // No currentModalOutlet available when opening 'primary' p-r-o.
                var outletName = 'primary';
                var outletPath = parentOutlet.peekState().segmentGroup.toString();
                var outletKey = this.getOutletKey(outletPath, outletName);
                // tslint:disable-next-line:max-line-length
                currentModalOutlet = this.createOutlet(outletKey, outletPath, segmentedGroup, parentOutlet, this._modalNavigationDepth, queryParams);
                this.currentOutlet = currentModalOutlet;
            }
            else if (this.updateStates(currentModalOutlet, segmentedGroup, queryParams)) {
                this.currentOutlet = currentModalOutlet; // If states updated
            }
        };
        NSLocationStrategy.prototype.getOutletKey = function (path, outletName) {
            return path ? path + '-' + outletName : outletName;
        };
        NSLocationStrategy.prototype.ngOnDestroy = function () {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('NSLocationStrategy.ngOnDestroy()');
            }
            this.outlets = [];
            this.currentOutlet = null;
        };
        return NSLocationStrategy;
    }(common.LocationStrategy));
    NSLocationStrategy.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function NSLocationStrategy_Factory() { return new NSLocationStrategy(i0__namespace.ɵɵinject(FrameService), i0__namespace.ɵɵinject(START_PATH, 8)); }, token: NSLocationStrategy, providedIn: "root" });
    NSLocationStrategy.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    NSLocationStrategy.ctorParameters = function () { return [
        { type: FrameService },
        { type: String, decorators: [{ type: i0.Inject, args: [START_PATH,] }, { type: i0.Optional }] }
    ]; };

    var ModalDialogParams = /** @class */ (function () {
        function ModalDialogParams(context, closeCallback) {
            if (context === void 0) { context = {}; }
            this.context = context;
            this.closeCallback = closeCallback;
        }
        return ModalDialogParams;
    }());
    var ModalDialogService = /** @class */ (function () {
        function ModalDialogService(location, zone, appRef, defaultInjector) {
            this.location = location;
            this.zone = zone;
            this.appRef = appRef;
            this.defaultInjector = defaultInjector;
        }
        ModalDialogService.prototype.showModal = function (type, options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            // if (!options.viewContainerRef) {
            //   throw new Error('No viewContainerRef: ' + 'Make sure you pass viewContainerRef in ModalDialogOptions.');
            // }
            var _a, _b, _c, _d;
            var parentView = ((_a = options.viewContainerRef) === null || _a === void 0 ? void 0 : _a.element.nativeElement) || core.Application.getRootView();
            if (options.target) {
                parentView = options.target;
            }
            if ((parentView instanceof AppHostView || parentView instanceof AppHostAsyncView) && parentView.ngAppRoot) {
                parentView = parentView.ngAppRoot;
            }
            // _ngDialogRoot is the first child of the previously detached proxy.
            // It should have 'viewController' (iOS) or '_dialogFragment' (Android) available for
            // presenting future modal views.
            if (parentView._ngDialogRoot) {
                parentView = parentView._ngDialogRoot;
            }
            // resolve from particular module (moduleRef)
            // or from same module as parentView (viewContainerRef)
            var componentInjector = ((_b = options.moduleRef) === null || _b === void 0 ? void 0 : _b.injector) || ((_c = options.viewContainerRef) === null || _c === void 0 ? void 0 : _c.injector) || this.defaultInjector;
            var resolver = componentInjector.get(i0.ComponentFactoryResolver);
            var frame = parentView;
            if (!(parentView instanceof core.Frame)) {
                frame = (parentView.page && parentView.page.frame) || core.Frame.topmost();
            }
            (_d = this.location) === null || _d === void 0 ? void 0 : _d._beginModalNavigation(frame);
            return new Promise(function (resolve, reject) {
                setTimeout(function () {
                    try {
                        _this._showDialog(Object.assign(Object.assign({}, options), { containerRef: options.viewContainerRef, injector: componentInjector, context: options.context, doneCallback: resolve, parentView: parentView, resolver: resolver, type: type }));
                    }
                    catch (err) {
                        reject(err);
                    }
                }, 10);
            });
        };
        ModalDialogService.prototype._showDialog = function (options) {
            var _this = this;
            var componentViewRef;
            var detachedLoaderRef;
            var portalOutlet;
            var closeCallback = once(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                options.doneCallback.apply(undefined, args);
                if (componentViewRef) {
                    componentViewRef.firstNativeLikeView.closeModal();
                    _this.location._closeModalNavigation();
                    if (detachedLoaderRef || portalOutlet) {
                        _this.zone.run(function () {
                            portalOutlet === null || portalOutlet === void 0 ? void 0 : portalOutlet.dispose();
                            detachedLoaderRef === null || detachedLoaderRef === void 0 ? void 0 : detachedLoaderRef.instance.detectChanges();
                            detachedLoaderRef === null || detachedLoaderRef === void 0 ? void 0 : detachedLoaderRef.destroy();
                        });
                    }
                }
            });
            var modalParams = new ModalDialogParams(options.context, closeCallback);
            var childInjector = i0.Injector.create({
                providers: [{ provide: ModalDialogParams, useValue: modalParams }],
                parent: options.injector,
            });
            this.zone.run(function () {
                // if we ever support templates in the old API
                // if(options.templateRef) {
                //     const detachedFactory = options.resolver.resolveComponentFactory(DetachedLoader);
                //     if(options.attachToContainerRef) {
                //         detachedLoaderRef = options.attachToContainerRef.createComponent(detachedFactory, 0, childInjector, null);
                //     } else {
                //         detachedLoaderRef = detachedFactory.create(childInjector); // this DetachedLoader is **completely** detached
                //         this.appRef.attachView(detachedLoaderRef.hostView); // we attach it to the applicationRef, so it becomes a "root" view in angular's hierarchy
                //     }
                //     detachedLoaderRef.changeDetectorRef.detectChanges(); // force a change detection
                //     detachedLoaderRef.instance.createTemplatePortal(options.templateRef);
                // }
                var targetView = new core.ContentView();
                var portal = new ComponentPortal(options.type);
                portalOutlet = new NativeScriptDomPortalOutlet(targetView, options.resolver, _this.appRef, childInjector);
                var componentRef = portalOutlet.attach(portal);
                i0.ɵmarkDirty(componentRef.instance);
                componentViewRef = new NgViewRef(componentRef);
                if (componentViewRef !== componentRef.location.nativeElement) {
                    componentRef.location.nativeElement._ngDialogRoot = componentViewRef.firstNativeLikeView;
                }
                // if we don't detach the view from its parent, ios gets mad
                componentViewRef.detachNativeLikeView();
                options.parentView.showModal(componentViewRef.firstNativeLikeView, Object.assign(Object.assign({}, options), { closeCallback: closeCallback }));
            });
        };
        return ModalDialogService;
    }());
    ModalDialogService.decorators = [
        { type: i0.Injectable }
    ];
    ModalDialogService.ctorParameters = function () { return [
        { type: NSLocationStrategy },
        { type: i0.NgZone },
        { type: i0.ApplicationRef },
        { type: i0.Injector }
    ]; };

    /**
     * This decorator delays a potentially unsafe event (like loaded/unloaded that will sometimes be called before ngOnInit) to be handled safely by ensuring it's called after a lifecycle hook.
     * @param runAfterEvent event/function call to wait until the event can be fired ('ngOnInit', 'ngAfterViewInit', ...)
     * @param options Optional event handling params
     * @returns decorator
     */
    function NativeScriptNgSafeEvent(runAfterEvent, options) {
        if (options === void 0) { options = {}; }
        var event = runAfterEvent;
        return function (target, propertyKey, descriptor) {
            function getNgSafe() {
                return target['__ng_safe__'];
            }
            if (!target['__ng_safe__']) {
                var defaultNgSafe = {
                    events: {},
                    runBefore: {},
                };
                target['__ng_safe__'] = defaultNgSafe;
            }
            if (!getNgSafe().events[event]) {
                getNgSafe().events[event] = {
                    done: false,
                    buffer: [],
                    originalDelegate: target[event],
                };
                target[event] = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    try {
                        if (getNgSafe().events[event].originalDelegate) {
                            return getNgSafe().events[event].originalDelegate.apply(this, args);
                        }
                    }
                    finally {
                        getNgSafe().events[event].done = true;
                        getNgSafe().events[event].buffer.forEach(function (fn) { return fn.fn(); });
                        getNgSafe().events[event].buffer = [];
                    }
                };
            }
            if (options.alwaysRunBefore) {
                getNgSafe().runBefore[propertyKey] = target[options.alwaysRunBefore];
                target["" + options.alwaysRunBefore] = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    getNgSafe()
                        .events[event].buffer.filter(function (v) { return v.key === propertyKey; })
                        .forEach(function (fn) { return fn.fn(); });
                    getNgSafe().events[event].buffer = getNgSafe().events[event].buffer.filter(function (v) { return v.key !== propertyKey; });
                    getNgSafe().runBefore[propertyKey];
                    if (getNgSafe().runBefore[propertyKey]) {
                        return getNgSafe().runBefore[propertyKey].apply(this, args);
                    }
                };
            }
            var oldFn = descriptor.value;
            descriptor.value = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (getNgSafe().events[event].done) {
                    return oldFn.apply(this, args);
                }
                var shouldPush = true;
                if (options.onlyFirst || options.onlyLast) {
                    for (var i = 0; i < getNgSafe().events[event].buffer.length; i++) {
                        if (getNgSafe().events[event].buffer[i].key === propertyKey) {
                            if (options.onlyFirst) {
                                shouldPush = false;
                                break;
                            }
                            if (options.onlyLast) {
                                getNgSafe().events[event].buffer.splice(i, 1);
                                break;
                            }
                        }
                    }
                }
                if (shouldPush) {
                    getNgSafe().events[event].buffer.push({
                        key: propertyKey,
                        fn: oldFn.bind(this, args),
                    });
                }
            };
        };
    }

    var TabViewDirective = /** @class */ (function () {
        function TabViewDirective(element) {
            this.tabView = element.nativeElement;
        }
        Object.defineProperty(TabViewDirective.prototype, "selectedIndex", {
            get: function () {
                return this._selectedIndex;
            },
            set: function (value) {
                this._selectedIndex = value;
                if (this.viewInitialized) {
                    this.tabView.selectedIndex = this._selectedIndex;
                }
            },
            enumerable: false,
            configurable: true
        });
        TabViewDirective.prototype.ngAfterViewInit = function () {
            this.viewInitialized = true;
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.rendererLog('this._selectedIndex: ' + this._selectedIndex);
            }
            if (!isBlank(this._selectedIndex)) {
                this.tabView.selectedIndex = this._selectedIndex;
            }
        };
        return TabViewDirective;
    }());
    TabViewDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'TabView', // eslint-disable-line @angular-eslint/directive-selector
                },] }
    ];
    TabViewDirective.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    TabViewDirective.propDecorators = {
        selectedIndex: [{ type: i0.Input }]
    };
    var TabViewItemDirective = /** @class */ (function () {
        function TabViewItemDirective(owner, templateRef, viewContainer) {
            this.owner = owner;
            this.templateRef = templateRef;
            this.viewContainer = viewContainer;
        }
        Object.defineProperty(TabViewItemDirective.prototype, "config", {
            get: function () {
                // tslint:disable-line:no-input-rename
                return this._config || {};
            },
            set: function (config) {
                if (!this._config || this._config.iconSource !== config.iconSource || this._config.title !== config.title || this._config.textTransform !== config.textTransform) {
                    this._config = config;
                    this.applyConfig();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TabViewItemDirective.prototype, "title", {
            get: function () {
                return this.config.title;
            },
            set: function (title) {
                this.config = Object.assign(this.config, { title: title });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TabViewItemDirective.prototype, "iconSource", {
            get: function () {
                return this.config.iconSource;
            },
            set: function (iconSource) {
                this.config = Object.assign(this.config, { iconSource: iconSource });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TabViewItemDirective.prototype, "textTransform", {
            get: function () {
                return this.config.textTransform;
            },
            set: function (textTransform) {
                this.config = Object.assign(this.config, { textTransform: textTransform });
            },
            enumerable: false,
            configurable: true
        });
        TabViewItemDirective.prototype.ensureItem = function () {
            if (!this.item) {
                this.item = new core.TabViewItem();
            }
        };
        TabViewItemDirective.prototype.applyConfig = function () {
            this.ensureItem();
            if (this.config.title) {
                this.item.title = this.config.title;
            }
            if (this.config.iconSource) {
                this.item.iconSource = this.config.iconSource;
            }
            //  TabViewItem textTransform has a default value for Android that kick in
            // only if no value (even a null value) is set.
            if (this.config.textTransform) {
                this.item.textTransform = this.config.textTransform;
            }
        };
        TabViewItemDirective.prototype.ngOnInit = function () {
            this.applyConfig();
            var viewRef = this.viewContainer.createEmbeddedView(this.templateRef);
            // Filter out text nodes and comments
            var realViews = viewRef.rootNodes.filter(function (node) { return !(node instanceof InvisibleNode); });
            if (realViews.length > 0) {
                this.item.view = realViews[0];
                var newItems = (this.owner.tabView.items || []).concat([this.item]);
                this.owner.tabView.items = newItems;
            }
        };
        return TabViewItemDirective;
    }());
    TabViewItemDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[tabItem]', // eslint-disable-line @angular-eslint/directive-selector
                },] }
    ];
    TabViewItemDirective.ctorParameters = function () { return [
        { type: TabViewDirective },
        { type: i0.TemplateRef },
        { type: i0.ViewContainerRef }
    ]; };
    TabViewItemDirective.propDecorators = {
        config: [{ type: i0.Input, args: ['tabItem',] }],
        title: [{ type: i0.Input }],
        iconSource: [{ type: i0.Input }],
        textTransform: [{ type: i0.Input }]
    };

    /* eslint-disable @angular-eslint/component-selector */
    var AndroidFilterComponent = /** @class */ (function () {
        function AndroidFilterComponent(device) {
            this.show = device.os === core.platformNames.android;
        }
        return AndroidFilterComponent;
    }());
    AndroidFilterComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'android',
                    template: "<ng-content *ngIf=\"show\"></ng-content>"
                },] }
    ];
    AndroidFilterComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [DEVICE,] }] }
    ]; };

    /* eslint-disable @angular-eslint/component-selector */
    var IOSFilterComponent = /** @class */ (function () {
        function IOSFilterComponent(device) {
            this.show = device.os === core.platformNames.ios;
        }
        return IOSFilterComponent;
    }());
    IOSFilterComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ios',
                    template: "<ng-content *ngIf=\"show\"></ng-content>"
                },] }
    ];
    IOSFilterComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [DEVICE,] }] }
    ]; };

    var CDK_COMPONENTS = [ActionBarComponent, ActionBarScope, ActionItemDirective, NavigationButtonDirective, ListViewComponent, TemplateKeyDirective, TabViewDirective, TabViewItemDirective, AndroidFilterComponent, IOSFilterComponent];
    registerNativeScriptViewComponents();
    var NativeScriptCommonModule = /** @class */ (function () {
        function NativeScriptCommonModule() {
        }
        return NativeScriptCommonModule;
    }());
    NativeScriptCommonModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [common.CommonModule, FramePageModule],
                    declarations: __spreadArray([], __read(CDK_COMPONENTS)),
                    exports: __spreadArray([common.CommonModule, FramePageModule], __read(CDK_COMPONENTS)),
                    providers: [ModalDialogService],
                    schemas: [i0.NO_ERRORS_SCHEMA],
                },] }
    ];

    function generateFallbackRootView(parentRootView) {
        if (parentRootView) {
            return parentRootView;
        }
        return new AppHostView(new core.Color('white'));
    }
    function errorHandler() {
        return new i0.ErrorHandler();
    }
    function generateRandomId() {
        return "" + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }
    var ɵ0$3 = core.Device;
    var NATIVESCRIPT_MODULE_STATIC_PROVIDERS = [
        { provide: APP_ROOT_VIEW, useFactory: generateFallbackRootView, deps: [[new i0.Optional(), new i0.SkipSelf(), APP_ROOT_VIEW]] },
        { provide: i0.ɵINJECTOR_SCOPE, useValue: 'root' },
        { provide: i0.ErrorHandler, useFactory: errorHandler, deps: [] },
        { provide: ViewUtil, useClass: ViewUtil, deps: [NAMESPACE_FILTERS, [new i0.Optional(), ENABLE_REUSABE_VIEWS]] },
        {
            provide: NativeScriptRendererFactory,
            useClass: NativeScriptRendererFactory,
            deps: [APP_ROOT_VIEW, NAMESPACE_FILTERS, NATIVESCRIPT_ROOT_MODULE_ID, [new i0.Optional(), ENABLE_REUSABE_VIEWS]],
        },
        { provide: NATIVESCRIPT_ROOT_MODULE_ID, useFactory: generateRandomId },
        { provide: i0.RendererFactory2, useExisting: NativeScriptRendererFactory },
        { provide: NAMESPACE_FILTERS, useClass: PlatformNamespaceFilter, deps: [DEVICE], multi: true },
        { provide: DEVICE, useValue: ɵ0$3 },
        { provide: common.XhrFactory, useClass: NativescriptXhrFactory, deps: [] },
    ];
    var NATIVESCRIPT_MODULE_PROVIDERS = [{ provide: common.ViewportScroller, useClass: common.ɵNullViewportScroller }];
    var NativeScriptModule = /** @class */ (function () {
        function NativeScriptModule(parentModule) {
            if (parentModule) {
                throw new Error("NativeScriptModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.");
            }
        }
        return NativeScriptModule;
    }());
    NativeScriptModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [i0.ApplicationModule, NativeScriptCommonModule],
                    declarations: [DetachedLoader],
                    providers: __spreadArray(__spreadArray([], __read(NATIVESCRIPT_MODULE_STATIC_PROVIDERS)), __read(NATIVESCRIPT_MODULE_PROVIDERS)),
                    exports: [i0.ApplicationModule, DetachedLoader, NativeScriptCommonModule],
                    schemas: [i0.NO_ERRORS_SCHEMA],
                },] }
    ];
    NativeScriptModule.ctorParameters = function () { return [
        { type: NativeScriptModule, decorators: [{ type: i0.Optional }, { type: i0.SkipSelf }, { type: i0.Inject, args: [NativeScriptModule,] }] }
    ]; };

    var RootViewProxy = /** @class */ (function (_super) {
        __extends(RootViewProxy, _super);
        function RootViewProxy(parentRootLayout) {
            var _this = _super.call(this) || this;
            _this.parentRootLayout = parentRootLayout;
            return _this;
        }
        RootViewProxy.prototype._addView = function (view, atIndex) {
            _super.prototype._addView.call(this, view, atIndex);
            if (this.parentRootLayout.getChildIndex(this) < 0) {
                this.parentRootLayout.insertChild(this, 0);
            }
        };
        RootViewProxy.prototype._removeView = function (view) {
            _super.prototype._removeView.call(this, view);
            this.parentRootLayout.removeChild(this);
        };
        return RootViewProxy;
    }(core.ContentView));
    /**
     * This generates a RootLayout and returns a RootViewProxy.
     * Setting RootViewProxy.content will add the view to the bottom of the RootLayout
     * Setting RootViewProxy.content = null will remove the view from the RootLayout
     * @returns RootViewProxy that will insert content into the start of the RootLayout
     */
    function generateRootLayoutAndProxy() {
        var rootView = core.Application.getRootView();
        if (!rootView || !(rootView instanceof core.RootLayout)) {
            rootView = new core.RootLayout();
            core.Application.resetRootView({ create: function () { return rootView; } });
        }
        var viewProxy = new RootViewProxy(rootView);
        // (rootView as RootLayout).insertChild(viewProxy, 0);
        return viewProxy;
    }
    var RootCompositeModule = /** @class */ (function () {
        function RootCompositeModule() {
        }
        return RootCompositeModule;
    }());
    RootCompositeModule.decorators = [
        { type: i0.NgModule, args: [{
                    providers: [
                        { provide: DISABLE_ROOT_VIEW_HANDLING, useValue: true },
                        { provide: APP_ROOT_VIEW, useFactory: generateRootLayoutAndProxy },
                    ],
                },] }
    ];

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Configuration for opening a modal dialog with the MatDialog service.
     */
    var NativeDialogConfig = /** @class */ (function () {
        function NativeDialogConfig() {
            /** Whether the dialog has a backdrop. */
            this.hasBackdrop = true;
            /** Whether the user can use escape or clicking on the backdrop to close the modal. */
            this.disableClose = false;
            /** Data being injected into the child component. */
            this.data = null;
            /**
             * Whether the dialog should close when the user goes backwards/forwards in history.
             * Note that this usually doesn't include clicking on links (unless the user is using
             * the `HashLocationStrategy`).
             */
            this.closeOnNavigation = true;
            this.nativeOptions = {};
            // TODO(jelbourn): add configuration for lifecycle hooks, ARIA labelling.
        }
        return NativeDialogConfig;
    }());

    // Counter for unique dialog ids.
    var uniqueId = 0;
    var NativeDialogRef = /** @class */ (function () {
        function NativeDialogRef(_nativeModalRef, id) {
            var _this = this;
            if (id === void 0) { id = "native-dialog-" + uniqueId++; }
            this._nativeModalRef = _nativeModalRef;
            this.id = id;
            /** Subject for notifying the user that the dialog has finished opening. */
            this._afterOpened = new rxjs.Subject();
            /** Subject for notifying the user that the dialog has finished closing. */
            this._afterClosed = new rxjs.Subject();
            /** Subject for notifying the user that the dialog has started closing. */
            this._beforeClosed = new rxjs.Subject();
            /** Current state of the dialog. */
            this._state = 0 /* OPEN */;
            // Pass the id along to the container.
            _nativeModalRef._id = id;
            // Emit when opening animation completes
            _nativeModalRef.stateChanged
                .pipe(operators.filter(function (event) { return event.state === 'opened'; }), operators.take(1))
                .subscribe(function () {
                _this._afterOpened.next();
                _this._afterOpened.complete();
            });
            // Dispose overlay when closing animation is complete
            _nativeModalRef.stateChanged
                .pipe(operators.filter(function (event) { return event.state === 'closed'; }), operators.take(1))
                .subscribe(function () {
                clearTimeout(_this._closeFallbackTimeout);
                _this._finishDialogClose();
            });
            _nativeModalRef.onDismiss.subscribe(function () {
                _this._beforeClosed.next(_this._result);
                _this._beforeClosed.complete();
                _this._afterClosed.next(_this._result);
                _this._afterClosed.complete();
                _this.componentInstance = null;
                _nativeModalRef.dispose();
            });
        }
        /**
         * Close the dialog.
         * @param dialogResult Optional result to return to the dialog opener.
         */
        NativeDialogRef.prototype.close = function (dialogResult) {
            var _this = this;
            this._result = dialogResult;
            // Transition the backdrop in parallel to the dialog.
            this._nativeModalRef.stateChanged
                .pipe(operators.filter(function (event) { return event.state === 'closing'; }), operators.take(1))
                .subscribe(function (event) {
                _this._beforeClosed.next(dialogResult);
                _this._beforeClosed.complete();
                _this._nativeModalRef.dispose();
                // this._overlayRef.detachBackdrop();
                // The logic that disposes of the overlay depends on the exit animation completing, however
                // it isn't guaranteed if the parent view is destroyed while it's running. Add a fallback
                // timeout which will clean everything up if the animation hasn't fired within the specified
                // amount of time plus 100ms. We don't need to run this outside the NgZone, because for the
                // vast majority of cases the timeout will have been cleared before it has the chance to fire.
                _this._closeFallbackTimeout = setTimeout(function () { return _this._finishDialogClose(); }, 
                //event.totalTime + 100);
                100);
            });
            this._state = 1 /* CLOSING */;
            this._nativeModalRef._startExitAnimation();
        };
        /**
         * Gets an observable that is notified when the dialog is finished opening.
         */
        NativeDialogRef.prototype.afterOpened = function () {
            return this._afterOpened;
        };
        /**
         * Gets an observable that is notified when the dialog is finished closing.
         */
        NativeDialogRef.prototype.afterClosed = function () {
            return this._afterClosed;
        };
        /**
         * Gets an observable that is notified when the dialog has started closing.
         */
        NativeDialogRef.prototype.beforeClosed = function () {
            return this._beforeClosed;
        };
        /**
         * Gets an observable that emits when the overlay's backdrop has been clicked.
         */
        NativeDialogRef.prototype.backdropClick = function () {
            throw new Error('Method not implemented');
        };
        /** Add a CSS class or an array of classes to the overlay pane. */
        NativeDialogRef.prototype.addPanelClass = function (classes) {
            // this._overlayRef.addPanelClass(classes);
            return this;
        };
        /** Remove a CSS class or an array of classes from the overlay pane. */
        NativeDialogRef.prototype.removePanelClass = function (classes) {
            // this._overlayRef.removePanelClass(classes);
            return this;
        };
        /** Gets the current state of the dialog's lifecycle. */
        NativeDialogRef.prototype.getState = function () {
            return this._state;
        };
        /**
         * Finishes the dialog close by updating the state of the dialog
         * and disposing the overlay.
         */
        NativeDialogRef.prototype._finishDialogClose = function () {
            this._state = 2 /* CLOSED */;
            this._nativeModalRef.dispose();
        };
        return NativeDialogRef;
    }());

    var NativeModalRef = /** @class */ (function () {
        function NativeModalRef(_config, _injector, location) {
            var _this = this;
            var _a;
            this._config = _config;
            this._injector = _injector;
            this.location = location;
            this.stateChanged = new rxjs.Subject();
            this.onDismiss = new rxjs.Subject();
            var parentView = ((_a = this._config.viewContainerRef) === null || _a === void 0 ? void 0 : _a.element.nativeElement) || core.Application.getRootView();
            if ((parentView instanceof AppHostView || parentView instanceof AppHostAsyncView) && parentView.ngAppRoot) {
                parentView = parentView.ngAppRoot;
            }
            // _ngDialogRoot is the first child of the previously detached proxy.
            // It should have 'viewController' (iOS) or '_dialogFragment' (Android) available for
            // presenting future modal views.
            if (parentView._ngDialogRoot) {
                parentView = parentView._ngDialogRoot;
            }
            this.parentView = parentView;
            this._closeCallback = once(function () {
                var _a, _b, _c;
                _this.stateChanged.next({ state: 'closing' });
                (_a = _this.modalViewRef.firstNativeLikeView) === null || _a === void 0 ? void 0 : _a.closeModal();
                (_b = _this.location) === null || _b === void 0 ? void 0 : _b._closeModalNavigation();
                // this.detachedLoaderRef?.destroy();
                if ((_c = _this.modalViewRef) === null || _c === void 0 ? void 0 : _c.firstNativeLikeView.isLoaded) {
                    rxjs.fromEvent(_this.modalViewRef.firstNativeLikeView, 'unloaded')
                        .pipe(operators.take(1))
                        .subscribe(function () { return _this.stateChanged.next({ state: 'closed' }); });
                }
                else {
                    _this.stateChanged.next({ state: 'closed' });
                }
            });
        }
        NativeModalRef.prototype._generateDetachedContainer = function (vcRef) {
            var _a;
            var detachedFactory = (this._config.componentFactoryResolver || this._injector.get(i0.ComponentFactoryResolver)).resolveComponentFactory(DetachedLoader);
            if (vcRef) {
                this.detachedLoaderRef = vcRef.createComponent(detachedFactory);
            }
            else {
                this.detachedLoaderRef = detachedFactory.create(((_a = this._config.viewContainerRef) === null || _a === void 0 ? void 0 : _a.injector) || this._injector);
                this._injector.get(i0.ApplicationRef).attachView(this.detachedLoaderRef.hostView);
            }
            this.detachedLoaderRef.changeDetectorRef.detectChanges();
        };
        NativeModalRef.prototype.attachTemplatePortal = function (portal) {
            var _this = this;
            this.startModalNavigation();
            var vcRef = portal.viewContainerRef || this._config.viewContainerRef;
            this._generateDetachedContainer(vcRef);
            portal.viewContainerRef = this.detachedLoaderRef.instance.vc;
            var targetView = new core.ContentView();
            this.portalOutlet = new NativeScriptDomPortalOutlet(targetView, this._config.componentFactoryResolver || this._injector.get(i0.ComponentFactoryResolver), this._injector.get(i0.ApplicationRef), this._injector);
            var templateRef = this.portalOutlet.attach(portal);
            this.modalViewRef = new NgViewRef(templateRef);
            this.modalViewRef.firstNativeLikeView['__ng_modal_id__'] = this._id;
            // if we don't detach the view from its parent, ios gets mad
            this.modalViewRef.detachNativeLikeView();
            var userOptions = this._config.nativeOptions || {};
            this.parentView.showModal(this.modalViewRef.firstNativeLikeView, Object.assign(Object.assign({ context: null }, userOptions), { closeCallback: function () {
                    var _a;
                    (_a = _this.location) === null || _a === void 0 ? void 0 : _a._closeModalNavigation();
                    _this.onDismiss.next();
                    _this.onDismiss.complete();
                }, cancelable: !this._config.disableClose }));
            //   if (this.modalView !== templateRef.rootNodes[0]) {
            //     componentRef.location.nativeElement._ngDialogRoot = this.modalView;
            //   }
            return templateRef;
        };
        NativeModalRef.prototype.attachComponentPortal = function (portal) {
            var _this = this;
            this.startModalNavigation();
            var targetView = new core.ContentView();
            this.portalOutlet = new NativeScriptDomPortalOutlet(targetView, this._config.componentFactoryResolver || this._injector.get(i0.ComponentFactoryResolver), this._injector.get(i0.ApplicationRef), this._injector);
            var componentRef = this.portalOutlet.attach(portal);
            i0.ɵmarkDirty(componentRef.instance);
            this.modalViewRef = new NgViewRef(componentRef);
            if (this.modalViewRef.firstNativeLikeView !== this.modalViewRef.view) {
                this.modalViewRef.view._ngDialogRoot = this.modalViewRef.firstNativeLikeView;
            }
            this.modalViewRef.firstNativeLikeView['__ng_modal_id__'] = this._id;
            // if we don't detach the view from its parent, ios gets mad
            this.modalViewRef.detachNativeLikeView();
            var userOptions = this._config.nativeOptions || {};
            this.parentView.showModal(this.modalViewRef.firstNativeLikeView, Object.assign(Object.assign({ context: null }, userOptions), { closeCallback: function () {
                    var _a;
                    (_a = _this.location) === null || _a === void 0 ? void 0 : _a._closeModalNavigation();
                    _this.onDismiss.next();
                    _this.onDismiss.complete();
                }, cancelable: !this._config.disableClose }));
            return componentRef;
        };
        NativeModalRef.prototype._startExitAnimation = function () {
            this._closeCallback();
        };
        NativeModalRef.prototype.dispose = function () {
            this.portalOutlet.dispose();
        };
        NativeModalRef.prototype.startModalNavigation = function () {
            var _a, _b, _c;
            var frame = this.parentView instanceof core.Frame ? this.parentView : ((_b = (_a = this.parentView) === null || _a === void 0 ? void 0 : _a.page) === null || _b === void 0 ? void 0 : _b.frame) || core.Frame.topmost();
            (_c = this.location) === null || _c === void 0 ? void 0 : _c._beginModalNavigation(frame);
        };
        return NativeModalRef;
    }());
    NativeModalRef.ctorParameters = function () { return [
        { type: NativeDialogConfig },
        { type: i0.Injector },
        { type: NSLocationStrategy, decorators: [{ type: i0.Optional }] }
    ]; };

    /** Injection token that can be used to access the data that was passed in to a dialog. */
    var NATIVE_DIALOG_DATA = new i0.InjectionToken('NativeDialogData');
    /** Injection token that can be used to specify default dialog options. */
    var NATIVE_DIALOG_DEFAULT_OPTIONS = new i0.InjectionToken('native-dialog-default-options');
    /**
     * Base class for dialog services. The base dialog service allows
     * for arbitrary dialog refs and dialog container components.
     */
    var _NativeDialogBase = /** @class */ (function () {
        function _NativeDialogBase(_injector, _defaultOptions, _parentDialog, _dialogRefConstructor, _nativeModalType, _dialogDataToken, locationStrategy) {
            var _this = this;
            this._injector = _injector;
            this._defaultOptions = _defaultOptions;
            this._parentDialog = _parentDialog;
            this._dialogRefConstructor = _dialogRefConstructor;
            this._nativeModalType = _nativeModalType;
            this._dialogDataToken = _dialogDataToken;
            this.locationStrategy = locationStrategy;
            this._openDialogsAtThisLevel = [];
            this._afterAllClosedAtThisLevel = new rxjs.Subject();
            this._afterOpenedAtThisLevel = new rxjs.Subject();
            // TODO (jelbourn): tighten the typing right-hand side of this expression.
            /**
             * Stream that emits when all open dialog have finished closing.
             * Will emit on subscribe if there are no open dialogs to begin with.
             */
            this.afterAllClosed = rxjs.defer(function () { return (_this.openDialogs.length ? _this._getAfterAllClosed() : _this._getAfterAllClosed().pipe(operators.startWith(undefined))); });
        }
        Object.defineProperty(_NativeDialogBase.prototype, "openDialogs", {
            /** Keeps track of the currently-open dialogs. */
            get: function () {
                return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(_NativeDialogBase.prototype, "afterOpened", {
            /** Stream that emits when a dialog has been opened. */
            get: function () {
                return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel;
            },
            enumerable: false,
            configurable: true
        });
        _NativeDialogBase.prototype._getAfterAllClosed = function () {
            var parent = this._parentDialog;
            return parent ? parent._getAfterAllClosed() : this._afterAllClosedAtThisLevel;
        };
        _NativeDialogBase.prototype.open = function (componentOrTemplateRef, config) {
            var _this = this;
            config = _applyConfigDefaults(config, this._defaultOptions || new NativeDialogConfig());
            if (config.id && this.getDialogById(config.id) && (typeof ngDevMode === 'undefined' || ngDevMode)) {
                throw Error("Dialog with id \"" + config.id + "\" exists already. The dialog id must be unique.");
            }
            var dialogRef = this._attachDialogContent(componentOrTemplateRef, config);
            this.openDialogs.push(dialogRef);
            dialogRef.afterClosed().subscribe(function () { return _this._removeOpenDialog(dialogRef); });
            this.afterOpened.next(dialogRef);
            // Notify the dialog container that the content has been attached.
            // dialogContainer._initializeWithAttachedContent();
            return dialogRef;
        };
        /**
         * Closes all of the currently-open dialogs.
         */
        _NativeDialogBase.prototype.closeAll = function () {
            this._closeDialogs(this.openDialogs);
        };
        /**
         * Finds an open dialog by its id.
         * @param id ID to use when looking up the dialog.
         */
        _NativeDialogBase.prototype.getDialogById = function (id) {
            return this.openDialogs.find(function (dialog) { return dialog.id === id; });
        };
        _NativeDialogBase.prototype.ngOnDestroy = function () {
            // Only close the dialogs at this level on destroy
            // since the parent service may still be active.
            this._closeDialogs(this._openDialogsAtThisLevel);
            this._afterAllClosedAtThisLevel.complete();
            this._afterOpenedAtThisLevel.complete();
        };
        /**
         * Attaches the user-provided component to the already-created dialog container.
         * @param componentOrTemplateRef The type of component being loaded into the dialog,
         *     or a TemplateRef to instantiate as the content.
         * @param dialogContainer Reference to the wrapping dialog container.
         * @param overlayRef Reference to the overlay in which the dialog resides.
         * @param config The dialog configuration.
         * @returns A promise resolving to the MatDialogRef that should be returned to the user.
         */
        _NativeDialogBase.prototype._attachDialogContent = function (componentOrTemplateRef, config) {
            // Create a reference to the dialog we're creating in order to give the user a handle
            // to modify and close it.
            var nativeModalRef = new this._nativeModalType(config, this._injector, this.locationStrategy);
            var dialogRef = new this._dialogRefConstructor(nativeModalRef, config.id);
            if (componentOrTemplateRef instanceof i0.TemplateRef) {
                //     const detachedFactory = options.resolver.resolveComponentFactory(DetachedLoader);
                //     if(options.attachToContainerRef) {
                //         detachedLoaderRef = options.attachToContainerRef.createComponent(detachedFactory, 0, childInjector, null);
                //     } else {
                //         detachedLoaderRef = detachedFactory.create(childInjector); // this DetachedLoader is **completely** detached
                //         this.appRef.attachView(detachedLoaderRef.hostView); // we attach it to the applicationRef, so it becomes a "root" view in angular's hierarchy
                //     }
                //     detachedLoaderRef.changeDetectorRef.detectChanges(); // force a change detection
                //     detachedLoaderRef.instance.createTemplatePortal(options.templateRef);
                nativeModalRef.attachTemplatePortal(
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                new TemplatePortal(componentOrTemplateRef, null, { $implicit: config.data, dialogRef: dialogRef }));
            }
            else {
                var injector = this._createInjector(config, dialogRef);
                var contentRef = nativeModalRef.attachComponentPortal(new ComponentPortal(componentOrTemplateRef, config.viewContainerRef, injector));
                dialogRef.componentInstance = contentRef.instance;
            }
            return dialogRef;
        };
        /**
         * Creates a custom injector to be used inside the dialog. This allows a component loaded inside
         * of a dialog to close itself and, optionally, to return a value.
         * @param config Config object that is used to construct the dialog.
         * @param dialogRef Reference to the dialog.
         * @param dialogContainer Dialog container element that wraps all of the contents.
         * @returns The custom injector that can be used inside the dialog.
         */
        _NativeDialogBase.prototype._createInjector = function (config, dialogRef) {
            var userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
            // The dialog container should be provided as the dialog container and the dialog's
            // content are created out of the same `ViewContainerRef` and as such, are siblings
            // for injector purposes. To allow the hierarchy that is expected, the dialog
            // container is explicitly provided in the injector.
            var providers = [
                { provide: this._dialogDataToken, useValue: config.data },
                { provide: this._dialogRefConstructor, useValue: dialogRef },
            ];
            return i0.Injector.create({ parent: userInjector || this._injector, providers: providers });
        };
        /**
         * Removes a dialog from the array of open dialogs.
         * @param dialogRef Dialog to be removed.
         */
        _NativeDialogBase.prototype._removeOpenDialog = function (dialogRef) {
            var index = this.openDialogs.indexOf(dialogRef);
            if (index > -1) {
                this.openDialogs.splice(index, 1);
                // If all the dialogs were closed, remove/restore the `aria-hidden`
                // to a the siblings and emit to the `afterAllClosed` stream.
                if (!this.openDialogs.length) {
                    this._getAfterAllClosed().next();
                }
            }
        };
        /** Closes all of the dialogs in an array. */
        _NativeDialogBase.prototype._closeDialogs = function (dialogs) {
            var i = dialogs.length;
            while (i--) {
                // The `_openDialogs` property isn't updated after close until the rxjs subscription
                // runs on the next microtask, in addition to modifying the array as we're going
                // through it. We loop through all of them and call close without assuming that
                // they'll be removed from the list instantaneously.
                dialogs[i].close();
            }
        };
        return _NativeDialogBase;
    }());
    _NativeDialogBase.decorators = [
        { type: i0.Directive }
    ];
    _NativeDialogBase.ctorParameters = function () { return [
        { type: i0.Injector },
        { type: undefined },
        { type: undefined },
        { type: i0.Type },
        { type: i0.Type },
        { type: i0.InjectionToken },
        { type: NSLocationStrategy }
    ]; };
    /**
     * Service to open Material Design modal dialogs.
     */
    var NativeDialogService = /** @class */ (function (_super) {
        __extends(NativeDialogService, _super);
        function NativeDialogService(injector, defaultOptions, parentDialog, location) {
            return _super.call(this, injector, defaultOptions, parentDialog, NativeDialogRef, NativeModalRef, NATIVE_DIALOG_DATA, location) || this;
        }
        return NativeDialogService;
    }(_NativeDialogBase));
    NativeDialogService.decorators = [
        { type: i0.Injectable }
    ];
    NativeDialogService.ctorParameters = function () { return [
        { type: i0.Injector },
        { type: NativeDialogConfig, decorators: [{ type: i0.Optional }, { type: i0.Inject, args: [NATIVE_DIALOG_DEFAULT_OPTIONS,] }] },
        { type: NativeDialogService, decorators: [{ type: i0.Optional }, { type: i0.SkipSelf }] },
        { type: NSLocationStrategy, decorators: [{ type: i0.Optional }] }
    ]; };
    /**
     * Applies default options to the dialog config.
     * @param config Config to be modified.
     * @param defaultOptions Default options provided.
     * @returns The new configuration object.
     */
    function _applyConfigDefaults(config, defaultOptions) {
        return Object.assign(Object.assign({}, defaultOptions), config);
    }

    /**
     * @license
     * Copyright Google LLC All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Button that will close the current dialog.
     */
    // eslint-disable-next-line @angular-eslint/directive-class-suffix
    var NativeDialogCloseDirective = /** @class */ (function () {
        function NativeDialogCloseDirective(
        // The dialog title directive is always used in combination with a `MatDialogRef`.
        // tslint:disable-next-line: lightweight-tokens
        dialogRef, _elementRef, _dialog) {
            this.dialogRef = dialogRef;
            this._elementRef = _elementRef;
            this._dialog = _dialog;
        }
        NativeDialogCloseDirective.prototype.ngOnInit = function () {
            if (!this.dialogRef) {
                // When this directive is included in a dialog via TemplateRef (rather than being
                // in a Component), the DialogRef isn't available via injection because embedded
                // views cannot be given a custom injector. Instead, we look up the DialogRef by
                // ID. This must occur in `onInit`, as the ID binding for the dialog container won't
                // be resolved at constructor time.
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.dialogRef = getClosestDialog(this._elementRef, this._dialog.openDialogs);
            }
        };
        NativeDialogCloseDirective.prototype.ngOnChanges = function (changes) {
            var proxiedChange = changes['_matDialogClose'] || changes['_matDialogCloseResult'];
            if (proxiedChange) {
                this.dialogResult = proxiedChange.currentValue;
            }
        };
        NativeDialogCloseDirective.prototype._onButtonClick = function () {
            // Determinate the focus origin using the click event, because using the FocusMonitor will
            // result in incorrect origins. Most of the time, close buttons will be auto focused in the
            // dialog, and therefore clicking the button won't result in a focus change. This means that
            // the FocusMonitor won't detect any origin change, and will always output `program`.
            this.dialogRef.close(this.dialogResult);
        };
        return NativeDialogCloseDirective;
    }());
    NativeDialogCloseDirective.decorators = [
        { type: i0.Directive, args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[native-dialog-close], [nativeDialogClose]',
                    exportAs: 'nativeDialogClose',
                },] }
    ];
    NativeDialogCloseDirective.ctorParameters = function () { return [
        { type: NativeDialogRef, decorators: [{ type: i0.Optional }] },
        { type: i0.ElementRef },
        { type: NativeDialogService }
    ]; };
    NativeDialogCloseDirective.propDecorators = {
        dialogResult: [{ type: i0.Input, args: ['native-dialog-close',] }],
        _matDialogClose: [{ type: i0.Input, args: ['nativeDialogClose',] }],
        _onButtonClick: [{ type: i0.HostListener, args: ['tap',] }]
    };
    /**
     * Finds the closest MatDialogRef to an element by looking at the DOM.
     * @param element Element relative to which to look for a dialog.
     * @param openDialogs References to the currently-open dialogs.
     */
    function getClosestDialog(element, openDialogs) {
        var view = element.nativeElement.parent;
        while (view && !Object.hasOwnProperty.call(view, '__ng_modal_id__')) {
            view = view.parent;
        }
        return view ? openDialogs.find(function (dialog) { return dialog.id === view['__ng_modal_id__']; }) : null;
    }

    var NativeDialogModule = /** @class */ (function () {
        function NativeDialogModule() {
        }
        return NativeDialogModule;
    }());
    NativeDialogModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [NativeDialogCloseDirective],
                    exports: [NativeDialogCloseDirective],
                    providers: [NativeDialogService],
                },] }
    ];

    // Allows greater flexibility with `file-system` and Angular
    // Also provides a way for `file-system` to be mocked for testing
    var NSFileSystem = /** @class */ (function () {
        function NSFileSystem() {
        }
        NSFileSystem.prototype.currentApp = function () {
            return core.knownFolders.currentApp();
        };
        NSFileSystem.prototype.fileFromPath = function (path) {
            return core.File.fromPath(path);
        };
        NSFileSystem.prototype.fileExists = function (path) {
            return core.File.exists(path);
        };
        return NSFileSystem;
    }());
    NSFileSystem.decorators = [
        { type: i0.Injectable }
    ];

    /**
     * creates a DetachedLoader either linked to the ViewContainerRef or the ApplicationRef if ViewContainerRef is not defined
     * @param resolver component factory resolver
     * @param injector default injector, unused if viewContainerRef is set
     * @param viewContainerRef where the view should live in the angular tree
     * @returns reference to the DetachedLoader
     */
    function generateDetachedLoader(resolver, injector, viewContainerRef) {
        injector = (viewContainerRef === null || viewContainerRef === void 0 ? void 0 : viewContainerRef.injector) || injector;
        var detachedFactory = resolver.resolveComponentFactory(DetachedLoader);
        var detachedLoaderRef = (viewContainerRef === null || viewContainerRef === void 0 ? void 0 : viewContainerRef.createComponent(detachedFactory)) || detachedFactory.create(injector);
        if (!viewContainerRef) {
            injector.get(i0.ApplicationRef).attachView(detachedLoaderRef.hostView);
        }
        detachedLoaderRef.changeDetectorRef.detectChanges();
        return detachedLoaderRef;
    }
    /**
     * Generates a NgViewRef from a component or template. @see NgViewRef
     * Pass keepNativeViewAttached as `true` if you don't want the first native view to be detached from its parent.
     * For opening modals and others, the firstNativeLikeView should be detached.
     * @param typeOrTemplate ComponentType or TemplateRef that should be instanced
     * @param options options for creating the view
     * @returns NgViewRef
     */
    function generateNativeScriptView(typeOrTemplate, options) {
        var _a;
        var detachedLoaderRef = options.detachedLoaderRef;
        var reusingDetachedLoader = !!detachedLoaderRef;
        if (reusingDetachedLoader) {
            options.viewContainerRef = detachedLoaderRef.instance.vc;
        }
        var injector = ((_a = options.viewContainerRef) === null || _a === void 0 ? void 0 : _a.injector) || options.injector;
        var resolver = options.resolver || injector.get(i0.ComponentFactoryResolver);
        if (!detachedLoaderRef && (options.viewContainerRef || typeOrTemplate instanceof i0.TemplateRef)) {
            detachedLoaderRef = generateDetachedLoader(resolver, injector, options.viewContainerRef);
        }
        var portal;
        if (typeOrTemplate instanceof i0.TemplateRef) {
            portal = new TemplatePortal(typeOrTemplate, detachedLoaderRef.instance.vc);
        }
        else {
            portal = new ComponentPortal(typeOrTemplate, detachedLoaderRef === null || detachedLoaderRef === void 0 ? void 0 : detachedLoaderRef.instance.vc);
        }
        var parentView = new core.ContentView();
        var portalOutlet = new NativeScriptDomPortalOutlet(parentView, resolver, injector.get(i0.ApplicationRef), injector);
        var componentOrTemplateRef = portalOutlet.attach(portal);
        componentOrTemplateRef.onDestroy(function () {
            portalOutlet.dispose();
        });
        if (detachedLoaderRef && !reusingDetachedLoader) {
            componentOrTemplateRef.onDestroy(function () {
                detachedLoaderRef.destroy();
            });
        }
        var viewRef = new NgViewRef(componentOrTemplateRef);
        viewRef.detachedLoaderRef = detachedLoaderRef;
        if (!options.keepNativeViewAttached) {
            viewRef.detachNativeLikeView();
        }
        return viewRef;
    }

    var BaseValueAccessor = /** @class */ (function () {
        function BaseValueAccessor(view) {
            this.view = view;
            this.pendingChangeNotification = 0;
            this.onChange = function (_) { };
            this.onTouched = function () { };
        }
        BaseValueAccessor.prototype.registerOnChange = function (fn) {
            var _this = this;
            this.onChange = function (arg) {
                if (_this.pendingChangeNotification) {
                    clearTimeout(_this.pendingChangeNotification);
                }
                _this.pendingChangeNotification = setTimeout(function () {
                    _this.pendingChangeNotification = 0;
                    fn(arg);
                }, 20);
            };
        };
        BaseValueAccessor.prototype.registerOnTouched = function (fn) {
            this.onTouched = fn;
        };
        BaseValueAccessor.prototype.setDisabledState = function (isDisabled) {
            this.view.isEnabled = !isDisabled;
        };
        BaseValueAccessor.prototype.writeValue = function (_) { };
        BaseValueAccessor.prototype.normalizeValue = function (value) {
            return isBlank(value) ? core.unsetValue : value;
        };
        return BaseValueAccessor;
    }());

    var TEXT_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return TextValueAccessor; }),
        multi: true,
    };
    /**
     * The accessor for writing a text and listening to changes that is used by the
     * {@link NgModel} directives.
     *
     *  ### Example
     *  ```
     *  <TextField [(ngModel)]="model.test">
     *  ```
     */
    var TextValueAccessor = /** @class */ (function (_super) {
        __extends(TextValueAccessor, _super);
        // tslint:disable-line:directive-class-suffix
        function TextValueAccessor(elementRef) {
            return _super.call(this, elementRef.nativeElement) || this;
        }
        TextValueAccessor.prototype.writeValue = function (value) {
            var normalized = _super.prototype.normalizeValue.call(this, value ? "" + value : value);
            this.view.text = normalized;
        };
        return TextValueAccessor;
    }(BaseValueAccessor));
    TextValueAccessor.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'TextField[ngModel],TextField[formControlName],TextField[formControl],' +
                        'textField[ngModel],textField[formControlName],textField[formControl],' +
                        'textfield[ngModel],textfield[formControlName],textfield[formControl],' +
                        'text-field[ngModel],text-field[formControlName],text-field[formControl],' +
                        'TextView[ngModel],TextView[formControlName],TextView[formControl],' +
                        'textView[ngModel],textView[formControlName],textView[formControl],' +
                        'textview[ngModel],textview[formControlName],textview[formControl],' +
                        'text-view[ngModel],text-view[formControlName],text-view[formControl],' +
                        'SearchBar[ngModel],SearchBar[formControlName],SearchBar[formControl],' +
                        'searchBar[ngModel],searchBar[formControlName],searchBar[formControl],' +
                        'searchbar[ngModel],searchbar[formControlName],searchbar[formControl],' +
                        'search-bar[ngModel], search-bar[formControlName],search-bar[formControl]',
                    providers: [TEXT_VALUE_ACCESSOR],
                    host: {
                        '(blur)': 'onTouched()',
                        '(textChange)': 'onChange($event.value)',
                    },
                },] }
    ];
    TextValueAccessor.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };

    var CHECKED_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return CheckedValueAccessor; }),
        multi: true,
    };
    /**
     * The accessor for setting a checked property and listening to changes that is used by the
     * {@link NgModel} directives.
     *
     *  ### Example
     *  ```
     *  <Switch [(ngModel)]="model.test">
     *  ```
     */
    var CheckedValueAccessor = /** @class */ (function (_super) {
        __extends(CheckedValueAccessor, _super);
        // tslint:disable-line:directive-class-suffix
        function CheckedValueAccessor(elementRef) {
            return _super.call(this, elementRef.nativeElement) || this;
        }
        CheckedValueAccessor.prototype.writeValue = function (value) {
            var normalized = _super.prototype.normalizeValue.call(this, value);
            this.view.checked = normalized;
        };
        return CheckedValueAccessor;
    }(BaseValueAccessor));
    CheckedValueAccessor.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'Switch[ngModel],Switch[formControlName],Switch[formControl],' + 'switch[ngModel],switch[formControlName],switch[formControl]',
                    providers: [CHECKED_VALUE_ACCESSOR],
                    host: {
                        '(checkedChange)': 'onChange($event.value)',
                    },
                },] }
    ];
    CheckedValueAccessor.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };

    var DATE_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return DateValueAccessor; }),
        multi: true,
    };
    /**
     * The accessor for setting a date and listening to changes that is used by the
     * {@link NgModel} directives.
     *
     *  ### Example
     *  ```
     *  <DatePicker [(ngModel)]="model.test">
     *  ```
     */
    var DateValueAccessor = /** @class */ (function (_super) {
        __extends(DateValueAccessor, _super);
        // tslint:disable-line:directive-class-suffix
        function DateValueAccessor(elementRef) {
            return _super.call(this, elementRef.nativeElement) || this;
        }
        DateValueAccessor.prototype.writeValue = function (value) {
            var normalized = _super.prototype.normalizeValue.call(this, value);
            this.view.date = normalized;
        };
        return DateValueAccessor;
    }(BaseValueAccessor));
    DateValueAccessor.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'DatePicker[ngModel],DatePicker[formControlName],DatePicker[formControl],' + 'datepicker[ngModel],datepicker[formControlName],datepicker[formControl],' + 'datePicker[ngModel],datePicker[formControlName],datePicker[formControl],' + 'date-picker[ngModel],date-picker[formControlName],date-picker[formControl]',
                    providers: [DATE_VALUE_ACCESSOR],
                    host: {
                        '(dateChange)': 'onChange($event.value)',
                    },
                },] }
    ];
    DateValueAccessor.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };

    var TIME_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return TimeValueAccessor; }),
        multi: true,
    };
    /**
     * The accessor for setting a time and listening to changes that is used by the
     * {@link NgModel} directives.
     *
     *  ### Example
     *  ```
     *  <TimePicker [(ngModel)]="model.test">
     *  ```
     */
    var TimeValueAccessor = /** @class */ (function (_super) {
        __extends(TimeValueAccessor, _super);
        // tslint:disable-line:directive-class-suffix
        function TimeValueAccessor(elementRef) {
            return _super.call(this, elementRef.nativeElement) || this;
        }
        TimeValueAccessor.prototype.writeValue = function (value) {
            var normalized = _super.prototype.normalizeValue.call(this, value);
            this.view.time = normalized;
        };
        return TimeValueAccessor;
    }(BaseValueAccessor));
    TimeValueAccessor.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'TimePicker[ngModel],TimePicker[formControlName],TimePicker[formControl],' + 'timepicker[ngModel],timepicker[formControlName],timepicker[formControl],' + 'timePicker[ngModel],timePicker[formControlName],timePicker[formControl],' + 'time-picker[ngModel],time-picker[formControlName],time-picker[formControl]',
                    providers: [TIME_VALUE_ACCESSOR],
                    host: {
                        '(timeChange)': 'onChange($event.value)',
                    },
                },] }
    ];
    TimeValueAccessor.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };

    var NUMBER_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return NumberValueAccessor; }),
        multi: true,
    };
    /**
     * The accessor for setting a value and listening to changes that is used by the
     * {@link NgModel}
     *
     *  ### Example
     *  ```
     *  <Slider [(ngModel)]="model.test">
     *  ```
     */
    var NumberValueAccessor = /** @class */ (function (_super) {
        __extends(NumberValueAccessor, _super);
        // tslint:disable-line:directive-class-suffix
        function NumberValueAccessor(elementRef) {
            return _super.call(this, elementRef.nativeElement) || this;
        }
        NumberValueAccessor.prototype.writeValue = function (value) {
            var normalized = _super.prototype.normalizeValue.call(this, value);
            this.view.value = normalized;
        };
        return NumberValueAccessor;
    }(BaseValueAccessor));
    NumberValueAccessor.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'Slider[ngModel],Slider[formControlName],Slider[formControl],' + 'slider[ngModel],slider[formControlName],slider[formControl]',
                    providers: [NUMBER_VALUE_ACCESSOR],
                    host: {
                        '(valueChange)': 'onChange($event.value)',
                    },
                },] }
    ];
    NumberValueAccessor.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };

    var SELECTED_INDEX_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: i0.forwardRef(function () { return SelectedIndexValueAccessor; }),
        multi: true,
    };
    /**
     * The accessor for setting a selectedIndex and listening to changes that is used by the
     * {@link NgModel} directives.
     *
     *  ### Example
     *  ```
     *  <SegmentedBar [(ngModel)]="model.test">
     *  ```
     */
    var SelectedIndexValueAccessor = /** @class */ (function (_super) {
        __extends(SelectedIndexValueAccessor, _super);
        // tslint:disable-line:max-line-length directive-class-suffix
        function SelectedIndexValueAccessor(elementRef) {
            return _super.call(this, elementRef.nativeElement) || this;
        }
        SelectedIndexValueAccessor.prototype.writeValue = function (value) {
            var normalized = _super.prototype.normalizeValue.call(this, value);
            this.value = normalized;
            if (this.viewInitialized) {
                this.view.selectedIndex = this.value;
            }
        };
        SelectedIndexValueAccessor.prototype.ngAfterViewInit = function () {
            this.viewInitialized = true;
            this.view.selectedIndex = this.value;
        };
        return SelectedIndexValueAccessor;
    }(BaseValueAccessor));
    SelectedIndexValueAccessor.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'SegmentedBar[ngModel],SegmentedBar[formControlName],SegmentedBar[formControl],' +
                        'segmentedBar[ngModel],segmentedBar[formControlName],segmentedBar[formControl],' +
                        'segmentedbar[ngModel],segmentedbar[formControlName],segmentedbar[formControl],' +
                        'segmented-bar[ngModel],segmented-bar[formControlName],segmented-bar[formControl],' +
                        'ListPicker[ngModel],ListPicker[formControlName],ListPicker[formControl],' +
                        'listPicker[ngModel],listPicker[formControlName],listPicker[formControl],' +
                        'listpicker[ngModel],listpicker[formControlName],listpicker[formControl],' +
                        'list-picker[ngModel],list-picker[formControlName],list-picker[formControl],' +
                        'TabView[ngModel],TabView[formControlName],TabView[formControl],' +
                        'tabView[ngModel],tabView[formControlName],tabView[formControl],' +
                        'tabview[ngModel],tabview[formControlName],tabview[formControl],' +
                        'tab-view[ngModel],tab-view[formControlName],tab-view[formControl]',
                    providers: [SELECTED_INDEX_VALUE_ACCESSOR],
                    host: {
                        '(selectedIndexChange)': 'onChange($event.value)',
                    },
                },] }
    ];
    SelectedIndexValueAccessor.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };

    var NativeScriptFormsModule = /** @class */ (function () {
        function NativeScriptFormsModule() {
        }
        return NativeScriptFormsModule;
    }());
    NativeScriptFormsModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [TextValueAccessor, CheckedValueAccessor, DateValueAccessor, TimeValueAccessor, SelectedIndexValueAccessor, NumberValueAccessor],
                    providers: [],
                    imports: [forms.FormsModule],
                    exports: [forms.FormsModule, TextValueAccessor, CheckedValueAccessor, DateValueAccessor, TimeValueAccessor, SelectedIndexValueAccessor, NumberValueAccessor],
                },] }
    ];

    var DASH_CASE_REGEXP = /-+([a-z0-9])/g;
    function dashCaseToCamelCase(input) {
        return input.replace(DASH_CASE_REGEXP, function () {
            var m = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                m[_i] = arguments[_i];
            }
            return m[1].toUpperCase();
        });
    }
    function createKeyframeAnimation(styles, duration, delay, easing) {
        var info = createKeyframeAnimationInfo(styles, duration, delay, easing);
        return core.KeyframeAnimation.keyframeAnimationFromInfo(info);
    }
    var createKeyframeAnimationInfo = function (styles, duration, delay, easing) { return ({
        isForwards: true,
        duration: duration || 0.01,
        delay: delay,
        curve: getCurve(easing),
        keyframes: styles.map(parseAnimationKeyframe),
    }); };
    var ɵ0$2 = createKeyframeAnimationInfo;
    var getCurve = function (value) { return core.animationTimingFunctionConverter(value); };
    var ɵ1 = getCurve;
    var parseAnimationKeyframe = function (styles) { return ({
        duration: getKeyframeDuration(styles),
        declarations: getDeclarations(styles),
    }); };
    var ɵ2 = parseAnimationKeyframe;
    var getKeyframeDuration = function (styles) { return styles.offset; };
    var ɵ3 = getKeyframeDuration;
    function getDeclarations(styles) {
        var unparsedDeclarations = Object.keys(styles).map(function (property) { return ({ property: property, value: styles[property] }); });
        return core.parseKeyframeDeclarations(unparsedDeclarations);
    }

    var NativeScriptAnimationPlayer = /** @class */ (function () {
        function NativeScriptAnimationPlayer(target, keyframes, duration, delay, easing) {
            this.target = target;
            this.duration = duration;
            this.delay = delay;
            this.parentPlayer = null;
            this._startSubscriptions = [];
            this._doneSubscriptions = [];
            this._finished = false;
            this._started = false;
            this.initKeyframeAnimation(keyframes, duration, delay, easing);
        }
        Object.defineProperty(NativeScriptAnimationPlayer.prototype, "totalTime", {
            get: function () {
                return this.delay + this.duration;
            },
            enumerable: false,
            configurable: true
        });
        NativeScriptAnimationPlayer.prototype.init = function () { };
        NativeScriptAnimationPlayer.prototype.hasStarted = function () {
            return this._started;
        };
        NativeScriptAnimationPlayer.prototype.onStart = function (fn) {
            this._startSubscriptions.push(fn);
        };
        NativeScriptAnimationPlayer.prototype.onDone = function (fn) {
            this._doneSubscriptions.push(fn);
        };
        NativeScriptAnimationPlayer.prototype.onDestroy = function (fn) {
            this._doneSubscriptions.push(fn);
        };
        NativeScriptAnimationPlayer.prototype.play = function () {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.animationsLog("NativeScriptAnimationPlayer.play");
            }
            if (!this.animation) {
                return;
            }
            if (!this._started) {
                this._started = true;
                this._startSubscriptions.forEach(function (fn) { return fn(); });
                this._startSubscriptions = [];
            }
            // When this issue https://github.com/NativeScript/NativeScript/issues/7984 is fixes in @nativescript/core
            // we can change this fix and apply the one that is recommended in that issue.
            if (this.target.isLoaded) {
                this.playAnimation();
            }
            else {
                this.target.on(core.View.loadedEvent, this.onTargetLoaded.bind(this));
            }
        };
        NativeScriptAnimationPlayer.prototype.onTargetLoaded = function (args) {
            this.target.off(core.View.loadedEvent, this.onTargetLoaded);
            this.playAnimation();
        };
        NativeScriptAnimationPlayer.prototype.playAnimation = function () {
            var _this = this;
            this.animation
                .play(this.target)
                .then(function () { return _this.onFinish(); })
                .catch(function (_e) { });
        };
        NativeScriptAnimationPlayer.prototype.pause = function () { };
        NativeScriptAnimationPlayer.prototype.finish = function () {
            this.onFinish();
        };
        NativeScriptAnimationPlayer.prototype.reset = function () {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.animationsLog("NativeScriptAnimationPlayer.reset");
            }
            if (this.animation && this.animation.isPlaying) {
                this.animation.cancel();
            }
        };
        NativeScriptAnimationPlayer.prototype.restart = function () {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.animationsLog("NativeScriptAnimationPlayer.restart");
            }
            this.reset();
            this.play();
        };
        NativeScriptAnimationPlayer.prototype.destroy = function () {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.animationsLog("NativeScriptAnimationPlayer.destroy");
            }
            this.onFinish();
        };
        NativeScriptAnimationPlayer.prototype.setPosition = function (_p) {
            throw new Error('AnimationPlayer.setPosition method is not supported!');
        };
        NativeScriptAnimationPlayer.prototype.getPosition = function () {
            return 0;
        };
        NativeScriptAnimationPlayer.prototype.initKeyframeAnimation = function (keyframes, duration, delay, easing) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.animationsLog("NativeScriptAnimationPlayer.initKeyframeAnimation");
            }
            this.animation = createKeyframeAnimation(keyframes, duration, delay, easing);
        };
        NativeScriptAnimationPlayer.prototype.onFinish = function () {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.animationsLog("NativeScriptAnimationPlayer.onFinish");
            }
            if (this._finished) {
                return;
            }
            this._finished = true;
            this._started = false;
            this._doneSubscriptions.forEach(function (fn) { return fn(); });
            this._doneSubscriptions = [];
        };
        return NativeScriptAnimationPlayer;
    }());

    var Selector = /** @class */ (function () {
        function Selector(rawSelector) {
            this.parse(rawSelector);
        }
        Selector.prototype.match = function (element) {
            return this.nsSelectorMatch(element) || this.classSelectorsMatch(element);
        };
        Selector.prototype.parse = function (rawSelector) {
            var selectors = rawSelector.split(',').map(function (s) { return s.trim(); });
            this.nsSelectors = selectors.map(core.CSSHelper.createSelector);
            this.classSelectors = selectors.filter(function (s) { return s.startsWith('.'); }).map(function (s) { return s.substring(1); });
        };
        Selector.prototype.nsSelectorMatch = function (element) {
            return this.nsSelectors.some(function (s) { return s.match(element); });
        };
        Selector.prototype.classSelectorsMatch = function (element) {
            var _this = this;
            return this.classSelectors.some(function (s) { return _this.hasClass(element, s); });
        };
        // we're using that instead of match for classes
        // that are dynamically added by the animation engine
        // such as .ng-trigger, that's added for every :enter view
        Selector.prototype.hasClass = function (element, cls) {
            return element && element['$$classes'] && element['$$classes'][cls];
        };
        return Selector;
    }());
    var NativeScriptAnimationDriver = /** @class */ (function () {
        function NativeScriptAnimationDriver() {
        }
        NativeScriptAnimationDriver.prototype.validateStyleProperty = function (property) {
            NativeScriptDebug.animationsLog("CssAnimationProperty.validateStyleProperty: " + property);
            return NativeScriptAnimationDriver.validProperties.indexOf(property) !== -1;
        };
        NativeScriptAnimationDriver.prototype.matchesElement = function (element, rawSelector) {
            NativeScriptDebug.animationsLog("NativeScriptAnimationDriver.matchesElement " + ("element: " + element + ", selector: " + rawSelector));
            var selector = this.makeSelector(rawSelector);
            return selector.match(element);
        };
        NativeScriptAnimationDriver.prototype.containsElement = function (elm1, elm2) {
            NativeScriptDebug.animationsLog("NativeScriptAnimationDriver.containsElement " + ("element1: " + elm1 + ", element2: " + elm2));
            // Checking if the parent is our fake body object
            if (elm1['isOverride']) {
                return true;
            }
            var params = { originalView: elm2 };
            var result = this.visitDescendants(elm1, viewMatches, params);
            return result.found;
        };
        NativeScriptAnimationDriver.prototype.query = function (element, rawSelector, multi) {
            NativeScriptDebug.animationsLog("NativeScriptAnimationDriver.query " + ("element: " + element + ", selector: " + rawSelector + " ") + ("multi: " + multi));
            var selector = this.makeSelector(rawSelector);
            var params = { selector: selector, multi: multi };
            var result = this.visitDescendants(element, queryDescendants, params);
            return result.matches || [];
        };
        NativeScriptAnimationDriver.prototype.computeStyle = function (element, prop) {
            NativeScriptDebug.animationsLog("NativeScriptAnimationDriver.computeStyle " + ("element: " + element + ", prop: " + prop));
            var camelCaseProp = dashCaseToCamelCase(prop);
            return element.style[camelCaseProp];
        };
        NativeScriptAnimationDriver.prototype.animate = function (element, keyframes, duration, delay, easing) {
            NativeScriptDebug.animationsLog("NativeScriptAnimationDriver.animate " + ("element: " + element + ", keyframes: " + keyframes + " ") + ("duration: " + duration + ", delay: " + delay + " ") + ("easing: " + easing));
            return new NativeScriptAnimationPlayer(element, keyframes, duration, delay, easing);
        };
        NativeScriptAnimationDriver.prototype.makeSelector = function (rawSelector) {
            return new Selector(rawSelector);
        };
        NativeScriptAnimationDriver.prototype.visitDescendants = function (element, cb, cbParams) {
            var result = {};
            // fill the result obj with the result from the callback function
            core.eachDescendant(element, function (child) { return cb(child, result, cbParams); });
            return result;
        };
        return NativeScriptAnimationDriver;
    }());
    NativeScriptAnimationDriver.validProperties = __spreadArray(__spreadArray([], __read(core.CssAnimationProperty._getPropertyNames())), ['transform']);
    function viewMatches(element, result, params) {
        if (element === params.originalView) {
            result.found = true;
        }
        return !result.found;
    }
    function queryDescendants(element, result, params) {
        if (!result.matches) {
            result.matches = [];
        }
        var selector = params.selector, multi = params.multi;
        // skip comment and text nodes
        // because they are not actual Views
        // and cannot be animated
        if (element instanceof InvisibleNode || !selector.match(element)) {
            return true;
        }
        if (element instanceof core.ProxyViewContainer) {
            element.eachChild(function (child) {
                result.matches.push(child);
                return true;
            });
        }
        else {
            result.matches.push(element);
        }
        return multi;
    }

    var InjectableAnimationEngine = /** @class */ (function (_super) {
        __extends(InjectableAnimationEngine, _super);
        function InjectableAnimationEngine(doc, driver, normalizer) {
            return _super.call(this, doc.body, driver, normalizer) || this;
        }
        return InjectableAnimationEngine;
    }(browser.ɵAnimationEngine));
    InjectableAnimationEngine.decorators = [
        { type: i0.Injectable }
    ];
    InjectableAnimationEngine.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [common.DOCUMENT,] }] },
        { type: browser.AnimationDriver },
        { type: browser.ɵAnimationStyleNormalizer }
    ]; };
    function instantiateSupportedAnimationDriver() {
        return new NativeScriptAnimationDriver();
    }
    function instantiateRendererFactory(renderer, engine, zone) {
        return new animations.ɵAnimationRendererFactory(renderer, engine, zone);
    }
    function instantiateDefaultStyleNormalizer() {
        return new browser.ɵWebAnimationsStyleNormalizer();
    }
    var NativeScriptAnimationsModule = /** @class */ (function () {
        function NativeScriptAnimationsModule(parentModule) {
            // Prevents NativeScriptAnimationsModule from getting imported multiple times
            throwIfAlreadyLoaded(parentModule, 'NativeScriptAnimationsModule');
        }
        return NativeScriptAnimationsModule;
    }());
    NativeScriptAnimationsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [NativeScriptCommonModule],
                    providers: [
                        {
                            provide: browser.AnimationDriver,
                            useFactory: instantiateSupportedAnimationDriver,
                        },
                        { provide: animations$1.AnimationBuilder, useClass: animations.ɵBrowserAnimationBuilder },
                        {
                            provide: browser.ɵAnimationStyleNormalizer,
                            useFactory: instantiateDefaultStyleNormalizer,
                        },
                        { provide: browser.ɵAnimationEngine, useClass: InjectableAnimationEngine },
                        {
                            provide: i0.RendererFactory2,
                            useFactory: instantiateRendererFactory,
                            deps: [NativeScriptRendererFactory, browser.ɵAnimationEngine, i0.NgZone],
                        },
                    ],
                },] }
    ];
    NativeScriptAnimationsModule.ctorParameters = function () { return [
        { type: NativeScriptAnimationsModule, decorators: [{ type: i0.Optional }, { type: i0.SkipSelf }] }
    ]; };

    function isLocalRequest(url) {
        return url.indexOf('~') === 0 || url.indexOf('/') === 0;
    }
    function getAbsolutePath(url, nsFileSystem) {
        url = url.replace('~', '').replace('/', '');
        url = core.path.join(nsFileSystem.currentApp().path, url);
        return url;
    }
    function processLocalFileRequest(url, nsFileSystem, successResponse, errorResponse) {
        url = getAbsolutePath(url, nsFileSystem);
        // request from local app resources
        return new rxjs.Observable(function (observer) {
            if (nsFileSystem.fileExists(url)) {
                var localFile = nsFileSystem.fileFromPath(url);
                localFile.readText().then(function (data) {
                    try {
                        var json = JSON.parse(data);
                        observer.next(successResponse(url, json, 200));
                        observer.complete();
                    }
                    catch (error) {
                        // Even though the response status was 2xx, this is still an error.
                        // The parse error contains the text of the body that failed to parse.
                        var errorResult = { error: error, text: data };
                        observer.error(errorResponse(url, errorResult, 200));
                    }
                }, function (err) {
                    observer.error(errorResponse(url, err, 400));
                });
            }
            else {
                observer.error(errorResponse(url, 'Not Found', 404));
            }
        });
    }

    var NsHttpBackEnd = /** @class */ (function (_super) {
        __extends(NsHttpBackEnd, _super);
        function NsHttpBackEnd(xhrFactory, nsFileSystem) {
            var _this = _super.call(this, xhrFactory) || this;
            _this.nsFileSystem = nsFileSystem;
            return _this;
        }
        NsHttpBackEnd.prototype.handle = function (req) {
            var result;
            if (isLocalRequest(req.url)) {
                result = this.handleLocalFileRequest(req.url);
            }
            else {
                result = _super.prototype.handle.call(this, req);
            }
            return result;
        };
        NsHttpBackEnd.prototype.handleLocalFileRequest = function (url) {
            return processLocalFileRequest(url, this.nsFileSystem, createSuccessResponse, createErrorResponse);
        };
        return NsHttpBackEnd;
    }(http.HttpXhrBackend));
    NsHttpBackEnd.decorators = [
        { type: i0.Injectable }
    ];
    NsHttpBackEnd.ctorParameters = function () { return [
        { type: common.XhrFactory },
        { type: NSFileSystem }
    ]; };
    function createSuccessResponse(url, body, status) {
        return new http.HttpResponse({
            url: url,
            body: body,
            status: status,
            statusText: 'OK',
        });
    }
    function createErrorResponse(url, body, status) {
        return new http.HttpErrorResponse({
            url: url,
            error: body,
            status: status,
            statusText: 'ERROR',
        });
    }

    var NativeScriptHttpClientModule = /** @class */ (function () {
        function NativeScriptHttpClientModule() {
        }
        return NativeScriptHttpClientModule;
    }());
    NativeScriptHttpClientModule.decorators = [
        { type: i0.NgModule, args: [{
                    providers: [NSFileSystem, NsHttpBackEnd, { provide: http.HttpBackend, useExisting: NsHttpBackEnd }],
                    imports: [http.HttpClientModule],
                    exports: [http.HttpClientModule],
                },] }
    ];

    /**
     * There are cases where multiple activatedRoute nodes should be associated/handled by the same PageRouterOutlet.
     * We can gat additional ActivatedRoutes nodes when there is:
     *  - Lazy loading - there is an additional ActivatedRoute node for the RouteConfig with the `loadChildren` setup
     *  - Componentless routes - there is an additional ActivatedRoute node for the componentless RouteConfig
     *
     * Example:
     *   R  <-- root
     *   |
     * feature (lazy module) <-- RouteConfig: { path: "lazy", loadChildren: "./feature/feature.module#FeatureModule" }
     *   |
     * module (componentless route) <-- RouteConfig: { path: "module", children: [...] } // Note: No 'component'
     *   |
     *  home <-- RouteConfig: { path: "module", component: MyComponent } - this is what we get as activatedRoute param
     *
     *  In these cases we will mark the top-most node (feature). NSRouteReuseStrategy will detach the tree there and
     *  use this ActivateRoute as a kay for caching.
     */
    function findTopActivatedRouteNodeForOutlet(activatedRoute) {
        var outletActivatedRoute = activatedRoute;
        while (outletActivatedRoute.parent && outletActivatedRoute.parent.routeConfig && !outletActivatedRoute.parent.routeConfig.component) {
            outletActivatedRoute = outletActivatedRoute.parent;
        }
        return outletActivatedRoute;
    }
    var pageRouterActivatedSymbol = Symbol('page-router-activated');
    var loaderRefSymbol = Symbol('loader-ref');
    function destroyComponentRef(componentRef) {
        if (componentRef) {
            var loaderRef = componentRef[loaderRefSymbol];
            if (loaderRef) {
                loaderRef.destroy();
            }
            componentRef.destroy();
        }
    }

    var getSnapshotKey = function (snapshot) {
        return snapshot.pathFromRoot.join('->');
    };
    var ɵ0$1 = getSnapshotKey;
    /**
     * Detached state cache
     */
    var DetachedStateCache = /** @class */ (function () {
        function DetachedStateCache() {
            this.cache = new Array();
        }
        Object.defineProperty(DetachedStateCache.prototype, "length", {
            get: function () {
                return this.cache.length;
            },
            enumerable: false,
            configurable: true
        });
        DetachedStateCache.prototype.push = function (cacheItem) {
            this.cache.push(cacheItem);
        };
        DetachedStateCache.prototype.pop = function () {
            return this.cache.pop();
        };
        DetachedStateCache.prototype.peek = function () {
            return this.cache[this.cache.length - 1];
        };
        DetachedStateCache.prototype.clear = function () {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routeReuseStrategyLog("DetachedStateCache.clear() " + this.cache.length + " items will be destroyed");
            }
            while (this.cache.length > 0) {
                var state = this.cache.pop().state;
                if (!state.componentRef) {
                    throw new Error('No componentRed found in DetachedRouteHandle');
                }
                destroyComponentRef(state.componentRef);
            }
        };
        DetachedStateCache.prototype.clearModalCache = function () {
            var removedItemsCount = 0;
            var hasModalPages = this.cache.some(function (cacheItem) {
                return cacheItem.isModal;
            });
            if (hasModalPages) {
                var modalCacheCleared = false;
                while (!modalCacheCleared) {
                    var cacheItem = this.peek();
                    var state = cacheItem.state;
                    if (!state.componentRef) {
                        throw new Error('No componentRef found in DetachedRouteHandle');
                    }
                    destroyComponentRef(state.componentRef);
                    if (cacheItem.isModal) {
                        modalCacheCleared = true;
                    }
                    this.pop();
                    removedItemsCount++;
                }
            }
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routeReuseStrategyLog("DetachedStateCache.clearModalCache() " + removedItemsCount + " items will be destroyed");
            }
        };
        return DetachedStateCache;
    }());
    /**
     * Detaches subtrees loaded inside PageRouterOutlet in forward navigation
     * and reattaches them on back.
     * Reuses routes as long as their route config is the same.
     */
    var NSRouteReuseStrategy = /** @class */ (function () {
        function NSRouteReuseStrategy(location) {
            this.location = location;
            this.cacheByOutlet = {};
        }
        NSRouteReuseStrategy.prototype.shouldDetach = function (route) {
            route = findTopActivatedRouteNodeForOutlet(route);
            var outletKey = this.location.getRouteFullPath(route);
            var outlet = this.location.findOutlet(outletKey, route);
            var key = getSnapshotKey(route);
            var isPageActivated = route[pageRouterActivatedSymbol];
            var isBack = outlet ? outlet.isPageNavigationBack : false;
            var shouldDetach = outlet && !isBack && isPageActivated;
            if (outlet) {
                if (outlet.parent && !outlet.parent.shouldDetach) {
                    shouldDetach = false;
                }
                outlet.shouldDetach = shouldDetach;
            }
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routeReuseStrategyLog("shouldDetach isBack: " + isBack + " key: " + key + " result: " + shouldDetach);
            }
            return shouldDetach;
        };
        NSRouteReuseStrategy.prototype.shouldAttach = function (route) {
            var _a;
            route = findTopActivatedRouteNodeForOutlet(route);
            var outletKey = this.location.getRouteFullPath(route);
            var outlet = this.location.findOutlet(outletKey, route);
            var cache = this.cacheByOutlet[outletKey];
            if (!cache) {
                return false;
            }
            var key = getSnapshotKey(route);
            var isBack = outlet ? outlet.isPageNavigationBack : false;
            var shouldAttach = isBack && ((_a = cache.peek()) === null || _a === void 0 ? void 0 : _a.key) === key;
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routeReuseStrategyLog("shouldAttach isBack: " + isBack + " key: " + key + " result: " + shouldAttach);
            }
            if (outlet) {
                outlet.shouldDetach = true;
            }
            return shouldAttach;
        };
        NSRouteReuseStrategy.prototype.store = function (route, state) {
            route = findTopActivatedRouteNodeForOutlet(route);
            var key = getSnapshotKey(route);
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routeReuseStrategyLog("store key: " + key + ", state: " + state);
            }
            var outletKey = this.location.getRouteFullPath(route);
            // tslint:disable-next-line:max-line-length
            var cache = (this.cacheByOutlet[outletKey] = this.cacheByOutlet[outletKey] || new DetachedStateCache());
            if (state) {
                var isModal = false;
                if (this.location._modalNavigationDepth > 0) {
                    isModal = true;
                }
                cache.push({ key: key, state: state, isModal: isModal });
            }
            else {
                var topItem = cache.peek();
                if (topItem.key === key) {
                    cache.pop();
                    if (!cache.length) {
                        delete this.cacheByOutlet[outletKey];
                    }
                }
                else {
                    throw new Error("Trying to pop from DetachedStateCache but keys don't match. " + ("expected: " + topItem.key + " actual: " + key));
                }
            }
        };
        NSRouteReuseStrategy.prototype.retrieve = function (route) {
            route = findTopActivatedRouteNodeForOutlet(route);
            var outletKey = this.location.getRouteFullPath(route);
            var outlet = this.location.findOutlet(outletKey, route);
            var cache = this.cacheByOutlet[outletKey];
            if (!cache) {
                return null;
            }
            var key = getSnapshotKey(route);
            var isBack = outlet ? outlet.isPageNavigationBack : false;
            var cachedItem = cache.peek();
            var state = null;
            if (isBack && cachedItem && cachedItem.key === key) {
                state = cachedItem.state;
            }
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routeReuseStrategyLog("retrieved isBack: " + isBack + " key: " + key + " state: " + state);
            }
            return state;
        };
        NSRouteReuseStrategy.prototype.shouldReuseRoute = function (future, curr) {
            var shouldReuse = future.routeConfig === curr.routeConfig;
            if (shouldReuse && curr && curr[pageRouterActivatedSymbol]) {
                // When reusing route - copy the pageRouterActivated to the new snapshot
                // It's needed in shouldDetach to determine if the route should be detached.
                future[pageRouterActivatedSymbol] = curr[pageRouterActivatedSymbol];
            }
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routeReuseStrategyLog("shouldReuseRoute result: " + shouldReuse);
            }
            return shouldReuse;
        };
        NSRouteReuseStrategy.prototype.clearCache = function (outletKey) {
            var cache = this.cacheByOutlet[outletKey];
            if (cache) {
                cache.clear();
            }
        };
        NSRouteReuseStrategy.prototype.clearModalCache = function (outletKey) {
            var cache = this.cacheByOutlet[outletKey];
            if (cache) {
                cache.clearModalCache();
            }
        };
        return NSRouteReuseStrategy;
    }());
    NSRouteReuseStrategy.decorators = [
        { type: i0.Injectable }
    ];
    NSRouteReuseStrategy.ctorParameters = function () { return [
        { type: NSLocationStrategy }
    ]; };

    var RouterExtensions = /** @class */ (function () {
        function RouterExtensions(router, locationStrategy, frameService) {
            this.router = router;
            this.locationStrategy = locationStrategy;
            this.frameService = frameService;
        }
        RouterExtensions.prototype.navigate = function (commands, extras) {
            if (extras) {
                this.locationStrategy._setNavigationOptions(extras);
            }
            return this.router.navigate(commands, extras);
        };
        RouterExtensions.prototype.navigateByUrl = function (url, options) {
            if (options) {
                this.locationStrategy._setNavigationOptions(options);
            }
            return this.router.navigateByUrl(url);
        };
        RouterExtensions.prototype.back = function (backNavigationOptions) {
            if (backNavigationOptions) {
                this.backOutlets(backNavigationOptions);
            }
            else {
                this.locationStrategy.back();
            }
        };
        RouterExtensions.prototype.canGoBack = function (backNavigationOptions) {
            var _this = this;
            var canGoBack = true;
            if (backNavigationOptions) {
                var _a = this.findOutletsToBack(backNavigationOptions), outletsToBack = _a.outletsToBack, outlets = _a.outlets;
                if (outletsToBack.length !== outlets.length) {
                    NativeScriptDebug.routerError('No outlet found relative to activated route');
                }
                else {
                    outletsToBack.forEach(function (outletToBack) {
                        if (!_this.locationStrategy.canGoBack(outletToBack)) {
                            canGoBack = false;
                        }
                    });
                }
            }
            else {
                canGoBack = this.locationStrategy.canGoBack();
            }
            return canGoBack;
        };
        RouterExtensions.prototype.backToPreviousPage = function () {
            this.frameService.getFrame().goBack();
        };
        RouterExtensions.prototype.canGoBackToPreviousPage = function () {
            return this.frameService.getFrame().canGoBack();
        };
        RouterExtensions.prototype.backOutlets = function (options) {
            var _this = this;
            var _a = this.findOutletsToBack(options), outletsToBack = _a.outletsToBack, outlets = _a.outlets;
            if (outletsToBack.length !== outlets.length) {
                NativeScriptDebug.routerError('No outlet found relative to activated route');
            }
            else {
                outletsToBack.forEach(function (outletToBack) {
                    if (outletToBack.isPageNavigationBack) {
                        NativeScriptDebug.routerError('Attempted to call startGoBack while going back:');
                    }
                    else {
                        _this.locationStrategy.back(outletToBack);
                    }
                });
            }
        };
        // tslint:disable-next-line:max-line-length
        RouterExtensions.prototype.findOutletsToBack = function (options) {
            var outletsToBack = [];
            var rootRoute = this.router.routerState.root;
            var outlets = options.outlets;
            var relativeRoute = options.relativeTo || rootRoute;
            var relativeRouteOutlet = this.findOutletByRoute(relativeRoute);
            var isNSEmptyOutlet = relativeRouteOutlet && relativeRouteOutlet.isNSEmptyOutlet;
            // Lazy named outlet has added 'primary' inner NSEmptyOutlet child.
            // Take parent route when `relativeTo` option points to the outer named outlet.
            if (isNSEmptyOutlet && relativeRoute.outlet !== 'primary') {
                relativeRoute = relativeRoute.parent || relativeRoute;
            }
            var routesToMatch = outlets ? relativeRoute.children : [relativeRoute];
            outlets = outlets || [relativeRoute.outlet];
            var _loop_1 = function (index) {
                var currentRoute = routesToMatch[index];
                if (outlets.some(function (currentOutlet) { return currentOutlet === currentRoute.outlet; })) {
                    var outlet = this_1.findOutletByRoute(currentRoute);
                    if (outlet) {
                        outletsToBack.push(outlet);
                    }
                }
            };
            var this_1 = this;
            for (var index = 0; index < routesToMatch.length; index++) {
                _loop_1(index);
            }
            return { outletsToBack: outletsToBack, outlets: outlets };
        };
        RouterExtensions.prototype.findOutletByRoute = function (currentRoute) {
            var outlet;
            var currentRouteSnapshop = findTopActivatedRouteNodeForOutlet(currentRoute.snapshot);
            var outletKey = this.locationStrategy.getRouteFullPath(currentRouteSnapshop);
            outlet = this.locationStrategy.findOutlet(outletKey, currentRouteSnapshop);
            return outlet;
        };
        return RouterExtensions;
    }());
    RouterExtensions.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function RouterExtensions_Factory() { return new RouterExtensions(i0__namespace.ɵɵinject(i1__namespace.Router), i0__namespace.ɵɵinject(NSLocationStrategy), i0__namespace.ɵɵinject(FrameService)); }, token: RouterExtensions, providedIn: "root" });
    RouterExtensions.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    RouterExtensions.ctorParameters = function () { return [
        { type: i1.Router },
        { type: NSLocationStrategy },
        { type: FrameService }
    ]; };

    /**
     * The nsRouterLink directive lets you link to specific parts of your app.
     *
     * Consider the following route configuration:
     * ```
     * [{ path: "/user", component: UserCmp }]
     * ```
     *
     * When linking to this `User` route, you can write:
     *
     * ```
     * <a [nsRouterLink]="["/user"]">link to user component</a>
     * ```
     *
     * NSRouterLink expects the value to be an array of path segments, followed by the params
     * for that level of routing. For instance `["/team", {teamId: 1}, "user", {userId: 2}]`
     * means that we want to generate a link to `/team;teamId=1/user;userId=2`.
     *
     * The first segment name can be prepended with `/`, `./`, or `../`.
     * If the segment begins with `/`, the router will look up the route from the root of the app.
     * If the segment begins with `./`, or doesn"t begin with a slash, the router will
     * instead look in the current component"s children for the route.
     * And if the segment begins with `../`, the router will go up one level.
     */
    var NSRouterLink = /** @class */ (function () {
        function NSRouterLink(ngZone, router, navigator, route, el) {
            this.ngZone = ngZone;
            this.router = router;
            this.navigator = navigator;
            this.route = route;
            this.el = el;
            this.pageTransition = true;
            this.commands = [];
        }
        NSRouterLink.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.el.nativeElement.on('tap', function () {
                _this.ngZone.run(function () {
                    _this.onTap();
                });
            });
        };
        Object.defineProperty(NSRouterLink.prototype, "params", {
            set: function (data) {
                if (Array.isArray(data)) {
                    this.commands = data;
                }
                else {
                    this.commands = [data];
                }
            },
            enumerable: false,
            configurable: true
        });
        NSRouterLink.prototype.onTap = function () {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog("nsRouterLink.tapped: " + this.commands + " " + ("clear: " + this.clearHistory + " ") + ("transition: " + JSON.stringify(this.pageTransition) + " ") + ("duration: " + this.pageTransitionDuration));
            }
            var extras = this.getExtras();
            // this.navigator.navigateByUrl(this.urlTree, extras);
            this.navigator.navigate(this.commands, Object.assign(Object.assign({}, extras), { relativeTo: this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: attrBoolValue(this.preserveFragment) }));
        };
        NSRouterLink.prototype.getExtras = function () {
            var transition = this.getTransition();
            return {
                skipLocationChange: attrBoolValue(this.skipLocationChange),
                replaceUrl: attrBoolValue(this.replaceUrl),
                clearHistory: this.convertClearHistory(this.clearHistory),
                animated: transition.animated,
                transition: transition.transition,
            };
        };
        Object.defineProperty(NSRouterLink.prototype, "urlTree", {
            get: function () {
                var urlTree = this.router.createUrlTree(this.commands, {
                    relativeTo: this.route,
                    queryParams: this.queryParams,
                    fragment: this.fragment,
                    queryParamsHandling: this.queryParamsHandling,
                    preserveFragment: attrBoolValue(this.preserveFragment),
                });
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.routerLog("nsRouterLink urlTree created: " + urlTree);
                }
                return urlTree;
            },
            enumerable: false,
            configurable: true
        });
        NSRouterLink.prototype.convertClearHistory = function (value) {
            return value === true || value === 'true';
        };
        NSRouterLink.prototype.getTransition = function () {
            var transition;
            var animated;
            if (typeof this.pageTransition === 'boolean') {
                animated = this.pageTransition;
            }
            else if (typeof this.pageTransition === 'string') {
                if (this.pageTransition === 'none' || this.pageTransition === 'false') {
                    animated = false;
                }
                else {
                    animated = true;
                    transition = {
                        name: this.pageTransition,
                    };
                }
            }
            else {
                animated = true;
                transition = this.pageTransition;
            }
            var duration = +this.pageTransitionDuration;
            if (!isNaN(duration)) {
                transition = transition || {};
                transition.duration = duration;
            }
            return { animated: animated, transition: transition };
        };
        return NSRouterLink;
    }());
    NSRouterLink.decorators = [
        { type: i0.Directive, args: [{ selector: '[nsRouterLink]' },] }
    ];
    NSRouterLink.ctorParameters = function () { return [
        { type: i0.NgZone },
        { type: i1.Router },
        { type: RouterExtensions },
        { type: i1.ActivatedRoute },
        { type: i0.ElementRef }
    ]; };
    NSRouterLink.propDecorators = {
        target: [{ type: i0.Input }],
        queryParams: [{ type: i0.Input }],
        fragment: [{ type: i0.Input }],
        queryParamsHandling: [{ type: i0.Input }],
        preserveQueryParams: [{ type: i0.Input }],
        preserveFragment: [{ type: i0.Input }],
        skipLocationChange: [{ type: i0.Input }],
        replaceUrl: [{ type: i0.Input }],
        clearHistory: [{ type: i0.Input }],
        pageTransition: [{ type: i0.Input }],
        pageTransitionDuration: [{ type: i0.Input }],
        params: [{ type: i0.Input, args: ['nsRouterLink',] }]
    };
    function attrBoolValue(s) {
        return s === '' || !!s;
    }

    /* tslint:disable:forin */
    function containsTree(container, containee, exact) {
        if (exact) {
            return equalSegmentGroups(container.root, containee.root);
        }
        else {
            return containsSegmentGroup(container.root, containee.root);
        }
    }
    function equalSegmentGroups(container, containee) {
        if (!equalPath(container.segments, containee.segments)) {
            return false;
        }
        if (container.numberOfChildren !== containee.numberOfChildren) {
            return false;
        }
        for (var c in containee.children) {
            if (!container.children[c]) {
                return false;
            }
            if (!equalSegmentGroups(container.children[c], containee.children[c])) {
                return false;
            }
        }
        return true;
    }
    function containsSegmentGroup(container, containee) {
        return containsSegmentGroupHelper(container, containee, containee.segments);
    }
    function containsSegmentGroupHelper(container, containee, containeePaths) {
        if (container.segments.length > containeePaths.length) {
            var current = container.segments.slice(0, containeePaths.length);
            if (!equalPath(current, containeePaths)) {
                return false;
            }
            if (containee.hasChildren()) {
                return false;
            }
            return true;
        }
        else if (container.segments.length === containeePaths.length) {
            if (!equalPath(container.segments, containeePaths)) {
                return false;
            }
            for (var c in containee.children) {
                if (!container.children[c]) {
                    return false;
                }
                if (!containsSegmentGroup(container.children[c], containee.children[c])) {
                    return false;
                }
            }
            return true;
        }
        else {
            var current = containeePaths.slice(0, container.segments.length);
            var next = containeePaths.slice(container.segments.length);
            if (!equalPath(container.segments, current)) {
                return false;
            }
            if (!container.children[i1.PRIMARY_OUTLET]) {
                return false;
            }
            return containsSegmentGroupHelper(container.children[i1.PRIMARY_OUTLET], containee, next);
        }
    }
    function equalPath(a, b) {
        if (a.length !== b.length) {
            return false;
        }
        for (var i = 0; i < a.length; ++i) {
            if (a[i].path !== b[i].path) {
                return false;
            }
        }
        return true;
    }

    /**
     * The NSRouterLinkActive directive lets you add a CSS class to an element when the link"s route
     * becomes active.
     *
     * Consider the following example:
     *
     * ```
     * <a [nsRouterLink]="/user/bob" [nsRouterLinkActive]="active-link">Bob</a>
     * ```
     *
     * When the url is either "/user" or "/user/bob", the active-link class will
     * be added to the component. If the url changes, the class will be removed.
     *
     * You can set more than one class, as follows:
     *
     * ```
     * <a [nsRouterLink]="/user/bob" [nsRouterLinkActive]="class1 class2">Bob</a>
     * <a [nsRouterLink]="/user/bob" [nsRouterLinkActive]="["class1", "class2"]">Bob</a>
     * ```
     *
     * You can configure NSRouterLinkActive by passing `exact: true`. This will add the
     * classes only when the url matches the link exactly.
     *
     * ```
     * <a [nsRouterLink]="/user/bob" [nsRouterLinkActive]="active-link"
     * [nsRouterLinkActiveOptions]="{exact: true}">Bob</a>
     * ```
     *
     * Finally, you can apply the NSRouterLinkActive directive to an ancestor of a RouterLink.
     *
     * ```
     * <div [nsRouterLinkActive]="active-link" [nsRouterLinkActiveOptions]="{exact: true}">
     *   <a [nsRouterLink]="/user/jim">Jim</a>
     *   <a [nsRouterLink]="/user/bob">Bob</a>
     * </div>
     * ```
     *
     * This will set the active-link class on the div tag if the url is either "/user/jim" or
     * "/user/bob".
     *
     * @stable
     */
    var NSRouterLinkActive = /** @class */ (function () {
        function NSRouterLinkActive(router, element, renderer) {
            var _this = this;
            this.router = router;
            this.element = element;
            this.renderer = renderer;
            this.classes = [];
            this.active = false;
            this.nsRouterLinkActiveOptions = { exact: false };
            this.subscription = router.events.subscribe(function (s) {
                if (s instanceof i1.NavigationEnd) {
                    _this.update();
                }
            });
        }
        Object.defineProperty(NSRouterLinkActive.prototype, "isActive", {
            get: function () {
                return this.active;
            },
            enumerable: false,
            configurable: true
        });
        NSRouterLinkActive.prototype.ngAfterContentInit = function () {
            var _this = this;
            this.links.changes.subscribe(function () { return _this.update(); });
            this.update();
        };
        Object.defineProperty(NSRouterLinkActive.prototype, "nsRouterLinkActive", {
            set: function (data) {
                if (Array.isArray(data)) {
                    this.classes = data;
                }
                else {
                    this.classes = data.split(' ');
                }
            },
            enumerable: false,
            configurable: true
        });
        NSRouterLinkActive.prototype.ngOnChanges = function (_) {
            this.update();
        };
        NSRouterLinkActive.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        NSRouterLinkActive.prototype.update = function () {
            var _this = this;
            if (!this.links) {
                return;
            }
            var hasActiveLinks = this.hasActiveLinks();
            // react only when status has changed to prevent unnecessary dom updates
            if (this.active !== hasActiveLinks) {
                var currentUrlTree = this.router.parseUrl(this.router.url);
                var isActiveLinks_1 = this.reduceList(currentUrlTree, this.links);
                this.classes.forEach(function (c) {
                    if (isActiveLinks_1) {
                        _this.renderer.addClass(_this.element.nativeElement, c);
                    }
                    else {
                        _this.renderer.removeClass(_this.element.nativeElement, c);
                    }
                });
            }
            Promise.resolve(hasActiveLinks).then(function (active) { return (_this.active = active); });
        };
        NSRouterLinkActive.prototype.reduceList = function (currentUrlTree, q) {
            var _this = this;
            return q.reduce(function (res, link) {
                return res || containsTree(currentUrlTree, link.urlTree, _this.nsRouterLinkActiveOptions.exact);
            }, false);
        };
        NSRouterLinkActive.prototype.isLinkActive = function (router) {
            var _this = this;
            return function (link) { return router.isActive(link.urlTree, _this.nsRouterLinkActiveOptions.exact); };
        };
        NSRouterLinkActive.prototype.hasActiveLinks = function () {
            return this.links.some(this.isLinkActive(this.router));
        };
        return NSRouterLinkActive;
    }());
    NSRouterLinkActive.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[nsRouterLinkActive]',
                    exportAs: 'routerLinkActive',
                },] }
    ];
    NSRouterLinkActive.ctorParameters = function () { return [
        { type: i1.Router },
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };
    NSRouterLinkActive.propDecorators = {
        links: [{ type: i0.ContentChildren, args: [NSRouterLink,] }],
        nsRouterLinkActiveOptions: [{ type: i0.Input }],
        nsRouterLinkActive: [{ type: i0.Input, args: ['nsRouterLinkActive',] }]
    };

    var PageRoute = /** @class */ (function () {
        function PageRoute(startRoute) {
            this.activatedRoute = new rxjs.BehaviorSubject(startRoute);
        }
        return PageRoute;
    }());
    var DestructibleInjector = /** @class */ (function () {
        function DestructibleInjector(destructableProviders, parent) {
            this.destructableProviders = destructableProviders;
            this.parent = parent;
            this.refs = new Set();
        }
        DestructibleInjector.prototype.get = function (token, notFoundValue, flags) {
            var ref = this.parent.get(token, notFoundValue, flags);
            if (this.destructableProviders.has(token)) {
                this.refs.add(ref);
            }
            return ref;
        };
        DestructibleInjector.prototype.destroy = function () {
            this.refs.forEach(function (ref) {
                if (ref.ngOnDestroy instanceof Function) {
                    ref.ngOnDestroy();
                }
            });
            this.refs.clear();
        };
        return DestructibleInjector;
    }());
    var routeToString = function (activatedRoute) {
        return activatedRoute.pathFromRoot.join('->');
    };
    var ɵ0 = routeToString;
    registerElement('page-router-outlet', function () { return core.Frame; });
    // eslint-disable-next-line @angular-eslint/directive-selector
    // eslint-disable-next-line @angular-eslint/directive-class-suffix
    var PageRouterOutlet = /** @class */ (function () {
        function PageRouterOutlet(parentContexts, location, name, actionBarVisibility, isEmptyOutlet, locationStrategy, componentFactoryResolver, resolver, changeDetector, pageFactory, routeReuseStrategy, ngZone, elRef, viewUtil) {
            this.parentContexts = parentContexts;
            this.location = location;
            this.locationStrategy = locationStrategy;
            this.componentFactoryResolver = componentFactoryResolver;
            this.resolver = resolver;
            this.changeDetector = changeDetector;
            this.pageFactory = pageFactory;
            this.routeReuseStrategy = routeReuseStrategy;
            this.ngZone = ngZone;
            // tslint:disable-line:directive-class-suffix
            this.activated = null;
            this._activatedRoute = null;
            // eslint-disable-next-line @angular-eslint/no-output-rename
            this.activateEvents = new i0.EventEmitter(); // tslint:disable-line:no-output-rename
            // eslint-disable-next-line @angular-eslint/no-output-rename
            this.deactivateEvents = new i0.EventEmitter(); // tslint:disable-line:no-output-rename
            this.isEmptyOutlet = isEmptyOutlet;
            this.frame = elRef.nativeElement;
            this.setActionBarVisibility(actionBarVisibility);
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog("PageRouterOutlet.constructor frame: " + this.frame);
            }
            this.name = name || i1.PRIMARY_OUTLET;
            parentContexts.onChildOutletCreated(this.name, this);
            this.viewUtil = viewUtil;
            this.detachedLoaderFactory = resolver.resolveComponentFactory(DetachedLoader);
        }
        Object.defineProperty(PageRouterOutlet.prototype, "locationInjector", {
            /** @deprecated from Angular since v4 */
            get: function () {
                return this.location.injector;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PageRouterOutlet.prototype, "locationFactoryResolver", {
            /** @deprecated from Angular since v4 */
            get: function () {
                return this.resolver;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PageRouterOutlet.prototype, "isActivated", {
            get: function () {
                return !!this.activated;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PageRouterOutlet.prototype, "component", {
            get: function () {
                if (!this.activated) {
                    if (NativeScriptDebug.isLogEnabled()) {
                        NativeScriptDebug.routerLog('Outlet is not activated');
                    }
                    return;
                }
                return this.activated.instance;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PageRouterOutlet.prototype, "activatedRoute", {
            get: function () {
                if (!this.activated) {
                    if (NativeScriptDebug.isLogEnabled()) {
                        NativeScriptDebug.routerLog('Outlet is not activated');
                    }
                    return;
                }
                return this._activatedRoute;
            },
            enumerable: false,
            configurable: true
        });
        PageRouterOutlet.prototype.setActionBarVisibility = function (actionBarVisibility) {
            switch (actionBarVisibility) {
                case 'always':
                case 'never':
                    this.frame.actionBarVisibility = actionBarVisibility;
                    return;
                default:
                    this.frame.actionBarVisibility = 'auto';
            }
        };
        PageRouterOutlet.prototype.ngOnDestroy = function () {
            var _this = this;
            // Clear accumulated modal view page cache when page-router-outlet
            // destroyed on modal view closing
            this.parentContexts.onChildOutletDestroyed(this.name);
            if (this.outlet) {
                this.outlet.outletKeys.forEach(function (key) {
                    _this.routeReuseStrategy.clearModalCache(key);
                });
                this.locationStrategy.clearOutlet(this.frame);
            }
            else {
                NativeScriptDebug.routerLog('PageRouterOutlet.ngOnDestroy: no outlet available for page-router-outlet');
            }
            if (this.isActivated) {
                var c = this.activated.instance;
                this.activated.hostView.detach();
                destroyComponentRef(this.activated);
                this.deactivateEvents.emit(c);
                this.activated = null;
            }
        };
        PageRouterOutlet.prototype.deactivate = function () {
            if (!this.outlet || !this.outlet.isPageNavigationBack) {
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.routerLog('Currently not in page back navigation - component should be detached instead of deactivated.');
                }
                return;
            }
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('PageRouterOutlet.deactivate() while going back - should destroy');
            }
            if (!this.isActivated) {
                return;
            }
            var c = this.activated.instance;
            destroyComponentRef(this.activated);
            this.activated = null;
            this._activatedRoute = null;
            this.deactivateEvents.emit(c);
        };
        /**
         * Called when the `RouteReuseStrategy` instructs to detach the subtree
         */
        PageRouterOutlet.prototype.detach = function () {
            if (!this.isActivated) {
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.routerLog('Outlet is not activated');
                }
                return;
            }
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog("PageRouterOutlet.detach() - " + routeToString(this._activatedRoute));
            }
            // Detach from ChangeDetection
            this.activated.hostView.detach();
            var component = this.activated;
            this.activated = null;
            this._activatedRoute = null;
            return component;
        };
        /**
         * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
         */
        PageRouterOutlet.prototype.attach = function (ref, activatedRoute) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog("PageRouterOutlet.attach() - " + routeToString(activatedRoute));
            }
            this.activated = ref;
            // reattach to ChangeDetection
            this.activated.hostView.markForCheck();
            this.activated.hostView.reattach();
            this._activatedRoute = activatedRoute;
            this.markActivatedRoute(activatedRoute);
            this.locationStrategy._finishBackPageNavigation(this.frame);
        };
        /**
         * Called by the Router to instantiate a new component during the commit phase of a navigation.
         * This method in turn is responsible for calling the `routerOnActivate` hook of its child.
         */
        PageRouterOutlet.prototype.activateWith = function (activatedRoute, resolver) {
            this.outlet = this.outlet || this.getOutlet(activatedRoute.snapshot);
            if (!this.outlet) {
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.routerError('No outlet found relative to activated route');
                }
                return;
            }
            this.outlet.isNSEmptyOutlet = this.isEmptyOutlet;
            this.locationStrategy.updateOutletFrame(this.outlet, this.frame, this.isEmptyOutlet);
            if (this.outlet && this.outlet.isPageNavigationBack) {
                if (NativeScriptDebug.isLogEnabled()) {
                    NativeScriptDebug.routerLog('Currently in page back navigation - component should be reattached instead of activated.');
                }
                this.locationStrategy._finishBackPageNavigation(this.frame);
            }
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog("PageRouterOutlet.activateWith() - " + routeToString(activatedRoute));
            }
            this._activatedRoute = activatedRoute;
            this.markActivatedRoute(activatedRoute);
            resolver = resolver || this.resolver;
            this.activateOnGoForward(activatedRoute, resolver);
            this.activateEvents.emit(this.activated.instance);
        };
        PageRouterOutlet.prototype.activateOnGoForward = function (activatedRoute, loadedResolver) {
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('PageRouterOutlet.activate() forward navigation - ' + 'create detached loader in the loader container');
            }
            var factory = this.getComponentFactory(activatedRoute, loadedResolver);
            var page = this.pageFactory({
                isNavigation: true,
                componentType: factory.componentType,
            });
            var destructables = new Set([]);
            var injector = i0.Injector.create({
                providers: [
                    { provide: core.Page, useValue: page },
                    { provide: core.Frame, useValue: this.frame },
                    { provide: PageRoute, useValue: new PageRoute(activatedRoute) },
                    { provide: i1.ActivatedRoute, useValue: activatedRoute },
                    { provide: i1.ChildrenOutletContexts, useValue: this.parentContexts.getOrCreateContext(this.name).children },
                    { provide: PageService, useClass: PageService },
                ],
                parent: this.location.injector,
            });
            var childInjector = new DestructibleInjector(destructables, injector);
            var loaderRef = this.location.createComponent(this.detachedLoaderFactory, this.location.length, childInjector, []);
            loaderRef.onDestroy(function () { return childInjector.destroy(); });
            this.changeDetector.markForCheck();
            this.activated = loaderRef.instance.loadWithFactory(factory);
            this.activated.changeDetectorRef.detectChanges();
            this.loadComponentInPage(page, this.activated, { activatedRoute: activatedRoute });
            this.activated[loaderRefSymbol] = loaderRef;
        };
        PageRouterOutlet.prototype.loadComponentInPage = function (page, componentRef, navigationContext) {
            var _this = this;
            // Component loaded. Find its root native view.
            var componentView = componentRef.location.nativeElement;
            // Remove it from original native parent.
            this.viewUtil.removeChild(componentView.parent, componentView);
            // Add it to the new page
            this.viewUtil.appendChild(page, componentView);
            var navigatedFromCallback = global.Zone.current.wrap(function (args) {
                if (args.isBackNavigation) {
                    _this.locationStrategy._beginBackPageNavigation(_this.frame);
                    _this.locationStrategy.back(null, _this.frame);
                }
            });
            // TODO: experiment with using NgZone instead of global above
            // const navigatedFromCallback = (args: NavigatedData) => {
            // 	if (args.isBackNavigation) {
            //     this.ngZone.run(() => {
            //       this.locationStrategy._beginBackPageNavigation(this.frame);
            //       this.locationStrategy.back(null, this.frame);
            //     });
            // 	}
            // };
            page.on(core.Page.navigatedFromEvent, navigatedFromCallback);
            componentRef.onDestroy(function () {
                if (page) {
                    page.off(core.Page.navigatedFromEvent, navigatedFromCallback);
                    page = null;
                }
            });
            var navOptions = this.locationStrategy._beginPageNavigation(this.frame);
            // Clear refCache if navigation with clearHistory
            if (navOptions.clearHistory) {
                var clearCallback = function () { return setTimeout(function () {
                    if (_this.outlet) {
                        _this.routeReuseStrategy.clearCache(_this.outlet.outletKeys[0]);
                    }
                }); };
                page.once(core.Page.navigatedToEvent, clearCallback);
            }
            this.frame.navigate({
                create: function () {
                    return page;
                },
                context: navigationContext,
                clearHistory: navOptions.clearHistory,
                animated: navOptions.animated,
                transition: navOptions.transition,
            });
        };
        // Find and mark the top activated route as an activated one.
        // In ns-location-strategy we are reusing components only if their corresponing routes
        // are marked as activated from this method.
        PageRouterOutlet.prototype.markActivatedRoute = function (activatedRoute) {
            var queue = [];
            queue.push(activatedRoute.snapshot);
            var currentRoute = queue.shift();
            while (currentRoute) {
                currentRoute.children.forEach(function (childRoute) {
                    queue.push(childRoute);
                });
                var topActivatedRoute = findTopActivatedRouteNodeForOutlet(currentRoute);
                var outletKey = this.locationStrategy.getRouteFullPath(topActivatedRoute);
                var outlet = this.locationStrategy.findOutlet(outletKey, topActivatedRoute);
                if (outlet && outlet.frames.length) {
                    topActivatedRoute[pageRouterActivatedSymbol] = true;
                    if (NativeScriptDebug.isLogEnabled()) {
                        NativeScriptDebug.routerLog('Activated route marked as page: ' + routeToString(topActivatedRoute));
                    }
                }
                currentRoute = queue.shift();
            }
        };
        PageRouterOutlet.prototype.getComponentFactory = function (activatedRoute, loadedResolver) {
            var component = activatedRoute.routeConfig.component;
            return loadedResolver ? loadedResolver.resolveComponentFactory(component) : this.componentFactoryResolver.resolveComponentFactory(component);
        };
        PageRouterOutlet.prototype.getOutlet = function (activatedRouteSnapshot) {
            var topActivatedRoute = findTopActivatedRouteNodeForOutlet(activatedRouteSnapshot);
            var outletKey = this.locationStrategy.getRouteFullPath(topActivatedRoute);
            var outlet = this.locationStrategy.findOutlet(outletKey, topActivatedRoute);
            // Named lazy loaded outlet.
            if (!outlet && this.isEmptyOutlet) {
                var parentOutletKey = this.locationStrategy.getRouteFullPath(topActivatedRoute.parent);
                outlet = this.locationStrategy.findOutlet(parentOutletKey, topActivatedRoute.parent);
                if (outlet) {
                    outlet.outletKeys.push(outletKey);
                }
            }
            return outlet;
        };
        return PageRouterOutlet;
    }());
    PageRouterOutlet.decorators = [
        { type: i0.Directive, args: [{ selector: 'page-router-outlet' }, // tslint:disable-line:directive-selector
            ] }
    ];
    PageRouterOutlet.ctorParameters = function () { return [
        { type: i1.ChildrenOutletContexts },
        { type: i0.ViewContainerRef },
        { type: String, decorators: [{ type: i0.Attribute, args: ['name',] }] },
        { type: String, decorators: [{ type: i0.Attribute, args: ['actionBarVisibility',] }] },
        { type: Boolean, decorators: [{ type: i0.Attribute, args: ['isEmptyOutlet',] }] },
        { type: NSLocationStrategy },
        { type: i0.ComponentFactoryResolver },
        { type: i0.ComponentFactoryResolver },
        { type: i0.ChangeDetectorRef },
        { type: undefined, decorators: [{ type: i0.Inject, args: [PAGE_FACTORY,] }] },
        { type: NSRouteReuseStrategy },
        { type: i0.NgZone },
        { type: i0.ElementRef },
        { type: ViewUtil }
    ]; };
    PageRouterOutlet.propDecorators = {
        activateEvents: [{ type: i0.Output, args: ['activate',] }],
        deactivateEvents: [{ type: i0.Output, args: ['deactivate',] }]
    };
    __decorate([
        core.profile
    ], PageRouterOutlet.prototype, "activateWith", null);
    __decorate([
        core.profile
    ], PageRouterOutlet.prototype, "loadComponentInPage", null);

    var NativescriptPlatformLocation = /** @class */ (function (_super) {
        __extends(NativescriptPlatformLocation, _super);
        function NativescriptPlatformLocation(locationStrategy) {
            var _this = _super.call(this) || this;
            _this.locationStrategy = locationStrategy;
            if (NativeScriptDebug.isLogEnabled()) {
                NativeScriptDebug.routerLog('NativescriptPlatformLocation.constructor()');
            }
            return _this;
        }
        NativescriptPlatformLocation.prototype.getState = function () {
            return undefined;
        };
        NativescriptPlatformLocation.prototype.getBaseHrefFromDOM = function () {
            return '/';
        };
        NativescriptPlatformLocation.prototype.onPopState = function (fn) {
            this.locationStrategy.onPopState(fn);
            return function () { };
        };
        NativescriptPlatformLocation.prototype.onHashChange = function (_fn) {
            return function () { };
        };
        Object.defineProperty(NativescriptPlatformLocation.prototype, "search", {
            get: function () {
                return '';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NativescriptPlatformLocation.prototype, "hash", {
            get: function () {
                return '';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NativescriptPlatformLocation.prototype, "pathname", {
            get: function () {
                return this.locationStrategy.path();
            },
            set: function (_newPath) {
                throw new Error('NativescriptPlatformLocation set pathname - not implemented');
            },
            enumerable: false,
            configurable: true
        });
        NativescriptPlatformLocation.prototype.pushState = function (state, title, url) {
            this.locationStrategy.pushState(state, title, url, null);
        };
        NativescriptPlatformLocation.prototype.replaceState = function (state, title, url) {
            this.locationStrategy.replaceState(state, title, url, null);
        };
        NativescriptPlatformLocation.prototype.forward = function () {
            throw new Error('NativescriptPlatformLocation.forward() - not implemented');
        };
        NativescriptPlatformLocation.prototype.back = function () {
            this.locationStrategy.back();
        };
        return NativescriptPlatformLocation;
    }(common.PlatformLocation));
    NativescriptPlatformLocation.decorators = [
        { type: i0.Injectable }
    ];
    NativescriptPlatformLocation.ctorParameters = function () { return [
        { type: NSLocationStrategy }
    ]; };

    var NSEmptyOutletComponent = /** @class */ (function () {
        function NSEmptyOutletComponent(page) {
            var _this = this;
            this.page = page;
            if (this.page) {
                this.page.actionBarHidden = true;
                this.page.on('loaded', function () {
                    if (_this.pageRouterOutlet && _this.page.frame) {
                        _this.pageRouterOutlet.setActionBarVisibility(_this.page.frame.actionBarVisibility);
                    }
                });
            }
        }
        return NSEmptyOutletComponent;
    }());
    NSEmptyOutletComponent.decorators = [
        { type: i0.Component, args: [{
                    // tslint:disable-next-line:component-selector
                    selector: 'ns-empty-outlet',
                    template: "<page-router-outlet isEmptyOutlet='true'></page-router-outlet>"
                },] }
    ];
    NSEmptyOutletComponent.ctorParameters = function () { return [
        { type: core.Page }
    ]; };
    NSEmptyOutletComponent.propDecorators = {
        pageRouterOutlet: [{ type: i0.ViewChild, args: [PageRouterOutlet, { read: PageRouterOutlet, static: false },] }]
    };

    function provideLocationStrategy(locationStrategy, frameService, startPath) {
        return locationStrategy ? locationStrategy : new NSLocationStrategy(frameService, startPath);
    }
    var NativeScriptRouterModule = /** @class */ (function () {
        function NativeScriptRouterModule() {
        }
        NativeScriptRouterModule.forRoot = function (routes, config) {
            return {
                ngModule: NativeScriptRouterModule,
                providers: __spreadArray(__spreadArray([], __read(i1.RouterModule.forRoot(routes, config).providers)), [
                    {
                        provide: NSLocationStrategy,
                        useFactory: provideLocationStrategy,
                        deps: [[NSLocationStrategy, new i0.Optional(), new i0.SkipSelf()], FrameService, [new i0.Optional(), START_PATH]],
                    },
                    { provide: common.LocationStrategy, useExisting: NSLocationStrategy },
                    NativescriptPlatformLocation,
                    { provide: common.PlatformLocation, useExisting: NativescriptPlatformLocation },
                    RouterExtensions,
                    NSRouteReuseStrategy,
                    { provide: i1.RouteReuseStrategy, useExisting: NSRouteReuseStrategy },
                ]),
            };
        };
        NativeScriptRouterModule.forChild = function (routes) {
            return { ngModule: NativeScriptRouterModule, providers: i1.RouterModule.forChild(routes).providers };
        };
        return NativeScriptRouterModule;
    }());
    NativeScriptRouterModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [NSRouterLink, NSRouterLinkActive, PageRouterOutlet, NSEmptyOutletComponent],
                    entryComponents: [NSEmptyOutletComponent],
                    imports: [i1.RouterModule, NativeScriptCommonModule],
                    exports: [i1.RouterModule, NSRouterLink, NSRouterLinkActive, PageRouterOutlet, NSEmptyOutletComponent],
                    schemas: [i0.NO_ERRORS_SCHEMA],
                },] }
    ];

    /* eslint-disable @typescript-eslint/ban-types */
    var currentRafId = 1;
    function noop() { }
    /**
     * An injectable service for executing work inside or outside of the Angular zone.
     *
     * The most common use of this service is to optimize performance when starting a work consisting of
     * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
     * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks
     * can reenter the Angular zone via {@link #run}.
     *
     * <!-- TODO: add/fix links to:
     *   - docs explaining zones and the use of zones in Angular and change-detection
     *   - link to runOutsideAngular/run (throughout this file!)
     *   -->
     *
     * @usageNotes
     * ### Example
     *
     * ```
     * import {Component, NgZone} from '@angular/core';
     * import {NgIf} from '@angular/common';
     *
     * @Component({
     *   selector: 'ng-zone-demo',
     *   template: `
     *     <h2>Demo: NgZone</h2>
     *
     *     <p>Progress: {{progress}}%</p>
     *     <p *ngIf="progress >= 100">Done processing {{label}} of Angular zone!</p>
     *
     *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
     *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
     *   `,
     * })
     * export class NgZoneDemo {
     *   progress: number = 0;
     *   label: string;
     *
     *   constructor(private _ngZone: NgZone) {}
     *
     *   // Loop inside the Angular zone
     *   // so the UI DOES refresh after each setTimeout cycle
     *   processWithinAngularZone() {
     *     this.label = 'inside';
     *     this.progress = 0;
     *     this._increaseProgress(() => console.log('Inside Done!'));
     *   }
     *
     *   // Loop outside of the Angular zone
     *   // so the UI DOES NOT refresh after each setTimeout cycle
     *   processOutsideOfAngularZone() {
     *     this.label = 'outside';
     *     this.progress = 0;
     *     this._ngZone.runOutsideAngular(() => {
     *       this._increaseProgress(() => {
     *         // reenter the Angular zone and display done
     *         this._ngZone.run(() => { console.log('Outside Done!'); });
     *       });
     *     });
     *   }
     *
     *   _increaseProgress(doneCallback: () => void) {
     *     this.progress += 1;
     *     console.log(`Current progress: ${this.progress}%`);
     *
     *     if (this.progress < 100) {
     *       window.setTimeout(() => this._increaseProgress(doneCallback), 10);
     *     } else {
     *       doneCallback();
     *     }
     *   }
     * }
     * ```
     *
     * @publicApi
     */
    var NativeScriptNgZone = /** @class */ (function () {
        function NativeScriptNgZone(_a) {
            var _b = _a === void 0 ? {} : _a, _c = _b.enableLongStackTrace, enableLongStackTrace = _c === void 0 ? i0.isDevMode() : _c, _d = _b.shouldCoalesceEventChangeDetection, shouldCoalesceEventChangeDetection = _d === void 0 ? true : _d, _e = _b.shouldCoalesceRunChangeDetection, shouldCoalesceRunChangeDetection = _e === void 0 ? true : _e;
            this.hasPendingMacrotasks = false;
            this.hasPendingMicrotasks = false;
            /**
             * Whether there are no outstanding microtasks or macrotasks.
             */
            this.isStable = true;
            /**
             * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
             */
            this.onUnstable = new i0.EventEmitter(false);
            /**
             * Notifies when there is no more microtasks enqueued in the current VM Turn.
             * This is a hint for Angular to do change detection, which may enqueue more microtasks.
             * For this reason this event can fire multiple times per VM Turn.
             */
            this.onMicrotaskEmpty = new i0.EventEmitter(false);
            /**
             * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
             * implies we are about to relinquish VM turn.
             * This event gets called just once.
             */
            this.onStable = new i0.EventEmitter(false);
            /**
             * Notifies that an error has been delivered.
             */
            this.onError = new i0.EventEmitter(false);
            if (typeof Zone == 'undefined') {
                throw new Error("In this configuration Angular requires Zone.js");
            }
            Zone.assertZonePatched();
            var self = this;
            self._nesting = 0;
            self._outer = self._inner = Zone.current;
            if (Zone['TaskTrackingZoneSpec']) {
                self._inner = self._inner.fork(new Zone['TaskTrackingZoneSpec']());
            }
            if (enableLongStackTrace && Zone['longStackTraceZoneSpec']) {
                self._inner = self._inner.fork(Zone['longStackTraceZoneSpec']);
            }
            // if shouldCoalesceRunChangeDetection is true, all tasks including event tasks will be
            // coalesced, so shouldCoalesceEventChangeDetection option is not necessary and can be skipped.
            self.shouldCoalesceEventChangeDetection = !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;
            self.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;
            self.lastRequestAnimationFrameId = -1;
            self.nativeRequestAnimationFrame = function (cb) {
                var nativeDispatchToMainThread = core.Utils[Zone.__symbol__('dispatchToMainThread')] || core.Utils.dispatchToMainThread;
                nativeDispatchToMainThread(cb);
                return currentRafId++;
            };
            forkInnerZoneWithAngularBehavior(self);
        }
        NativeScriptNgZone.isInAngularZone = function () {
            return Zone.current.get('isAngularZone') === true;
        };
        NativeScriptNgZone.assertInAngularZone = function () {
            if (!i0.NgZone.isInAngularZone()) {
                throw new Error('Expected to be in Angular Zone, but it is not!');
            }
        };
        NativeScriptNgZone.assertNotInAngularZone = function () {
            if (i0.NgZone.isInAngularZone()) {
                throw new Error('Expected to not be in Angular Zone, but it is!');
            }
        };
        /**
         * Executes the `fn` function synchronously within the Angular zone and returns value returned by
         * the function.
         *
         * Running functions via `run` allows you to reenter Angular zone from a task that was executed
         * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
         *
         * Any future tasks or microtasks scheduled from within this function will continue executing from
         * within the Angular zone.
         *
         * If a synchronous error happens it will be rethrown and not reported via `onError`.
         */
        NativeScriptNgZone.prototype.run = function (fn, applyThis, applyArgs) {
            return this._inner.run(fn, applyThis, applyArgs);
        };
        /**
         * Executes the `fn` function synchronously within the Angular zone as a task and returns value
         * returned by the function.
         *
         * Running functions via `run` allows you to reenter Angular zone from a task that was executed
         * outside of the Angular zone (typically started via {@link #runOutsideAngular}).
         *
         * Any future tasks or microtasks scheduled from within this function will continue executing from
         * within the Angular zone.
         *
         * If a synchronous error happens it will be rethrown and not reported via `onError`.
         */
        NativeScriptNgZone.prototype.runTask = function (fn, applyThis, applyArgs, name) {
            var zone = this._inner;
            var task = zone.scheduleEventTask('NgZoneEvent: ' + name, fn, EMPTY_PAYLOAD, noop, noop);
            try {
                return zone.runTask(task, applyThis, applyArgs);
            }
            finally {
                zone.cancelTask(task);
            }
        };
        /**
         * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
         * rethrown.
         */
        NativeScriptNgZone.prototype.runGuarded = function (fn, applyThis, applyArgs) {
            return this._inner.runGuarded(fn, applyThis, applyArgs);
        };
        /**
         * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
         * the function.
         *
         * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do
         * work that
         * doesn't trigger Angular change-detection or is subject to Angular's error handling.
         *
         * Any future tasks or microtasks scheduled from within this function will continue executing from
         * outside of the Angular zone.
         *
         * Use {@link #run} to reenter the Angular zone and do work that updates the application model.
         */
        NativeScriptNgZone.prototype.runOutsideAngular = function (fn) {
            return this._outer.run(fn);
        };
        return NativeScriptNgZone;
    }());
    var EMPTY_PAYLOAD = {};
    function checkStable(zone) {
        // TODO: @JiaLiPassion, should check zone.isCheckStableRunning to prevent
        // re-entry. The case is:
        //
        // @Component({...})
        // export class AppComponent {
        // constructor(private ngZone: NgZone) {
        //   this.ngZone.onStable.subscribe(() => {
        //     this.ngZone.run(() => console.log('stable'););
        //   });
        // }
        //
        // The onStable subscriber run another function inside ngZone
        // which causes `checkStable()` re-entry.
        // But this fix causes some issues in g3, so this fix will be
        // launched in another PR.
        if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {
            try {
                zone._nesting++;
                zone.onMicrotaskEmpty.emit(null);
            }
            finally {
                zone._nesting--;
                if (!zone.hasPendingMicrotasks) {
                    try {
                        zone.runOutsideAngular(function () { return zone.onStable.emit(null); });
                    }
                    finally {
                        zone.isStable = true;
                    }
                }
            }
        }
    }
    function delayChangeDetectionForEvents(zone) {
        /**
         * We also need to check _nesting here
         * Consider the following case with shouldCoalesceRunChangeDetection = true
         *
         * ngZone.run(() => {});
         * ngZone.run(() => {});
         *
         * We want the two `ngZone.run()` only trigger one change detection
         * when shouldCoalesceRunChangeDetection is true.
         * And because in this case, change detection run in async way(requestAnimationFrame),
         * so we also need to check the _nesting here to prevent multiple
         * change detections.
         */
        if (zone.isCheckStableRunning || zone.lastRequestAnimationFrameId !== -1) {
            return;
        }
        zone.lastRequestAnimationFrameId = zone.nativeRequestAnimationFrame.call(global, function () {
            // This is a work around for https://github.com/angular/angular/issues/36839.
            // The core issue is that when event coalescing is enabled it is possible for microtasks
            // to get flushed too early (As is the case with `Promise.then`) between the
            // coalescing eventTasks.
            //
            // To workaround this we schedule a "fake" eventTask before we process the
            // coalescing eventTasks. The benefit of this is that the "fake" container eventTask
            //  will prevent the microtasks queue from getting drained in between the coalescing
            // eventTask execution.
            if (!zone.fakeTopEventTask) {
                zone.fakeTopEventTask = Zone.root.scheduleEventTask('fakeTopEventTask', function () {
                    zone.lastRequestAnimationFrameId = -1;
                    updateMicroTaskStatus(zone);
                    zone.isCheckStableRunning = true;
                    checkStable(zone);
                    zone.isCheckStableRunning = false;
                }, undefined, function () { }, function () { });
            }
            zone.fakeTopEventTask.invoke();
        });
        updateMicroTaskStatus(zone);
    }
    function forkInnerZoneWithAngularBehavior(zone) {
        var delayChangeDetectionForEventsDelegate = function () {
            delayChangeDetectionForEvents(zone);
        };
        zone._inner = zone._inner.fork({
            name: 'angular',
            properties: { isAngularZone: true },
            onInvokeTask: function (delegate, current, target, task, applyThis, applyArgs) {
                try {
                    onEnter(zone);
                    return delegate.invokeTask(target, task, applyThis, applyArgs);
                }
                finally {
                    if ((zone.shouldCoalesceEventChangeDetection && task.type === 'eventTask') || zone.shouldCoalesceRunChangeDetection || !core.Utils.isMainThread()) {
                        delayChangeDetectionForEventsDelegate();
                    }
                    onLeave(zone);
                }
            },
            onInvoke: function (delegate, current, target, callback, applyThis, applyArgs, source) {
                try {
                    onEnter(zone);
                    return delegate.invoke(target, callback, applyThis, applyArgs, source);
                }
                finally {
                    if (zone.shouldCoalesceRunChangeDetection || !core.Utils.isMainThread()) {
                        delayChangeDetectionForEventsDelegate();
                    }
                    onLeave(zone);
                }
            },
            onHasTask: function (delegate, current, target, hasTaskState) {
                delegate.hasTask(target, hasTaskState);
                if (current === target) {
                    // We are only interested in hasTask events which originate from our zone
                    // (A child hasTask event is not interesting to us)
                    if (hasTaskState.change == 'microTask') {
                        zone._hasPendingMicrotasks = hasTaskState.microTask;
                        updateMicroTaskStatus(zone);
                        checkStable(zone);
                    }
                    else if (hasTaskState.change == 'macroTask') {
                        zone.hasPendingMacrotasks = hasTaskState.macroTask;
                    }
                }
            },
            onHandleError: function (delegate, current, target, error) {
                delegate.handleError(target, error);
                zone.runOutsideAngular(function () { return zone.onError.emit(error); });
                return false;
            },
        });
    }
    function updateMicroTaskStatus(zone) {
        if (zone._hasPendingMicrotasks || zone.lastRequestAnimationFrameId !== -1) {
            zone.hasPendingMicrotasks = true;
        }
        else {
            zone.hasPendingMicrotasks = false;
        }
    }
    function onEnter(zone) {
        zone._nesting++;
        if (zone.isStable) {
            zone.isStable = false;
            zone.onUnstable.emit(null);
        }
    }
    function onLeave(zone) {
        zone._nesting--;
        checkStable(zone);
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.APP_ROOT_VIEW = APP_ROOT_VIEW;
    exports.ActionBarComponent = ActionBarComponent;
    exports.ActionBarScope = ActionBarScope;
    exports.ActionItemDirective = ActionItemDirective;
    exports.AndroidFilterComponent = AndroidFilterComponent;
    exports.AppHostAsyncView = AppHostAsyncView;
    exports.AppHostView = AppHostView;
    exports.BasePortalOutlet = BasePortalOutlet;
    exports.BaseValueAccessor = BaseValueAccessor;
    exports.COMMON_PROVIDERS = COMMON_PROVIDERS;
    exports.CdkPortal = CdkPortal;
    exports.CdkPortalOutlet = CdkPortalOutlet;
    exports.CheckedValueAccessor = CheckedValueAccessor;
    exports.CommentNode = CommentNode;
    exports.ComponentPortal = ComponentPortal;
    exports.DEVICE = DEVICE;
    exports.DISABLE_ROOT_VIEW_HANDLING = DISABLE_ROOT_VIEW_HANDLING;
    exports.DateValueAccessor = DateValueAccessor;
    exports.DetachedLoader = DetachedLoader;
    exports.DomPortal = DomPortal;
    exports.ENABLE_REUSABE_VIEWS = ENABLE_REUSABE_VIEWS;
    exports.EmulatedRenderer = EmulatedRenderer;
    exports.FrameDirective = FrameDirective;
    exports.FramePageComponent = FramePageComponent;
    exports.FramePageModule = FramePageModule;
    exports.FrameService = FrameService;
    exports.IOSFilterComponent = IOSFilterComponent;
    exports.InjectableAnimationEngine = InjectableAnimationEngine;
    exports.InvisibleNode = InvisibleNode;
    exports.ItemContext = ItemContext;
    exports.ListViewComponent = ListViewComponent;
    exports.ModalDialogParams = ModalDialogParams;
    exports.ModalDialogService = ModalDialogService;
    exports.NAMESPACE_FILTERS = NAMESPACE_FILTERS;
    exports.NATIVESCRIPT_MODULE_PROVIDERS = NATIVESCRIPT_MODULE_PROVIDERS;
    exports.NATIVESCRIPT_MODULE_STATIC_PROVIDERS = NATIVESCRIPT_MODULE_STATIC_PROVIDERS;
    exports.NATIVESCRIPT_ROOT_MODULE_ID = NATIVESCRIPT_ROOT_MODULE_ID;
    exports.NATIVE_DIALOG_DATA = NATIVE_DIALOG_DATA;
    exports.NATIVE_DIALOG_DEFAULT_OPTIONS = NATIVE_DIALOG_DEFAULT_OPTIONS;
    exports.NSEmptyOutletComponent = NSEmptyOutletComponent;
    exports.NSFileSystem = NSFileSystem;
    exports.NSLocationStrategy = NSLocationStrategy;
    exports.NSRouteReuseStrategy = NSRouteReuseStrategy;
    exports.NSRouterLink = NSRouterLink;
    exports.NSRouterLinkActive = NSRouterLinkActive;
    exports.NativeDialogCloseDirective = NativeDialogCloseDirective;
    exports.NativeDialogConfig = NativeDialogConfig;
    exports.NativeDialogModule = NativeDialogModule;
    exports.NativeDialogRef = NativeDialogRef;
    exports.NativeDialogService = NativeDialogService;
    exports.NativeModalRef = NativeModalRef;
    exports.NativeScriptAnimationDriver = NativeScriptAnimationDriver;
    exports.NativeScriptAnimationPlayer = NativeScriptAnimationPlayer;
    exports.NativeScriptAnimationsModule = NativeScriptAnimationsModule;
    exports.NativeScriptCommonModule = NativeScriptCommonModule;
    exports.NativeScriptDocument = NativeScriptDocument;
    exports.NativeScriptDomPortalOutlet = NativeScriptDomPortalOutlet;
    exports.NativeScriptFormsModule = NativeScriptFormsModule;
    exports.NativeScriptHttpClientModule = NativeScriptHttpClientModule;
    exports.NativeScriptLoadingService = NativeScriptLoadingService;
    exports.NativeScriptModule = NativeScriptModule;
    exports.NativeScriptNgSafeEvent = NativeScriptNgSafeEvent;
    exports.NativeScriptNgZone = NativeScriptNgZone;
    exports.NativeScriptRendererFactory = NativeScriptRendererFactory;
    exports.NativeScriptRouterModule = NativeScriptRouterModule;
    exports.NativeScriptSanitizer = NativeScriptSanitizer;
    exports.NativescriptXhrFactory = NativescriptXhrFactory;
    exports.NavigationButtonDirective = NavigationButtonDirective;
    exports.NgViewRef = NgViewRef;
    exports.NsHttpBackEnd = NsHttpBackEnd;
    exports.NsTemplatedItem = NsTemplatedItem;
    exports.NumberValueAccessor = NumberValueAccessor;
    exports.Outlet = Outlet;
    exports.PAGE_FACTORY = PAGE_FACTORY;
    exports.PageDirective = PageDirective;
    exports.PageRoute = PageRoute;
    exports.PageRouterOutlet = PageRouterOutlet;
    exports.PageService = PageService;
    exports.PlatformNamespaceFilter = PlatformNamespaceFilter;
    exports.Portal = Portal;
    exports.PortalModule = PortalModule;
    exports.RootCompositeModule = RootCompositeModule;
    exports.RootViewProxy = RootViewProxy;
    exports.RouterExtensions = RouterExtensions;
    exports.START_PATH = START_PATH;
    exports.SelectedIndexValueAccessor = SelectedIndexValueAccessor;
    exports.TEMPLATED_ITEMS_COMPONENT = TEMPLATED_ITEMS_COMPONENT;
    exports.TabViewDirective = TabViewDirective;
    exports.TabViewItemDirective = TabViewItemDirective;
    exports.TemplateKeyDirective = TemplateKeyDirective;
    exports.TemplatePortal = TemplatePortal;
    exports.TextNode = TextNode;
    exports.TextValueAccessor = TextValueAccessor;
    exports.TimeValueAccessor = TimeValueAccessor;
    exports._NativeDialogBase = _NativeDialogBase;
    exports.createKeyframeAnimation = createKeyframeAnimation;
    exports.customFrameComponentFactory = customFrameComponentFactory;
    exports.customFrameDirectiveFactory = customFrameDirectiveFactory;
    exports.customPageFactory = customPageFactory;
    exports.customPageFactoryFromFrame = customPageFactoryFromFrame;
    exports.dashCaseToCamelCase = dashCaseToCamelCase;
    exports.defaultNavOptions = defaultNavOptions;
    exports.defaultPageFactory = defaultPageFactory;
    exports.defaultPageFactoryProvider = defaultPageFactoryProvider;
    exports.detachViewFromParent = detachViewFromParent;
    exports.disableRootViewHanding = disableRootViewHanding;
    exports.errorHandler = errorHandler;
    exports.extractSingleViewRecursive = extractSingleViewRecursive;
    exports.frameMeta = frameMeta;
    exports.generateDetachedLoader = generateDetachedLoader;
    exports.generateFallbackRootView = generateFallbackRootView;
    exports.generateNativeScriptView = generateNativeScriptView;
    exports.generateRandomId = generateRandomId;
    exports.generateRootLayoutAndProxy = generateRootLayoutAndProxy;
    exports.getFirstNativeLikeView = getFirstNativeLikeView;
    exports.getItemViewRoot = getItemViewRoot;
    exports.getSingleViewRecursive = getSingleViewRecursive;
    exports.getViewClass = getViewClass;
    exports.getViewMeta = getViewMeta;
    exports.instantiateDefaultStyleNormalizer = instantiateDefaultStyleNormalizer;
    exports.instantiateRendererFactory = instantiateRendererFactory;
    exports.instantiateSupportedAnimationDriver = instantiateSupportedAnimationDriver;
    exports.isBlank = isBlank;
    exports.isContentView = isContentView;
    exports.isDetachedElement = isDetachedElement;
    exports.isInvisibleNode = isInvisibleNode;
    exports.isKnownView = isKnownView;
    exports.isLayout = isLayout;
    exports.isPresent = isPresent;
    exports.isView = isView;
    exports.onAfterLivesync = onAfterLivesync;
    exports.onBeforeLivesync = onBeforeLivesync;
    exports.once = once;
    exports.platformNativeScript = platformNativeScript;
    exports.platformNativeScriptDynamic = platformNativeScriptDynamic;
    exports.postAngularBootstrap$ = postAngularBootstrap$;
    exports.preAngularDisposal$ = preAngularDisposal$;
    exports.provideLocationStrategy = provideLocationStrategy;
    exports.registerElement = registerElement;
    exports.registerNativeScriptViewComponents = registerNativeScriptViewComponents;
    exports.runNativeScriptAngularApp = runNativeScriptAngularApp;
    exports.throwIfAlreadyLoaded = throwIfAlreadyLoaded;
    exports.throwNoPortalAttachedError = throwNoPortalAttachedError;
    exports.throwNullPortalError = throwNullPortalError;
    exports.throwNullPortalOutletError = throwNullPortalOutletError;
    exports.throwPortalAlreadyAttachedError = throwPortalAlreadyAttachedError;
    exports.throwPortalOutletAlreadyDisposedError = throwPortalOutletAlreadyDisposedError;
    exports.throwUnknownPortalTypeError = throwUnknownPortalTypeError;
    exports.ɵCOMPONENT_VARIABLE = COMPONENT_VARIABLE;
    exports.ɵCONTENT_ATTR = CONTENT_ATTR;
    exports.ɵHOST_ATTR = HOST_ATTR;
    exports.ɵViewUtil = viewUtil;
    exports.ɵa = FramePageModule;
    exports.ɵactionBarMeta = actionBarMeta;
    exports.ɵb = customFrameDirectiveFactory;
    exports.ɵc = FrameDirective;
    exports.ɵd = customPageFactory;
    exports.ɵe = PageDirective;
    exports.ɵelementMap = elementMap;
    exports.ɵf = PageService;
    exports.ɵg = customFrameComponentFactory;
    exports.ɵh = customPageFactoryFromFrame;
    exports.ɵi = FramePageComponent;
    exports.ɵisActionItem = isActionItem;
    exports.ɵisNavigationButton = isNavigationButton;
    exports.ɵj = TEMPLATED_ITEMS_COMPONENT;
    exports.ɵk = ItemContext;
    exports.ɵl = ListViewComponent;
    exports.ɵm = TemplateKeyDirective;
    exports.ɵn = ModalDialogService;
    exports.ɵo = NSLocationStrategy;
    exports.ɵp = FrameService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=nativescript-angular.umd.js.map
