"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringUtils = exports.sanitize = exports.sanitizeCommaDelimitedArg = exports.getNxWorkspaceConfig = exports.updateNxProjects = exports.updateWorkspace = exports.readWorkspaceJson = exports.updatePackageScripts = exports.updateFile = exports.updateJsonFile = exports.getJsonFromFile = exports.jsonParse = exports.addInstallTask = exports.prerun = exports.getDefaultTemplateOptions = exports.getPlatformName = exports.getAppNamingConvention = exports.applyAppNamingConvention = exports.isXplatWorkspace = exports.getAppName = exports.getGroupByName = exports.getFrontendFramework = exports.getPrefix = exports.getNpmScope = exports.packageSettingKeys = exports.supportedSandboxPlatforms = exports.supportedFrameworks = exports.supportedPlatforms = void 0;
const schematics_1 = require("@angular-devkit/schematics");
const tasks_1 = require("@angular-devkit/schematics/tasks");
const devkit_1 = require("@nrwl/devkit");
const workspace_1 = require("@nrwl/workspace");
exports.supportedPlatforms = [
    'nativescript',
];
// TODO: support react, svelte, vue
// | 'react'
// | 'svelte
// | 'vue'
exports.supportedFrameworks = ['angular']; //, 'react', 'svelte', 'vue']
exports.supportedSandboxPlatforms = ['nativescript'];
// various plugin settings - workspace can be setup using these possible keys
// this plugin works under the hood of xplat as well
exports.packageSettingKeys = {
    nativescriptNx: 'nativescript-nx',
    xplat: 'xplat'
};
let npmScope;
// selector prefix to use when generating various boilerplate components
let prefix;
// user preferred default framework
let frontendFramework;
// Group by app name (appname-platform) instead of the default (platform-appname)
let groupByName = false;
let usingXplatWorkspace = false;
function getNpmScope() {
    return npmScope;
}
exports.getNpmScope = getNpmScope;
function getPrefix() {
    return prefix;
}
exports.getPrefix = getPrefix;
function getFrontendFramework() {
    return frontendFramework;
}
exports.getFrontendFramework = getFrontendFramework;
function getGroupByName() {
    return groupByName;
}
exports.getGroupByName = getGroupByName;
function getAppName(options, platform) {
    return groupByName
        ? options.name.replace(`-${platform}`, '')
        : options.name.replace(`${platform}-`, '');
}
exports.getAppName = getAppName;
function isXplatWorkspace() {
    return usingXplatWorkspace;
}
exports.isXplatWorkspace = isXplatWorkspace;
function applyAppNamingConvention(options, platform) {
    return (tree, context) => {
        const { name, directory } = getAppNamingConvention(options, platform);
        options.name = name;
        options.directory = directory;
        // console.log('applyAppNamingConvention:', options);
        // adjusted name, nothing else to do
        return schematics_1.noop()(tree, context);
    };
}
exports.applyAppNamingConvention = applyAppNamingConvention;
function getAppNamingConvention(options, platform) {
    let name = '';
    let directory = '';
    if (options.directory) {
        directory = workspace_1.toFileName(options.directory);
        if (directory === platform &&
            exports.supportedPlatforms.includes(directory)) {
            name = workspace_1.toFileName(options.name);
        }
        else {
            name = getPlatformName(options.name, platform);
        }
    }
    else {
        name = getPlatformName(options.name, platform);
    }
    return {
        name,
        directory,
    };
}
exports.getAppNamingConvention = getAppNamingConvention;
function getPlatformName(name, platform) {
    const nameSanitized = workspace_1.toFileName(name);
    return getGroupByName()
        ? `${nameSanitized}-${platform}`
        : `${platform}-${nameSanitized}`;
}
exports.getPlatformName = getPlatformName;
function getDefaultTemplateOptions() {
    // console.log('getDefaultTemplateOptions getPrefix:', getPrefix());
    return {
        tmpl: '',
        utils: exports.stringUtils,
        npmScope: getNpmScope(),
        prefix: getPrefix(),
        dot: '.',
    };
}
exports.getDefaultTemplateOptions = getDefaultTemplateOptions;
function prerun(options, init) {
    return (tree) => {
        const nxJson = getNxWorkspaceConfig(tree);
        if (nxJson) {
            npmScope = nxJson.npmScope || 'workspace';
        }
        // console.log('npmScope:', npmScope);
        const packageJson = getJsonFromFile(tree, 'package.json');
        let frameworkChoice;
        if (options && options.framework) {
            // can actually specify comma delimited list of frameworks to generate support for
            // most common to generate 1 at a time but we allow multiple
            const frameworks = sanitizeCommaDelimitedArg(options.framework);
            // always default framework choice to first in list when multiple
            // when it's just one (most common) will be first already
            frameworkChoice = frameworks[0];
        }
        // console.log('frameworkChoice:', frameworkChoice);
        if (packageJson) {
            prefix = '';
            const pluginSettings = packageJson[exports.packageSettingKeys.nativescriptNx] || packageJson[exports.packageSettingKeys.xplat];
            if (pluginSettings) {
                usingXplatWorkspace = !!packageJson[exports.packageSettingKeys.xplat];
                // use persisted settings
                prefix = pluginSettings.prefix || npmScope; // (if not prefix, default to npmScope)
                frontendFramework = pluginSettings.framework;
                if (options) {
                    if (options.prefix) {
                        // always use explicit prefix user passed in
                        prefix = options.prefix;
                    }
                    else {
                        // ensure options are updated
                        options.prefix = prefix;
                    }
                    if (frameworkChoice) {
                        // always override default framework when user has explicitly passed framework option in
                        frontendFramework = frameworkChoice;
                    }
                }
                // grouping
                groupByName =
                    pluginSettings.groupByName || (options ? options.groupByName : false);
            }
            else if (options) {
                groupByName = options.groupByName;
                if (options.prefix) {
                    if (!prefix && init) {
                        // initializing for first time
                        prefix = options.prefix;
                    }
                }
                else {
                    // default to npmScope for prefix
                    options.prefix = npmScope;
                }
                if (frameworkChoice) {
                    if (!frontendFramework && init) {
                        frontendFramework = frameworkChoice;
                    }
                }
            }
        }
        // console.log('prefix:', prefix);
        return tree;
    };
}
exports.prerun = prerun;
function addInstallTask(options) {
    return (host, context) => {
        if (!options || (options && !options.skipInstall)) {
            context.addTask(new tasks_1.NodePackageInstallTask());
        }
        return host;
    };
}
exports.addInstallTask = addInstallTask;
function jsonParse(content) {
    if (content) {
        // ensure comments are stripped when parsing (otherwise will fail)
        return devkit_1.parseJson(content);
    }
    return {};
}
exports.jsonParse = jsonParse;
function getJsonFromFile(tree, path) {
    // console.log('getJsonFromFile:', path)
    return jsonParse(tree.get(path).content.toString());
}
exports.getJsonFromFile = getJsonFromFile;
function updateJsonFile(tree, path, jsonData) {
    try {
        tree.overwrite(path, workspace_1.serializeJson(jsonData));
        return tree;
    }
    catch (err) {
        // console.warn(err);
        throw new schematics_1.SchematicsException(`${path}: ${err}`);
    }
}
exports.updateJsonFile = updateJsonFile;
function updateFile(tree, path, content) {
    try {
        // if (tree.exists(path)) {
        tree.overwrite(path, content);
        // }
        return tree;
    }
    catch (err) {
        // console.warn(err);
        throw new schematics_1.SchematicsException(`${path}: ${err}`);
    }
}
exports.updateFile = updateFile;
function updatePackageScripts(tree, scripts) {
    const path = 'package.json';
    const packageJson = getJsonFromFile(tree, path);
    const scriptsMap = Object.assign({}, packageJson.scripts);
    packageJson.scripts = Object.assign(scriptsMap, scripts);
    return updateJsonFile(tree, path, packageJson);
}
exports.updatePackageScripts = updatePackageScripts;
function readWorkspaceJson(tree) {
    return workspace_1.readJsonInTree(tree, workspace_1.getWorkspacePath(tree));
}
exports.readWorkspaceJson = readWorkspaceJson;
function updateWorkspace(updates) {
    return workspace_1.updateWorkspaceInTree((json) => {
        for (const key in updates) {
            json[key] = Object.assign(Object.assign({}, (json[key] || {})), updates[key]);
        }
        return json;
    });
}
exports.updateWorkspace = updateWorkspace;
function updateNxProjects(tree, projects) {
    const path = 'nx.json';
    const nxJson = getJsonFromFile(tree, path);
    const projectsMap = Object.assign({}, nxJson.projects);
    nxJson.projects = Object.assign(projectsMap, projects);
    return updateJsonFile(tree, path, nxJson);
}
exports.updateNxProjects = updateNxProjects;
function getNxWorkspaceConfig(tree) {
    const nxConfig = getJsonFromFile(tree, 'nx.json');
    const hasWorkspaceDirs = tree.exists('libs') || tree.exists('packages');
    // determine if Nx workspace
    if (nxConfig) {
        if (nxConfig.npmScope || hasWorkspaceDirs) {
            return nxConfig;
        }
    }
    throw new schematics_1.SchematicsException('@nativescript/nx must be used inside an Nx workspace. Create a workspace first. https://nx.dev');
}
exports.getNxWorkspaceConfig = getNxWorkspaceConfig;
function sanitizeCommaDelimitedArg(input) {
    if (input) {
        return input
            .split(',')
            .filter((i) => !!i)
            .map((i) => i.trim().toLowerCase());
    }
    return [];
}
exports.sanitizeCommaDelimitedArg = sanitizeCommaDelimitedArg;
/**
 * Sanitizes a given string by removing all characters that
 * are not letters or digits.
 *
 ```javascript
 sanitize('nativescript-app');  // 'nativescriptapp'
 sanitize('action_name');       // 'actioname'
 sanitize('css-class-name');    // 'cssclassname'
 sanitize('my favorite items'); // 'myfavoriteitems'
 ```

 @method sanitize
 @param {String} str The string to sanitize.
 @return {String} the sanitized string.
*/
const sanitize = (str) => str
    .split('')
    .filter((char) => /[a-zA-Z0-9]/.test(char))
    .join('');
exports.sanitize = sanitize;
exports.stringUtils = Object.assign({ sanitize: exports.sanitize }, workspace_1.stringUtils);
//# sourceMappingURL=general.js.map