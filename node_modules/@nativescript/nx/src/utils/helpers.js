"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluginFeatureHelpers = exports.PluginComponentHelpers = exports.PluginHelpers = void 0;
const schematics_1 = require("@angular-devkit/schematics");
const tasks_1 = require("@angular-devkit/schematics/tasks");
const workspace_1 = require("@nrwl/workspace");
const typescript_1 = require("typescript");
const ast_1 = require("./ast");
const errors_1 = require("./errors");
const general_1 = require("./general");
const versions_1 = require("./versions");
var PluginHelpers;
(function (PluginHelpers) {
    function getFrameworksFromOptions(frameworkArgument) {
        // will support comma delimited list of frameworks to generate support for
        // most common to generate 1 at a time but we will allow multiple
        // always default framework choice to first in list when multiple
        return general_1.sanitizeCommaDelimitedArg(frameworkArgument);
    }
    PluginHelpers.getFrameworksFromOptions = getFrameworksFromOptions;
    function getFrameworkChoice(frameworkArgument, frameworks) {
        frameworks = frameworks || getFrameworksFromOptions(frameworkArgument);
        return frameworks.length ? frameworks[0] : null;
    }
    PluginHelpers.getFrameworkChoice = getFrameworkChoice;
    function updateRootDeps(options) {
        return (tree, context) => {
            const frameworkDependencies = {};
            const frameworkDevDependencies = {};
            switch (options.framework) {
                case 'angular':
                    // dep
                    frameworkDependencies['@nativescript/angular'] = versions_1.nsAngularVersion;
                    frameworkDependencies['@angular/animations'] = versions_1.angularVersion;
                    frameworkDependencies['@angular/common'] = versions_1.angularVersion;
                    frameworkDependencies['@angular/compiler'] = versions_1.angularVersion;
                    frameworkDependencies['@angular/core'] = versions_1.angularVersion;
                    frameworkDependencies['@angular/forms'] = versions_1.angularVersion;
                    frameworkDependencies['@angular/platform-browser'] = versions_1.angularVersion;
                    frameworkDependencies['@angular/platform-browser-dynamic'] = versions_1.angularVersion;
                    frameworkDependencies['@angular/router'] = versions_1.angularVersion;
                    frameworkDependencies['rxjs'] = versions_1.rxjsVersion;
                    frameworkDependencies['zone.js'] = versions_1.zonejsVersion;
                    // devDep
                    frameworkDevDependencies['@angular/compiler-cli'] = versions_1.angularVersion;
                    frameworkDevDependencies['@ngtools/webpack'] = versions_1.nsNgToolsVersion;
                    break;
            }
            return PluginHelpers.updatePackageForWorkspace(options, {
                dependencies: Object.assign({ '@nativescript/core': versions_1.nsCoreVersion, 'nativescript-theme-core': versions_1.nsThemeVersion }, frameworkDependencies),
                devDependencies: Object.assign({ 'sass': versions_1.sassVersion, '@nativescript/webpack': versions_1.nsWebpackVersion, '@nativescript/types': versions_1.nsTypesVersion }, frameworkDevDependencies),
            })(tree, context);
        };
    }
    PluginHelpers.updateRootDeps = updateRootDeps;
    //   export function updatePrettierIgnore() {
    //     return PluginHelpers.updatePrettierIgnore(
    //       `\n
    // # @nativescript/nx added rules
    // **/*.d.ts
    // **/apps/**/platforms/**/*
    // **/App_Resources/**/*
    // **/apps/nativescript*/hooks/**/*
    // **/apps/nativescript*/tools/**/*
    // **/apps/nativescript*/src/assets/*.min.css
    // **/apps/*nativescript/hooks/**/*
    // **/apps/*nativescript/tools/**/*
    // **/apps/*nativescript/src/assets/*.css`,
    //       '**/apps/*nativescript/src/assets/*.css'
    //     );
    //   }
    function getUpdatedPluginSettings(options) {
        const frameworks = getFrameworksFromOptions(options.framework);
        const frameworkChoice = PluginHelpers.getFrameworkChoice(options.framework, frameworks);
        const pluginSettings = {
            prefix: general_1.getPrefix(),
        };
        if (frameworkChoice && frameworks.length === 1) {
            // when only 1 framework is specified, auto add as default
            pluginSettings.framework = frameworkChoice;
        }
        if (options.groupByName) {
            pluginSettings.groupByName = true;
        }
        return pluginSettings;
    }
    PluginHelpers.getUpdatedPluginSettings = getUpdatedPluginSettings;
    /**
     * Returns a name with the platform.
     *
     * @example (app, nativescript) => nativescript-app or app-nativescript
     * @param name
     * @param platform
     */
    function getPlatformName(name, platform) {
        const nameSanitized = workspace_1.toFileName(name);
        return general_1.getGroupByName() ? `${nameSanitized}-${platform}` : `${platform}-${nameSanitized}`;
    }
    PluginHelpers.getPlatformName = getPlatformName;
    /**
     * Returns libs folder name dependent on settings.
     *
     * @example ('web', 'angular') => 'web-angular' if no default framework otherwise just 'web'
     * @param platform
     * @param framework
     */
    function getLibFoldername(platform, framework) {
        const frontendFramework = general_1.getFrontendFramework();
        // console.log('getLibFoldername frontendFramework:', frontendFramework);
        // console.log('framework:', framework);
        let frameworkSuffix = '';
        if (framework && frontendFramework !== framework) {
            // user had a default framework set
            // however an explicit framework is being requested
            // if they differ, use suffix to distinguish
            frameworkSuffix = `-${framework}`;
        }
        return `${platform}${frameworkSuffix}`;
    }
    PluginHelpers.getLibFoldername = getLibFoldername;
    function getExternalChainsForGenerator(options, generator, packagesToRunXplat) {
        let generatorSettings;
        let isApp = false;
        switch (generator) {
            case 'component':
                generatorSettings = PluginComponentHelpers.prepare(options);
                break;
            case 'feature':
                generatorSettings = PluginFeatureHelpers.prepare(options);
                break;
            default:
                isApp = ['application', 'app'].includes(generator);
                generatorSettings = {
                    platforms: general_1.sanitizeCommaDelimitedArg('nativescript'),
                };
                break;
        }
        const platforms = generatorSettings.platforms;
        const externalChains = [];
        const devDependencies = {};
        // frontend framework
        const frameworks = getFrameworksFromOptions(options.framework);
        const frameworkChoice = getFrameworkChoice(options.framework, frameworks);
        // console.log('frameworks:', frameworks);
        // console.log('frameworkChoice:', frameworkChoice);
        // console.log('platforms:', platforms);
        if (frameworks.length) {
            for (const framework of frameworks) {
                if (general_1.supportedFrameworks.includes(framework)) {
                    const packageName = `@nativescript/nx-${framework}`;
                    devDependencies[packageName] = versions_1.nsNxPluginVersion;
                    // externalChains.push(externalSchematic(`@nstudio/${platform}-${framework}`, 'app', options));
                    packagesToRunXplat.push(packageName);
                }
                else {
                    throw new schematics_1.SchematicsException(errors_1.unsupportedFrameworkError(framework));
                }
            }
        }
        if (Object.keys(devDependencies).length) {
            externalChains.push((tree, context) => {
                // console.log(devDependencies);
                return PluginHelpers.updatePackageForWorkspace(options, {
                    devDependencies,
                })(tree, context);
            });
            if (options.isTesting) {
                // necessary to unit test the appropriately
                // console.log('packagesToRunXplat:', packagesToRunXplat)
                if (packagesToRunXplat.length) {
                    for (const packageName of packagesToRunXplat) {
                        externalChains.push(schematics_1.externalSchematic(packageName, generator, options, {
                            interactive: false,
                        }));
                    }
                }
            }
            else {
                externalChains.push((tree, context) => {
                    const installPackageTask = context.addTask(new tasks_1.NodePackageInstallTask());
                    // console.log('devDependencies:', devDependencies);
                    // console.log('packagesToRunXplat:', packagesToRunXplat);
                    for (const packageName of packagesToRunXplat) {
                        context.addTask(new tasks_1.RunSchematicTask(packageName, generator, options), [installPackageTask]);
                    }
                });
            }
        }
        return externalChains;
    }
    PluginHelpers.getExternalChainsForGenerator = getExternalChainsForGenerator;
    function getExternalChainsForApplication(options, generator, packagesToRun) {
        let generatorSettings = {
            platforms: general_1.sanitizeCommaDelimitedArg('nativescript'),
        };
        const platforms = generatorSettings.platforms;
        const externalChains = [];
        const devDependencies = {};
        let targetPlatforms = 0;
        // console.log('platforms:', platforms);
        if (options.isTesting) {
            // necessary to unit test the appropriately
            if (targetPlatforms) {
                externalChains.push(schematics_1.externalSchematic('@nativescript/nx', 'app-generate', options, {
                    interactive: false,
                }));
            }
            if (packagesToRun.length) {
                for (const packageName of packagesToRun) {
                    const nxPlatform = packageName.replace('@nrwl/', '');
                    const { name, directory } = getAppNamingConvention(options, nxPlatform);
                    externalChains.push(schematics_1.externalSchematic(packageName, generator, Object.assign(Object.assign({}, options), { name,
                        directory }), {
                        interactive: false,
                    }));
                }
            }
        }
        else {
            if (targetPlatforms) {
                externalChains.push(schematics_1.externalSchematic('@nativescript/nx', 'app-generate', options));
            }
            if (packagesToRun.length) {
                externalChains.push((tree, context) => {
                    const installPackageTask = context.addTask(new tasks_1.NodePackageInstallTask());
                    // console.log('devDependencies:', devDependencies);
                    // console.log('packagesToRunXplat:', packagesToRunXplat);
                    for (const packageName of packagesToRun) {
                        const nxPlatform = packageName.replace('@nrwl/', '');
                        const { name, directory } = getAppNamingConvention(options, nxPlatform);
                        context.addTask(new tasks_1.RunSchematicTask(packageName, generator, Object.assign(Object.assign({}, options), { name,
                            directory })), [installPackageTask]);
                    }
                });
            }
        }
        return externalChains;
    }
    PluginHelpers.getExternalChainsForApplication = getExternalChainsForApplication;
    function applyAppNamingConvention(options, platform) {
        return (tree, context) => {
            const { name, directory } = getAppNamingConvention(options, platform);
            options.name = name;
            options.directory = directory;
            // console.log('applyAppNamingConvention:', options);
            // adjusted name, nothing else to do
            return schematics_1.noop()(tree, context);
        };
    }
    PluginHelpers.applyAppNamingConvention = applyAppNamingConvention;
    function getAppNamingConvention(options, platform) {
        let name = '';
        let directory = '';
        if (options.directory) {
            directory = workspace_1.toFileName(options.directory);
            if (directory === platform && general_1.supportedPlatforms.includes(directory)) {
                name = workspace_1.toFileName(options.name);
            }
            else {
                name = getPlatformName(options.name, platform);
            }
        }
        else {
            name = getPlatformName(options.name, platform);
        }
        return {
            name,
            directory,
        };
    }
    PluginHelpers.getAppNamingConvention = getAppNamingConvention;
    function updatePackageForWorkspace(options, updates) {
        return (tree, context) => {
            const packagePath = 'package.json';
            let packageJson = general_1.getJsonFromFile(tree, packagePath);
            if (packageJson) {
                // could introduce another json config file but trying to avoid too much extra overhead so just store in package.json for now
                const pluginSettings = getUpdatedPluginSettings(options);
                const pluginSettingsKey = general_1.isXplatWorkspace() ? general_1.packageSettingKeys.xplat : general_1.packageSettingKeys.nativescriptNx;
                if (!updates && pluginSettings) {
                    // just updating plugin settings
                    packageJson[pluginSettingsKey] = Object.assign(Object.assign({}, (packageJson[pluginSettingsKey] || {})), pluginSettings);
                    return general_1.updateJsonFile(tree, packagePath, packageJson);
                }
                else if (updates) {
                    // update root dependencies for the generated support
                    packageJson = Object.assign(Object.assign({}, packageJson), { dependencies: Object.assign(Object.assign({}, (packageJson.dependencies || {})), (updates.dependencies || {})), devDependencies: Object.assign(Object.assign({}, (packageJson.devDependencies || {})), (updates.devDependencies || {})), [pluginSettingsKey]: Object.assign(Object.assign({}, (packageJson[pluginSettingsKey] || {})), pluginSettings) });
                    // console.log('updatePackageForWorkspace:', serializeJson(packageJson));
                    return general_1.updateJsonFile(tree, packagePath, packageJson);
                }
            }
            return tree;
        };
    }
    PluginHelpers.updatePackageForWorkspace = updatePackageForWorkspace;
    function updateGitIgnore() {
        return (tree) => {
            //       const gitIgnorePath = '.gitignore';
            //       let gitIgnore = tree.get(gitIgnorePath).content.toString();
            //       if (gitIgnore) {
            //         if (gitIgnore.indexOf('libs/**/*.js') === -1) {
            //           gitIgnore += `
            // # libs
            // libs/**/*.js
            // libs/**/*.map
            // libs/**/*.d.ts
            // libs/**/*.metadata.json
            // libs/**/*.ngfactory.ts
            // libs/**/*.ngsummary.json
            //       `;
            //         }
            //       }
            //       return updateFile(tree, gitIgnorePath, gitIgnore);
        };
    }
    PluginHelpers.updateGitIgnore = updateGitIgnore;
    function updatePrettierIgnore(content, checkExisting) {
        return (tree) => {
            const prettierFileName = '.prettierignore';
            if (tree.exists(prettierFileName)) {
                let prettier = tree.read(prettierFileName).toString('utf-8');
                if (prettier && prettier.indexOf(checkExisting) === -1) {
                    // update prettier rules
                    prettier = `${prettier}\n${content}`;
                    tree.overwrite(prettierFileName, prettier);
                }
            }
            return tree;
        };
    }
    PluginHelpers.updatePrettierIgnore = updatePrettierIgnore;
    function addPackageInstallTask(options) {
        return (tree, context) => {
            // let packageTask;
            if (!options.skipInstall) {
                // packageTask = context.addTask(
                //   new NodePackageInstallTask() //options.directory)
                // );
                context.addTask(new tasks_1.NodePackageInstallTask());
            }
        };
    }
    PluginHelpers.addPackageInstallTask = addPackageInstallTask;
})(PluginHelpers = exports.PluginHelpers || (exports.PluginHelpers = {}));
var PluginComponentHelpers;
(function (PluginComponentHelpers) {
    function prepare(options) {
        if (!options.name) {
            throw new Error(errors_1.generateOptionError('component'));
        }
        // reset module globals
        options.needsIndex = false;
        let featureName;
        let projectNames = null;
        let platforms = [];
        if (options.feature) {
            featureName = options.feature.toLowerCase();
        }
        const projects = options.projects;
        if (projects) {
            options.onlyProject = true;
            if (!featureName) {
                // no feature targeted, default to shared
                featureName = 'shared';
            }
            // building feature in shared code and in projects
            projectNames = general_1.sanitizeCommaDelimitedArg(projects);
            for (const name of projectNames) {
                const projectParts = name.split('-');
                const platPrefix = projectParts[0];
                const platSuffix = projectParts.pop();
                if (general_1.supportedPlatforms.includes(platPrefix) && !platforms.includes(platPrefix)) {
                    // if project name is prefixed with supported platform and not already added
                    platforms.push(platPrefix);
                }
                else if (general_1.supportedPlatforms.includes(platSuffix) && !platforms.includes(platSuffix)) {
                    platforms.push(platSuffix);
                }
            }
        }
        else {
            if (!featureName) {
                // no feature targeted, default to ui
                featureName = 'ui';
            }
            // building feature in shared code only
            platforms = general_1.sanitizeCommaDelimitedArg('nativescript');
        }
        return { featureName, projectNames, platforms };
    }
    PluginComponentHelpers.prepare = prepare;
})(PluginComponentHelpers = exports.PluginComponentHelpers || (exports.PluginComponentHelpers = {}));
var PluginFeatureHelpers;
(function (PluginFeatureHelpers) {
    function prepare(options) {
        if (!options.name) {
            throw new schematics_1.SchematicsException(`You did not specify the name of the feature you'd like to generate. For example: nx g @nativescript/nx:feature my-feature`);
        }
        const featureName = options.name.toLowerCase();
        let projects = options.projects;
        let projectNames;
        let platforms = [];
        if (options.adjustSandbox) {
            // when adjusting sandbox for the feature, turn dependent options on
            // for convenience also setup some default fallbacks to avoid requiring so many options
            // sandbox flags are meant to be quick and convenient
            options.onlyProject = true;
            options.routing = true;
            if (!projects) {
                if (!options.platforms) {
                    // default to {N} sandbox
                    projects = 'nativescript-sandbox';
                }
                else {
                    platforms = general_1.sanitizeCommaDelimitedArg(options.platforms);
                    const projectSandboxNames = [];
                    // default to project with sandbox name
                    for (const p of platforms) {
                        if (general_1.supportedSandboxPlatforms.includes(p)) {
                            projectSandboxNames.push(`${p}-sandbox`);
                        }
                        else {
                            throw new schematics_1.SchematicsException(`The --adjustSandbox flag supports the following at the moment: ${general_1.supportedSandboxPlatforms}`);
                        }
                    }
                    projects = projectSandboxNames.join(',');
                }
            }
        }
        if (options.routing && !options.onlyProject) {
            throw new schematics_1.SchematicsException(`When generating a feature with the --routing option, please also specify --onlyProject. Support for shared code routing is under development.`);
        }
        if (projects) {
            // building feature in shared code and in projects
            projectNames = general_1.sanitizeCommaDelimitedArg(projects);
            for (const name of projectNames) {
                let projectName = name;
                if (name.indexOf('/') > -1) {
                    projectName = name.split('/').pop();
                }
                const projectParts = projectName.split('-');
                const platPrefix = projectParts[0];
                const platSuffix = projectParts.pop();
                if (general_1.supportedPlatforms.includes(platPrefix) && !platforms.includes(platPrefix)) {
                    // if project name is prefixed with supported platform and not already added
                    platforms.push(platPrefix);
                }
                else if (general_1.supportedPlatforms.includes(platSuffix) && !platforms.includes(platSuffix)) {
                    // if project name is suffixed with supported platform and not already added
                    platforms.push(platSuffix);
                }
            }
        }
        else if (options.platforms) {
            // building feature in shared code only
            platforms = general_1.sanitizeCommaDelimitedArg(options.platforms);
        }
        // if (platforms.length === 0 && !options.onlyModule) {
        //   let error = projects
        //     ? platformAppPrefixError()
        //     : generatorError('feature');
        //   throw new SchematicsException(optionsMissingError(error));
        // }
        return { featureName, projectNames, platforms };
    }
    PluginFeatureHelpers.prepare = prepare;
    function addFiles(options, target = '', projectName = '', extra = '', framework) {
        let moveTo;
        if (target) {
            moveTo = getMoveTo(options, target, projectName, framework);
        }
        else {
            target = 'lib';
            moveTo = `libs/features/${options.name.toLowerCase()}`;
        }
        if (!extra) {
            // make sure no `null` or `undefined` values get in the string path
            extra = '';
        }
        // console.log('target:', target);
        // console.log('addFiles moveTo:', moveTo);
        // console.log('add files from:', `${workingDirectory}/${extra}_files`);
        return schematics_1.branchAndMerge(schematics_1.mergeWith(schematics_1.apply(schematics_1.url(`./${extra}_files`), [schematics_1.template(getTemplateOptions(options, target, framework)), schematics_1.move(moveTo)])));
    }
    PluginFeatureHelpers.addFiles = addFiles;
    function adjustBarrelIndex(options, indexFilePath) {
        return (tree) => {
            // console.log('adjustBarrelIndex indexFilePath:', indexFilePath);
            // console.log('tree.exists(indexFilePath):', tree.exists(indexFilePath));
            const indexSource = tree.read(indexFilePath).toString('utf-8');
            const indexSourceFile = typescript_1.createSourceFile(indexFilePath, indexSource, typescript_1.ScriptTarget.Latest, true);
            ast_1.insert(tree, indexFilePath, [...ast_1.addGlobal(indexSourceFile, indexFilePath, `export * from './${options.name.toLowerCase()}';`, true)]);
            return tree;
        };
    }
    PluginFeatureHelpers.adjustBarrelIndex = adjustBarrelIndex;
    function getTemplateOptions(options, platform, framework) {
        const nameParts = options.name.split('-');
        let endingDashName = nameParts[0];
        if (nameParts.length > 1) {
            endingDashName = general_1.stringUtils.capitalize(nameParts[nameParts.length - 1]);
        }
        const libFolderName = PluginHelpers.getLibFoldername(platform, framework);
        return Object.assign(Object.assign(Object.assign({}, options), general_1.getDefaultTemplateOptions()), { name: options.name.toLowerCase(), endingDashName,
            libFolderName });
    }
    PluginFeatureHelpers.getTemplateOptions = getTemplateOptions;
    function getMoveTo(options, platform, projectName, framework) {
        // console.log('getMoveTo framework:', framework);
        const libFolderName = PluginHelpers.getLibFoldername(platform, framework);
        // console.log('getMoveTo libFolderName:', libFolderName);
        const featureName = options.name.toLowerCase();
        let moveTo = `libs/${general_1.isXplatWorkspace() ? 'xplat/' : ''}${libFolderName}/features/${featureName}`;
        if (projectName) {
            let appDir = ['web', 'web-angular'].includes(libFolderName) ? '/app' : '';
            moveTo = `apps/${projectName}/src${appDir}/features/${featureName}`;
            // console.log('moveTo:', moveTo);
        }
        return moveTo;
    }
    PluginFeatureHelpers.getMoveTo = getMoveTo;
})(PluginFeatureHelpers = exports.PluginFeatureHelpers || (exports.PluginFeatureHelpers = {}));
//# sourceMappingURL=helpers.js.map