"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resetIndexForDemoType = exports.resetAngularRoutes = exports.resetAngularIndex = exports.getPackagesForIndex = exports.getDemoIndexPathForType = exports.getDemoIndexButtonForType = exports.getDemoFlavorExt = exports.getDemoTypeFromName = exports.getSrcFolderForType = exports.getPluginDemoPath = exports.getDemoAppRoot = exports.getPathToPackageForDemo = exports.updateDemoDependencies = exports.addDependencyToDemoApp = exports.updateDemoSharedIndex = exports.getDemoTypes = exports.setDemoTypes = exports.SupportedDemoTypes = void 0;
const workspace_1 = require("@nrwl/workspace");
const workspace_2 = require("./workspace");
const xml2js = require('xml2js');
exports.SupportedDemoTypes = ['xml', 'angular', 'react', 'svelte', 'vue'];
let demoTypes = exports.SupportedDemoTypes;
function setDemoTypes(types) {
    demoTypes = types;
}
exports.setDemoTypes = setDemoTypes;
function getDemoTypes() {
    return demoTypes;
}
exports.getDemoTypes = getDemoTypes;
function updateDemoSharedIndex(tree, allPackages, packages, addingNew) {
    if (addingNew) {
        // just add to all packages
        for (const p of packages) {
            if (!allPackages.includes(p)) {
                allPackages.push(p);
            }
        }
        packages = allPackages;
    }
    else {
        // isolate to packages or fallback to all
        packages = packages && packages.length ? packages : allPackages;
    }
    const demoSharedPath = `tools/demo/index.ts`;
    const demoSharedExport = (name) => {
        return `export * from './${name}';\n`;
    };
    const demoSharedIndex = `export * from './utils';\n${packages.sort().map(demoSharedExport).join('')}`;
    tree.write(demoSharedPath, demoSharedIndex);
}
exports.updateDemoSharedIndex = updateDemoSharedIndex;
function addDependencyToDemoApp(tree, type, demoAppRoot) {
    workspace_2.checkPackages(tree);
    // update app dependencies for plugin development
    updateDemoDependencies(tree, type, demoAppRoot);
}
exports.addDependencyToDemoApp = addDependencyToDemoApp;
function updateDemoDependencies(tree, type, demoAppRoot, allPackages, focus) {
    const packagePath = `${demoAppRoot}/package.json`;
    const packageData = workspace_2.getJsonFromFile(tree, packagePath);
    const npmPackageNames = workspace_2.getNpmPackageNames();
    if (packageData) {
        packageData.dependencies = packageData.dependencies || {};
        const packageNamesToUpdate = workspace_2.getPackageNamesToUpdate();
        if (!packageNamesToUpdate || packageNamesToUpdate.length === 0) {
            // reset to all
            if (allPackages) {
                for (const name of allPackages) {
                    packageData.dependencies[npmPackageNames[name]] = getPathToPackageForDemo(type, name);
                }
            }
        }
        else {
            for (const name of packageNamesToUpdate) {
                packageData.dependencies[npmPackageNames[name]] = getPathToPackageForDemo(type, name);
            }
            if (focus && allPackages) {
                // when focusing packages, remove others not being focused on
                for (const name of allPackages) {
                    if (!packageNamesToUpdate.includes(name)) {
                        delete packageData.dependencies[npmPackageNames[name]];
                    }
                }
            }
        }
        tree.write(packagePath, workspace_1.serializeJson(packageData));
    }
}
exports.updateDemoDependencies = updateDemoDependencies;
// Angular uses dist output to ensure properly built angular packages
// may can switch to all same once confirmed ngcc is absolutely no longer needed
function getPathToPackageForDemo(type, name) {
    return `file:../../${type === 'angular' ? 'dist/' : ''}packages/${name}`;
}
exports.getPathToPackageForDemo = getPathToPackageForDemo;
function getDemoAppRoot(type) {
    return `apps/demo${type !== 'xml' ? '-' + type : ''}`;
}
exports.getDemoAppRoot = getDemoAppRoot;
function getPluginDemoPath(type) {
    return `${getSrcFolderForType(type)}/plugin-demos`;
}
exports.getPluginDemoPath = getPluginDemoPath;
function getSrcFolderForType(type) {
    switch (type) {
        case 'svelte':
        case 'vue':
            return 'app';
        default:
            return 'src';
    }
}
exports.getSrcFolderForType = getSrcFolderForType;
function getDemoTypeFromName(name) {
    const parts = name.split('-');
    if (parts.length > 1) {
        return parts[1];
    }
    else {
        // no suffix defaults to vanilla xml
        return 'xml';
    }
}
exports.getDemoTypeFromName = getDemoTypeFromName;
function getDemoFlavorExt(type) {
    let viewExt = 'xml';
    let viewClassExt = 'ts';
    let viewModuleExt;
    // adjust folder location and viewExt dependent on demo type if needed
    switch (type) {
        case 'angular':
            viewExt = 'component.html';
            viewClassExt = 'component.ts';
            viewModuleExt = 'module.ts';
            break;
        case 'react':
            viewExt = 'tsx';
            viewClassExt = null;
            break;
        case 'svelte':
            viewExt = 'svelte';
            viewClassExt = null;
            break;
        case 'vue':
            viewExt = 'vue';
            viewClassExt = null;
            break;
    }
    return {
        viewExt,
        viewClassExt,
        viewModuleExt
    };
}
exports.getDemoFlavorExt = getDemoFlavorExt;
function getDemoIndexButtonForType(type, packageName) {
    let buttonClass = `class="btn btn-primary view-demo"`;
    let buttonEnd = `/>`;
    let buttonStart;
    let buttonTap;
    switch (type) {
        case 'xml':
            buttonStart = `<Button text="${packageName}"`;
            buttonTap = `tap="{{ viewDemo }}"`;
            return {
                buttonStart,
                buttonTap,
                buttonClass,
                buttonEnd,
                buttonMarkup: `${buttonStart} ${buttonTap} ${buttonClass}${buttonEnd}`,
            };
        // case 'angular':
        //
        //   return {
        //     indexViewPath
        //   };
    }
}
exports.getDemoIndexButtonForType = getDemoIndexButtonForType;
function getDemoIndexPathForType(type) {
    switch (type) {
        case 'xml':
            return 'src/main-page.xml';
        case 'angular':
            return 'src/home.component.ts';
    }
}
exports.getDemoIndexPathForType = getDemoIndexPathForType;
function getPackagesForIndex(tree, packages, addingNew) {
    if (addingNew) {
        // just add to all packages
        const allPackages = workspace_2.getAllPackages(tree);
        for (const p of packages) {
            if (!allPackages.includes(p)) {
                allPackages.push(p);
            }
        }
        packages = allPackages;
    }
    else {
        // isolate to packages or fallback to all
        packages = packages && packages.length ? packages : workspace_2.getAllPackages(tree);
    }
    return packages;
}
exports.getPackagesForIndex = getPackagesForIndex;
function resetAngularIndex(tree, packages, addingNew) {
    const angularIndexPath = `${getDemoAppRoot('angular')}/${getDemoIndexPathForType('angular')}`;
    let angularIndex = tree.read(angularIndexPath).toString();
    const demosIndex = angularIndex.indexOf('[');
    packages = getPackagesForIndex(tree, packages, addingNew);
    angularIndex =
        angularIndex.substring(0, demosIndex + 1) +
            packages
                .sort()
                .map((p) => `\n	{\n		name: '${p}'\n	}`)
                .join(',') +
            '\n];\n}';
    tree.write(angularIndexPath, angularIndex);
}
exports.resetAngularIndex = resetAngularIndex;
function resetAngularRoutes(tree, packages, addingNew) {
    const angularRouteModulePath = `${getDemoAppRoot('angular')}/src/app-routing.module.ts`;
    let angularRouteModule = tree.read(angularRouteModulePath).toString();
    const routeDefIndex = angularRouteModule.indexOf('const routes');
    const routeModuleStart = angularRouteModule.substring(0, routeDefIndex);
    const routeMoudleDefIndex = angularRouteModule.indexOf('@NgModule');
    const routeModuleEnd = angularRouteModule.substring(routeMoudleDefIndex, angularRouteModule.length);
    packages = getPackagesForIndex(tree, packages, addingNew);
    const packageRoutes = packages
        .sort()
        .map((p) => `	{ path: '${p}', loadChildren: () => import('./plugin-demos/${p}.module').then(m => m.${workspace_1.stringUtils.classify(p)}Module) }`)
        .join(',\n') + '\n];\n\n';
    const routeStart = `const routes: Routes = [
   { path: '', redirectTo: '/home', pathMatch: 'full' },
   { path: 'home', component: HomeComponent },\n`;
    angularRouteModule = routeModuleStart + routeStart + packageRoutes + routeModuleEnd;
    // console.log('angularRouteModule:', angularRouteModule);
    tree.write(angularRouteModulePath, angularRouteModule);
}
exports.resetAngularRoutes = resetAngularRoutes;
function resetIndexForDemoType(tree, demoType) {
    const packages = workspace_2.getPackageNamesToUpdate();
    switch (demoType) {
        case 'angular':
            resetAngularIndex(tree, packages);
            resetAngularRoutes(tree, packages);
            break;
        case 'xml':
            const demoIndexPath = getDemoIndexPathForType(demoType);
            const demoIndexFullPath = `${getDemoAppRoot(demoType)}/${demoIndexPath}`;
            if (tree.exists(demoIndexFullPath)) {
                const indexStringData = tree.read(demoIndexFullPath).toString();
                xml2js.parseString(indexStringData, (err, indexData) => {
                    // console.log('indexData:', indexData);
                    if (indexData && indexData.Page) {
                        if (indexData.Page.StackLayout) {
                            const stackLayout = indexData.Page.StackLayout[0];
                            if (stackLayout && stackLayout.ScrollView) {
                                const scrollView = stackLayout.ScrollView[0];
                                if (scrollView && scrollView.StackLayout) {
                                    const buttons = scrollView.StackLayout[0].Button;
                                    const buttonStructure = buttons[0];
                                    // console.log('buttonStructure:', buttonStructure);
                                    // console.log('buttons:', buttons);
                                    scrollView.StackLayout[0].Button = [];
                                    if (packages.length === 0) {
                                        // resetting to include buttons for all packages
                                        for (const p of workspace_2.getAllPackages(tree)) {
                                            scrollView.StackLayout[0].Button.push({
                                                $: Object.assign(Object.assign({}, buttonStructure.$), { text: p }),
                                            });
                                        }
                                    }
                                    else {
                                        // focus on specific packages for demo testing
                                        for (const p of packages) {
                                            scrollView.StackLayout[0].Button.push({
                                                $: Object.assign(Object.assign({}, buttonStructure.$), { text: p }),
                                            });
                                        }
                                    }
                                    const xmlBuilder = new xml2js.Builder({
                                        headless: true,
                                    });
                                    const modifiedIndex = xmlBuilder.buildObject(indexData);
                                    // console.log('modifiedIndex:', modifiedIndex);
                                    tree.write(demoIndexFullPath, modifiedIndex);
                                }
                            }
                        }
                    }
                });
            }
            break;
    }
}
exports.resetIndexForDemoType = resetIndexForDemoType;
//# sourceMappingURL=demo.js.map