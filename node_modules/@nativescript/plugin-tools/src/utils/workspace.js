"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateReadMe = exports.updateJsonFile = exports.checkPackages = exports.getAllPackages = exports.sanitizeCollectionArgs = exports.jsonParse = exports.getJsonFromFile = exports.updateWorkspaceJson = exports.getPackageNamesToUpdate = exports.setPackageNamesToUpdate = exports.prerun = exports.getNpmPackageNames = exports.getNxNpmScope = exports.getNpmScope = void 0;
/**
 * Workspace utilities
 */
const workspace_1 = require("@nrwl/workspace");
const devkit_1 = require("@nrwl/devkit");
// includes '@' prefix
let npmScope;
// raw scope without '@' prefix
let nxNpmScope;
;
let npmPackageNames;
function getNpmScope() {
    return npmScope;
}
exports.getNpmScope = getNpmScope;
function getNxNpmScope() {
    return nxNpmScope;
}
exports.getNxNpmScope = getNxNpmScope;
function getNpmPackageNames() {
    return npmPackageNames;
}
exports.getNpmPackageNames = getNpmPackageNames;
function prerun(tree) {
    if (!npmScope) {
        const nxConfig = getJsonFromFile(tree, 'nx.json');
        if (nxConfig && nxConfig.npmScope) {
            nxNpmScope = nxConfig.npmScope;
            npmScope = `@${nxConfig.npmScope}`;
        }
    }
    checkPackages(tree);
}
exports.prerun = prerun;
let packageNamesToUpdate;
function setPackageNamesToUpdate(names) {
    packageNamesToUpdate = names;
}
exports.setPackageNamesToUpdate = setPackageNamesToUpdate;
function getPackageNamesToUpdate() {
    return packageNamesToUpdate ? packageNamesToUpdate.filter((n) => n.indexOf('.') === -1) : [];
}
exports.getPackageNamesToUpdate = getPackageNamesToUpdate;
function updateWorkspaceJson(updates) {
    return workspace_1.updateWorkspaceInTree((json) => {
        for (const key in updates) {
            json[key] = Object.assign(Object.assign({}, (json[key] || {})), updates[key]);
        }
        return json;
    });
}
exports.updateWorkspaceJson = updateWorkspaceJson;
function getJsonFromFile(tree, path) {
    return devkit_1.readJson(tree, path);
}
exports.getJsonFromFile = getJsonFromFile;
function jsonParse(content) {
    if (content) {
        return devkit_1.parseJson(content);
    }
    return {};
}
exports.jsonParse = jsonParse;
function sanitizeCollectionArgs(value) {
    return (value || '')
        .split(',')
        .filter((i) => !!i)
        .map((t) => t.toLowerCase().trim())
        .sort();
}
exports.sanitizeCollectionArgs = sanitizeCollectionArgs;
function getAllPackages(tree) {
    return tree
        .children('packages')
        .filter((n) => {
        // only include valid package structures (in case other misc folders are present)
        // ignore hidden files in packages folder (ie, .gitkeep)
        const packagePath = `packages/${n}/package.json`;
        const validPackage = tree.exists(`packages/${n}/package.json`) && n.indexOf('.') === -1;
        if (validPackage) {
            const packageJson = devkit_1.readJson(tree, packagePath);
            if (packageJson && packageJson.name) {
                if (!npmPackageNames) {
                    npmPackageNames = {};
                }
                npmPackageNames[n] = packageJson.name;
            }
        }
        return validPackage;
    })
        .sort();
}
exports.getAllPackages = getAllPackages;
function checkPackages(tree) {
    if (!packageNamesToUpdate) {
        // default to updating demo's for all packages in workspace
        setPackageNamesToUpdate(getAllPackages(tree));
    }
    // console.log('packageNamesToUpdate:' + packageNamesToUpdate);
}
exports.checkPackages = checkPackages;
function updateJsonFile(tree, path, jsonData) {
    try {
        tree.write(path, workspace_1.serializeJson(jsonData));
        return tree;
    }
    catch (err) {
        // console.warn(err);
        throw new Error(`${path}: ${err}`);
    }
}
exports.updateJsonFile = updateJsonFile;
function updateReadMe(tree, packages) {
    const readmePath = 'README.md';
    let readmeContent = tree.read(readmePath).toString('utf-8');
    // Add package as build option
    const listPackageSectionIndex = readmeContent.indexOf(`- ${npmScope}`);
    const readmeStart = readmeContent.substring(0, listPackageSectionIndex);
    const listEndIndex = readmeContent.indexOf(`# How to`);
    const readmeEnd = readmeContent.substring(listEndIndex, readmeContent.length);
    const packageNames = packages || getAllPackages(tree);
    const npmPackageNames = getNpmPackageNames();
    let packageList = '';
    for (const packageName of packageNames) {
        packageList += `- [${npmPackageNames[packageName]}](packages/${packageName}/README.md)\n`;
    }
    readmeContent = `${readmeStart}${packageList}\n${readmeEnd}`;
    // console.log(readmeContent);
    tree.write(readmePath, readmeContent);
}
exports.updateReadMe = updateReadMe;
//# sourceMappingURL=workspace.js.map