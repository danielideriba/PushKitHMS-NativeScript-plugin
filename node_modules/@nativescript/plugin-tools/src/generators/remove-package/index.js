"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateDemoSharedIndex = exports.updateDemoDependencies = exports.resetAngularRoutes = exports.resetAngularIndex = void 0;
const devkit_1 = require("@nrwl/devkit");
const workspace_1 = require("@nrwl/workspace");
const utils_1 = require("../../utils");
let name;
let npmPackageName;
function default_1(tree, schema) {
    name = workspace_1.stringUtils.dasherize(schema.name);
    utils_1.prerun(tree);
    const packagePath = `packages/${name}/package.json`;
    if (tree.exists(packagePath)) {
        const packageJson = devkit_1.readJson(tree, packagePath);
        npmPackageName = packageJson.name;
        removePackage(tree);
        devkit_1.removeProjectConfiguration(tree, name);
        removeFromBuildAll(tree);
        utils_1.updateReadMe(tree, getUpdatedPackages(tree));
        for (const t of utils_1.getDemoTypes()) {
            const demoAppRoot = utils_1.getDemoAppRoot(t);
            if (tree.exists(`${demoAppRoot}/package.json`)) {
                removeDemoFiles(tree, t, demoAppRoot);
                removeFromDemoIndex(tree, t, demoAppRoot);
                updateDemoDependencies(tree, demoAppRoot);
            }
        }
        removeSharedDemoFiles(tree);
        updateDemoSharedIndex(tree);
        console.log(`"${npmPackageName}" removed from 'packages' and removed from all demo apps.`);
    }
    else {
        console.error(`Nothing found at 'packages/${name}/package.json' to remove.`);
    }
}
exports.default = default_1;
function removePackage(tree) {
    console.log(`Removing plugin ${name}...`);
    tree.delete(`packages/${name}`);
}
function removeFromBuildAll(tree) {
    var _a, _b, _c;
    const allConfig = devkit_1.readProjectConfiguration(tree, 'all');
    if (allConfig) {
        let commands = [];
        if ((_c = (_b = (_a = allConfig.targets) === null || _a === void 0 ? void 0 : _a.build) === null || _b === void 0 ? void 0 : _b.options) === null || _c === void 0 ? void 0 : _c.commands) {
            commands = allConfig.targets.build.options.commands;
            const index = commands.indexOf(`nx run ${name}:build.all`);
            if (index > -1) {
                commands.splice(index, 1);
            }
        }
        devkit_1.updateProjectConfiguration(tree, 'all', Object.assign(Object.assign({}, allConfig), { targets: {
                build: {
                    executor: allConfig.targets.build.executor,
                    outputs: ['dist/packages'],
                    options: {
                        commands,
                        parallel: false,
                    },
                },
                focus: allConfig.targets.focus,
            } }));
    }
}
function removeDemoFiles(tree, type, demoAppRoot) {
    const demoAppFolder = `${demoAppRoot}/${utils_1.getPluginDemoPath(type)}`;
    console.log(`Removing demo files in "${demoAppFolder}"`);
    let viewExt = 'xml';
    let viewClassExt = 'ts';
    let viewModuleExt;
    // adjust folder location and viewExt dependent on demo type if needed
    switch (type) {
        case 'angular':
            viewExt = 'component.html';
            viewClassExt = 'component.ts';
            viewModuleExt = 'module.ts';
            break;
        case 'react':
            viewExt = 'tsx';
            viewClassExt = null;
            break;
        case 'svelte':
            viewExt = 'svelte';
            viewClassExt = null;
            break;
        case 'vue':
            viewExt = 'vue';
            viewClassExt = null;
            break;
    }
    let packageDemoViewModulePath;
    if (viewModuleExt) {
        packageDemoViewModulePath = `${demoAppFolder}/${name}.${viewModuleExt}`;
    }
    const packageDemoViewPath = `${demoAppFolder}/${name}.${viewExt}`;
    const packageDemoViewClassPath = viewClassExt ? `${demoAppFolder}/${name}.${viewClassExt}` : null;
    // console.log('packageDemoViewPath: ' + packageDemoViewPath);
    if (tree.exists(packageDemoViewPath)) {
        tree.delete(packageDemoViewPath);
    }
    if (packageDemoViewClassPath && tree.exists(packageDemoViewClassPath)) {
        tree.delete(packageDemoViewClassPath);
    }
    if (packageDemoViewModulePath && tree.exists(packageDemoViewModulePath)) {
        tree.delete(packageDemoViewModulePath);
    }
}
function removeFromDemoIndex(tree, type, demoAppRoot) {
    utils_1.checkPackages(tree);
    if (type === 'angular') {
        resetAngularIndex(tree);
        resetAngularRoutes(tree);
        return tree;
    }
    else if (['react', 'svelte', 'vue'].includes(type)) {
        // TODO: add index page for these flavors
        return tree;
    }
    const demoIndexViewPath = `${demoAppRoot}/${utils_1.getDemoIndexPathForType(type)}`;
    let indexViewContent = tree.read(demoIndexViewPath).toString('utf-8');
    indexViewContent = indexViewContent.replace(`<Button text="${name}" tap="{{ viewDemo }}" class="btn btn-primary view-demo"/>`, '');
    // console.log(indexViewContent);
    tree.write(demoIndexViewPath, indexViewContent);
}
function resetAngularIndex(tree) {
    const angularIndexPath = `${utils_1.getDemoAppRoot('angular')}/${utils_1.getDemoIndexPathForType('angular')}`;
    let angularIndex = tree.read(angularIndexPath).toString();
    const demosIndex = angularIndex.indexOf('[');
    angularIndex =
        angularIndex.substring(0, demosIndex + 1) +
            getUpdatedPackages(tree)
                .sort()
                .map((p) => `\n	{\n		name: '${p}'\n	}`)
                .join(',') +
            '\n];\n}';
    tree.write(angularIndexPath, angularIndex);
}
exports.resetAngularIndex = resetAngularIndex;
function resetAngularRoutes(tree) {
    const angularRouteModulePath = `${utils_1.getDemoAppRoot('angular')}/src/app-routing.module.ts`;
    let angularRouteModule = tree.read(angularRouteModulePath).toString();
    const routeDefIndex = angularRouteModule.indexOf('const routes');
    const routeModuleStart = angularRouteModule.substring(0, routeDefIndex);
    const routeMoudleDefIndex = angularRouteModule.indexOf('@NgModule');
    const routeModuleEnd = angularRouteModule.substring(routeMoudleDefIndex, angularRouteModule.length);
    const packageRoutes = getUpdatedPackages(tree)
        .sort()
        .map((p) => `	{ path: '${p}', loadChildren: () => import('./plugin-demos/${p}.module').then(m => m.${workspace_1.stringUtils.classify(p)}Module) }`)
        .join(',\n') + '\n];\n\n';
    const routeStart = `const routes: Routes = [
   { path: '', redirectTo: '/home', pathMatch: 'full' },
   { path: 'home', component: HomeComponent },\n`;
    angularRouteModule = routeModuleStart + routeStart + packageRoutes + routeModuleEnd;
    // console.log('angularRouteModule:', angularRouteModule);
    tree.write(angularRouteModulePath, angularRouteModule);
}
exports.resetAngularRoutes = resetAngularRoutes;
function updateDemoDependencies(tree, demoAppRoot) {
    const packagePath = `${demoAppRoot}/package.json`;
    devkit_1.updateJson(tree, packagePath, (json) => {
        json.dependencies = json.dependencies || {};
        delete json.dependencies[npmPackageName];
        return json;
    });
}
exports.updateDemoDependencies = updateDemoDependencies;
function removeSharedDemoFiles(tree) {
    tree.delete(`tools/demo/${name}`);
}
function updateDemoSharedIndex(tree) {
    const demoSharedPath = `tools/demo/index.ts`;
    const demoSharedExport = (name) => {
        return `export * from './${name}';\n`;
    };
    const demoSharedIndex = `export * from './utils';\n${getUpdatedPackages(tree).sort().map(demoSharedExport).join('')}`;
    tree.write(demoSharedPath, demoSharedIndex);
}
exports.updateDemoSharedIndex = updateDemoSharedIndex;
function getUpdatedPackages(tree) {
    utils_1.checkPackages(tree);
    return utils_1.getPackageNamesToUpdate().filter((n) => n !== name);
}
//# sourceMappingURL=index.js.map