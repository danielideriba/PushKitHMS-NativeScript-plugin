"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const devkit_1 = require("@nrwl/devkit");
const workspace_1 = require("@nrwl/workspace");
const utils_1 = require("../../utils");
let npmPackageNames;
function default_1(tree, schema, relativePrefix, addingNew) {
    if (schema) {
        if (schema.types) {
            // only updating specific demo types
            const demoTypes = utils_1.sanitizeCollectionArgs(schema.types);
            for (const t of demoTypes) {
                if (!utils_1.SupportedDemoTypes.includes(t)) {
                    throw new Error(`Can only update supported demo types: ${utils_1.SupportedDemoTypes.join()}`);
                }
            }
            utils_1.setDemoTypes(demoTypes);
        }
        if (schema.packages) {
            // only updating demo's for specific packages
            utils_1.setPackageNamesToUpdate(utils_1.sanitizeCollectionArgs(schema.packages).sort());
        }
    }
    utils_1.prerun(tree);
    npmPackageNames = utils_1.getNpmPackageNames();
    for (const t of utils_1.getDemoTypes()) {
        const demoAppRoot = utils_1.getDemoAppRoot(t);
        if (tree.exists(`${demoAppRoot}/package.json`)) {
            addDemoFiles(tree, t, demoAppRoot, relativePrefix);
            addToDemoIndex(tree, t, demoAppRoot);
            utils_1.addDependencyToDemoApp(tree, t, demoAppRoot);
        }
    }
    addDemoSharedFiles(tree, relativePrefix);
    utils_1.updateDemoSharedIndex(tree, utils_1.getAllPackages(tree), utils_1.getPackageNamesToUpdate(), addingNew);
    devkit_1.formatFiles(tree);
}
exports.default = default_1;
function addDemoFiles(tree, type, demoAppRoot, relativePrefix = '') {
    console.log(`Updating "${demoAppRoot}"`);
    const demoAppFolder = `${demoAppRoot}/${utils_1.getPluginDemoPath(type)}`;
    const { viewExt, viewClassExt, viewModuleExt } = utils_1.getDemoFlavorExt(type);
    for (const name of utils_1.getPackageNamesToUpdate()) {
        const packageDemoViewPath = `${demoAppFolder}/${name}.${viewExt}`;
        // console.log('packageDemoViewPath: ' + packageDemoViewPath);
        if (!tree.exists(packageDemoViewPath)) {
            // console.log('packageDemoViewPath: DID NOT EXIST!');
            devkit_1.generateFiles(tree, devkit_1.joinPathFragments(__dirname, relativePrefix, `files_${type}`), demoAppFolder, {
                name,
                npmPackageName: npmPackageNames[name],
                npmScope: utils_1.getNpmScope(),
                stringUtils: workspace_1.stringUtils,
                tmpl: '',
                dot: '.',
            });
        }
    }
}
function addToDemoIndex(tree, type, demoAppRoot) {
    utils_1.checkPackages(tree);
    if (type === 'angular') {
        utils_1.resetAngularIndex(tree, utils_1.getPackageNamesToUpdate(), true);
        utils_1.resetAngularRoutes(tree, utils_1.getPackageNamesToUpdate(), true);
        return tree;
    }
    else if (['react', 'svelte', 'vue'].includes(type)) {
        // TODO: add index page for these flavors
        return tree;
    }
    const demoIndexViewPath = `${demoAppRoot}/${utils_1.getDemoIndexPathForType(type)}`;
    let indexViewContent = tree.read(demoIndexViewPath).toString('utf-8');
    // adjust index view app path dependent on demo type
    for (const name of utils_1.getPackageNamesToUpdate()) {
        switch (type) {
            case 'xml':
                const { buttonMarkup } = utils_1.getDemoIndexButtonForType(type, name);
                if (indexViewContent.indexOf(`Button text="${name}"`) === -1) {
                    // get index of last view-demo button
                    const lastBtnLocatorIndex = indexViewContent.lastIndexOf('view-demo');
                    // get final content after that last button
                    const remainingContent = indexViewContent.substr(lastBtnLocatorIndex, indexViewContent.length);
                    // get first line break to determine position of where to insert next button
                    const firstLB = remainingContent.indexOf('\n');
                    const endingContent = indexViewContent.substring(lastBtnLocatorIndex + firstLB, indexViewContent.length);
                    // console.log('buttonMarkup: ' + buttonMarkup);
                    indexViewContent = indexViewContent.substring(0, lastBtnLocatorIndex + firstLB) + `\n${buttonMarkup}` + endingContent;
                }
                break;
        }
    }
    // console.log(indexViewContent);
    tree.write(demoIndexViewPath, indexViewContent);
}
function addDemoSharedFiles(tree, relativePrefix = '') {
    const demoSharedPath = `tools/demo`;
    console.log(`Updating shared demo code in "${demoSharedPath}"`);
    for (const name of utils_1.getPackageNamesToUpdate()) {
        const demoSharedIndex = `${demoSharedPath}/${name}/index.ts`;
        // console.log('packageDemoViewPath: ' + packageDemoViewPath);
        if (!tree.exists(demoSharedIndex)) {
            // console.log('packageDemoViewPath: DID NOT EXIST!');
            devkit_1.generateFiles(tree, devkit_1.joinPathFragments(__dirname, relativePrefix, `files_demo_shared`), demoSharedPath, {
                name,
                npmPackageName: npmPackageNames[name],
                npmScope: utils_1.getNpmScope(),
                stringUtils: workspace_1.stringUtils,
                tmpl: '',
                dot: '.',
            });
        }
    }
}
//# sourceMappingURL=index.js.map