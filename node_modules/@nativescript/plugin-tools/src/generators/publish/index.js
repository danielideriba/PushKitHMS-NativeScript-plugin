"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const utils_1 = require("../../utils");
const parse_version_string_1 = require("parse-version-string");
const workspace_1 = require("@nrwl/workspace");
const child_process_1 = require("child_process");
const path = require("path");
const fs_1 = require("fs");
let publishPackages;
let packageVersions;
let version;
let npmScope;
// console.log('__dirname:', __dirname);
const workspaceDir = path.resolve(__dirname, '../../../../../..');
// console.log(`workspaceDir:`, workspaceDir);
function default_1(tree, schema) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        publishPackages = utils_1.sanitizeCollectionArgs(schema.name);
        if (schema.version) {
            version = parse_version_string_1.default(schema.version);
        }
        utils_1.prerun(tree);
        if (schema.verify) {
            npmScope = utils_1.getNpmScope();
            utils_1.setPackageNamesToUpdate(publishPackages);
            const allPackages = utils_1.getAllPackages(tree);
            packageVersions = [];
            // console.log('allPackages:', allPackages);
            if (!publishPackages || (publishPackages && publishPackages.length === 0)) {
                // when nothing is specified default to all
                publishPackages = allPackages;
            }
            for (const p of publishPackages) {
                // const packageJsonPath = `packages/${p}/package.json`;
                // const packageJson = getJsonFromFile(tree, packageJsonPath);
                const packageJsonPath = path.resolve(workspaceDir, 'packages', p, 'package.json');
                let packageJson = fs_1.readFileSync(packageJsonPath, { encoding: 'utf-8' });
                if (packageJson) {
                    packageJson = utils_1.jsonParse(packageJson);
                    // console.log(`packageJson:`, packageJson);
                    const currentVersion = packageJson.version;
                    const parsedVersion = parse_version_string_1.default(currentVersion);
                    if (version) {
                        packageJson.version = schema.version;
                    }
                    else {
                        // when no version is specified, bump the patch version
                        // console.log('p:', p, 'version:', parsedVersion);
                        if (parsedVersion.preReleaseLabel) {
                            parsedVersion.preReleaseIncrement = typeof parsedVersion.preReleaseIncrement === 'number' ? parsedVersion.preReleaseIncrement + 1 : 0;
                        }
                        else {
                            parsedVersion.patch = parsedVersion.patch + 1;
                        }
                        packageJson.version = `${parsedVersion.major}.${parsedVersion.minor}.${parsedVersion.patch}${parsedVersion.preReleaseLabel ? '-' + parsedVersion.preReleaseType + '.' + parsedVersion.patch : ''}`;
                    }
                    const fullPackageName = packageJson.name;
                    console.log('\n\nðŸ‘€ ', fullPackageName, '-- current:', currentVersion, '> â¬† bumping to:', packageJson.version);
                    packageVersions.push({
                        name: fullPackageName,
                        package: p,
                        version: packageJson.version,
                        parsedVersion: parse_version_string_1.default(packageJson.version),
                    });
                    fs_1.writeFileSync(packageJsonPath, workspace_1.serializeJson(packageJson));
                    // tree.overwrite(packageJsonPath, serializeJson(packageJson));
                }
            }
        }
        if (schema.verify) {
            yield new Promise((resolve, reject) => {
                // console.log(options.args);
                let cnt = 0;
                const buildPackage = () => {
                    const p = publishPackages[cnt];
                    const cmdArgs = ['run', `${p}:build.all`];
                    const child = child_process_1.spawn(`nx`, cmdArgs, {
                        cwd: workspaceDir,
                        stdio: 'inherit',
                        shell: true,
                    });
                    child.on('error', (error) => {
                        console.log('build emitted error:', error);
                        reject(error);
                    });
                    child.on('close', (res) => {
                        console.log('build finished with code:', res);
                        child.kill();
                        cnt++;
                        if (cnt === publishPackages.length) {
                            console.log(`âœ… Successfully built ${packageVersions.map((p) => `${p.name}:${p.version}`).join(',')}`);
                            resolve();
                        }
                        else {
                            buildPackage();
                        }
                    });
                };
                buildPackage();
            });
        }
        if (schema.verify) {
            yield new Promise((resolve, reject) => {
                let cnt = 0;
                const publishPackage = () => {
                    const p = publishPackages[cnt];
                    const packageDetails = packageVersions.find((pck) => pck.package === p);
                    console.log(`âš¡ publishing ${packageDetails.name} ${packageDetails.version}`);
                    // console.log('dist path:', path.resolve(workspaceDir, 'dist', 'packages', p));
                    const cmdArgs = ['publish', '--access', 'public'];
                    if (packageDetails.parsedVersion.preReleaseLabel) {
                        cmdArgs.push(`--tag`);
                        cmdArgs.push(packageDetails.parsedVersion.preReleaseType);
                    }
                    const child = child_process_1.spawn(`npm`, cmdArgs, {
                        cwd: path.resolve(workspaceDir, 'dist', 'packages', p),
                        stdio: 'inherit',
                        shell: true,
                    });
                    child.on('error', (error) => {
                        console.log('publish emitted error:', error);
                        reject(error);
                    });
                    child.on('close', (res) => {
                        console.log('publish finished with code:', res);
                        child.kill();
                        cnt++;
                        if (cnt === publishPackages.length) {
                            console.log(`ðŸš€ Successfully published:\n${packageVersions.map((p) => `\n* ${p.name}:${p.version}`).join(', ')}\n\n`);
                            resolve();
                        }
                        else {
                            publishPackage();
                        }
                    });
                };
                publishPackage();
            });
        }
    });
}
exports.default = default_1;
//# sourceMappingURL=index.js.map